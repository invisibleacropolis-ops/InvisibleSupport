<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Invisible Support Portal</title>
    <style>
      /*
        Design tokens create a consistent visual system for engineers and designers.
        Tokens are exposed as CSS custom properties so themes can be swapped or extended.
      */
      :root {
        color-scheme: light dark;
        --color-surface: #ffffff;
        --color-surface-muted: #f5f7fa;
        --color-elevated: #ffffffee;
        --color-border: #d8dee6;
        --color-text: #1c2333;
        --color-text-muted: #546173;
        --color-accent: #4b6bfb;
        --color-accent-strong: #2e51f0;
        --color-success: #3bb273;
        --color-danger: #f25757;
        --color-immersive: 200 56% 16%;

        --font-sans: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
        --font-mono: "JetBrains Mono", "SFMono-Regular", ui-monospace, monospace;

        --space-2xs: 0.25rem;
        --space-xs: 0.5rem;
        --space-sm: 0.75rem;
        --space-md: 1rem;
        --space-lg: 1.5rem;
        --space-xl: 2rem;
        --space-2xl: 3rem;

        --radius-sm: 0.5rem;
        --radius-md: 0.75rem;
        --radius-lg: 1.5rem;

        --shadow-sm: 0 8px 20px rgba(28, 35, 51, 0.08);
        --shadow-lg: 0 24px 60px rgba(28, 35, 51, 0.16);

        --transition-base: 180ms ease;
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --color-surface: #101321;
          --color-surface-muted: #161a2d;
          --color-elevated: rgba(18, 22, 38, 0.9);
          --color-border: rgba(119, 131, 160, 0.3);
          --color-text: #f5f7ff;
          --color-text-muted: #a6b2d2;
        }
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      html {
        height: 100%;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: var(--font-sans);
        background: var(--color-surface-muted);
        color: var(--color-text);
        overflow-y: auto;
        overflow-x: hidden;
        scrollbar-gutter: stable;
      }

      body::-webkit-scrollbar {
        width: 0.75rem;
      }

      body::-webkit-scrollbar-track {
        background: color-mix(in srgb, var(--color-surface-muted) 80%, transparent 20%);
      }

      body::-webkit-scrollbar-thumb {
        background: color-mix(in srgb, var(--color-accent) 45%, transparent 55%);
        border-radius: var(--radius-md);
      }

      .theme {
        position: relative;
        overflow-x: hidden;
        overflow-y: visible;
      }

      .theme--immersive::before {
        content: "";
        position: fixed;
        inset: 0;
        background: radial-gradient(
            circle at 10% 20%,
            hsla(var(--color-immersive) / 0.6) 0,
            transparent 55%
          ),
          radial-gradient(
            circle at 80% 10%,
            hsla(220 60% 40% / 0.55) 0,
            transparent 50%
          ),
          radial-gradient(
            circle at 50% 100%,
            hsla(260 65% 45% / 0.45) 0,
            transparent 60%
          );
        pointer-events: none;
        opacity: 0.9;
        z-index: -2;
      }

      .theme--immersive::after {
        content: "";
        position: fixed;
        inset: 0;
        background: linear-gradient(
          180deg,
          rgba(12, 16, 28, 0.35) 0%,
          rgba(12, 16, 28, 0.1) 35%,
          rgba(12, 16, 28, 0.65) 100%
        );
        mix-blend-mode: multiply;
        pointer-events: none;
        z-index: -1;
      }

      .portal {
        position: relative;
        padding: var(--space-2xl) clamp(var(--space-md), 6vw, var(--space-2xl));
        display: flex;
        flex-direction: column;
        gap: var(--space-xl);
      }

      .portal__header {
        display: flex;
        flex-direction: column;
        gap: var(--space-sm);
        max-width: 48rem;
      }

      .storage-meter {
        display: grid;
        gap: var(--space-xs);
        padding: var(--space-sm) var(--space-md);
        border-radius: var(--radius-md);
        border: 1px solid color-mix(in srgb, var(--color-border) 75%, transparent 25%);
        background: color-mix(in srgb, var(--color-surface) 88%, transparent 12%);
        max-width: min(24rem, 100%);
      }

      .storage-meter__heading {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: var(--space-sm);
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--color-text-muted);
      }

      .storage-meter__values {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: var(--space-sm);
        font-size: 0.9rem;
        font-weight: 600;
      }

      .storage-meter__progress {
        position: relative;
        height: 0.5rem;
        border-radius: var(--radius-md);
        background: color-mix(in srgb, var(--color-border) 50%, transparent 50%);
        overflow: hidden;
      }

      .storage-meter__progress-bar {
        position: absolute;
        inset: 0;
        width: 0%;
        border-radius: inherit;
        background: linear-gradient(90deg, var(--color-accent), var(--color-accent-strong));
        transition: width var(--transition-base);
      }

      .storage-meter.is-warning .storage-meter__progress-bar {
        background: linear-gradient(90deg, var(--color-danger), color-mix(in srgb, var(--color-danger) 70%, var(--color-accent) 30%));
      }

      .storage-meter__warning {
        margin: 0;
        font-size: 0.85rem;
        color: var(--color-danger);
      }

      .storage-meter__actions {
        display: flex;
        justify-content: flex-end;
      }

      .storage-meter__button {
        font-size: 0.85rem;
        padding: var(--space-2xs) var(--space-sm);
      }

      .portal__heading {
        font-size: clamp(2rem, 3vw, 2.75rem);
        font-weight: 700;
        letter-spacing: -0.01em;
        margin: 0;
      }

      .portal__lede {
        margin: 0;
        color: var(--color-text-muted);
        font-size: 1.05rem;
        line-height: 1.6;
      }

      .portal__grid {
        display: grid;
        grid-template-columns: minmax(0, 3fr) minmax(0, 2.5fr);
        gap: var(--space-xl);
        align-items: start;
      }

      @media (max-width: 960px) {
        .portal__grid {
          grid-template-columns: 1fr;
        }

        .portal__column--secondary {
          order: -1;
        }
      }

      .image-portal {
        display: grid;
        gap: var(--space-xl);
      }

      .image-portal__header {
        display: flex;
        flex-direction: column;
        gap: var(--space-sm);
        max-width: 48rem;
      }

      .image-portal__grid {
        display: grid;
        grid-template-columns: minmax(0, 3fr) minmax(0, 2.5fr);
        gap: var(--space-xl);
        align-items: start;
      }

      .image-portal__column {
        display: grid;
        gap: var(--space-xl);
      }

      @media (max-width: 960px) {
        .image-portal__grid {
          grid-template-columns: 1fr;
        }
      }

      .toast-stack {
        position: fixed;
        bottom: var(--space-xl);
        right: var(--space-xl);
        display: grid;
        gap: var(--space-sm);
        width: min(24rem, calc(100vw - 2 * var(--space-xl)));
        z-index: 1000;
        pointer-events: none;
      }

      .toast {
        display: flex;
        align-items: center;
        gap: var(--space-sm);
        border-radius: var(--radius-md);
        padding: var(--space-sm) var(--space-md);
        background: var(--color-elevated);
        border: 1px solid color-mix(in srgb, var(--color-border) 70%, transparent 30%);
        box-shadow: var(--shadow-sm);
        color: var(--color-text);
        opacity: 0;
        transform: translateY(10px);
        transition: opacity var(--transition-base), transform var(--transition-base);
        pointer-events: auto;
      }

      .toast.is-visible {
        opacity: 1;
        transform: translateY(0);
      }

      .toast__icon {
        font-size: 1.2rem;
      }

      .toast__message {
        flex: 1 1 auto;
      }

      .toast__dismiss {
        margin-left: auto;
        appearance: none;
        border: none;
        background: transparent;
        color: var(--color-text-muted);
        font-weight: 600;
        cursor: pointer;
        padding: var(--space-2xs) var(--space-xs);
      }

      .toast__dismiss:hover {
        color: var(--color-text);
      }

      .toast__dismiss:focus-visible {
        outline: 2px solid color-mix(in srgb, var(--color-accent) 65%, white 35%);
        outline-offset: 2px;
        border-radius: var(--radius-sm);
      }

      .toast--success {
        border-color: color-mix(in srgb, var(--color-success) 40%, transparent 60%);
      }

      .toast--success .toast__icon {
        color: var(--color-success);
      }

      .toast--error {
        border-color: color-mix(in srgb, var(--color-danger) 40%, transparent 60%);
      }

      .toast--error .toast__icon {
        color: var(--color-danger);
      }

      .toast--info {
        border-color: color-mix(in srgb, var(--color-accent) 40%, transparent 60%);
      }

      .toast--info .toast__icon {
        color: var(--color-accent-strong);
      }

      @media (max-width: 640px) {
        .toast-stack {
          left: var(--space-md);
          right: var(--space-md);
          width: auto;
          bottom: var(--space-lg);
        }
      }

      /* Utility foundation */
      .u-card {
        background: var(--color-elevated);
        border-radius: var(--radius-lg);
        border: 1px solid var(--color-border);
        box-shadow: var(--shadow-sm);
        padding: var(--space-xl) clamp(var(--space-lg), 4vw, var(--space-xl));
        backdrop-filter: blur(14px);
        display: flex;
        flex-direction: column;
        gap: var(--space-lg);
      }

      .u-card__header {
        display: flex;
        flex-direction: column;
        gap: var(--space-xs);
      }

      .u-card__title {
        font-size: 1.35rem;
        font-weight: 600;
        margin: 0;
      }

      .u-card__subtitle {
        margin: 0;
        color: var(--color-text-muted);
        font-size: 0.95rem;
      }

      .u-btn {
        appearance: none;
        border: none;
        border-radius: var(--radius-md);
        padding: var(--space-sm) var(--space-lg);
        font-size: 0.95rem;
        font-weight: 600;
        letter-spacing: 0.01em;
        cursor: pointer;
        transition: transform var(--transition-base),
          box-shadow var(--transition-base),
          background-color var(--transition-base);
      }

      .u-btn:focus-visible {
        outline: 3px solid color-mix(in srgb, var(--color-accent) 60%, white 40%);
        outline-offset: 2px;
      }

      .u-btn--primary {
        background: linear-gradient(135deg, var(--color-accent), var(--color-accent-strong));
        color: white;
        box-shadow: 0 12px 24px rgba(75, 107, 251, 0.32);
      }

      .u-btn--primary:hover {
        transform: translateY(-1px);
      }

      .u-btn--ghost {
        background: color-mix(in srgb, var(--color-accent) 12%, transparent 88%);
        color: var(--color-accent-strong);
        border: 1px solid color-mix(in srgb, var(--color-accent) 40%, transparent 60%);
      }

      .u-input {
        width: 100%;
        border-radius: var(--radius-md);
        border: 1px solid var(--color-border);
        background: color-mix(in srgb, var(--color-surface) 90%, transparent 10%);
        padding: var(--space-sm) var(--space-md);
        font-size: 1rem;
        color: var(--color-text);
        transition: border-color var(--transition-base), box-shadow var(--transition-base);
      }

      .u-input:focus {
        border-color: color-mix(in srgb, var(--color-accent) 60%, var(--color-border) 40%);
        box-shadow: 0 0 0 4px color-mix(in srgb, var(--color-accent) 16%, transparent 84%);
        outline: none;
      }

      .u-input[type="file"] {
        padding: var(--space-sm);
      }

      .u-tabs {
        display: flex;
        gap: var(--space-xs);
        border-radius: var(--radius-md);
        background: color-mix(in srgb, var(--color-surface) 65%, transparent 35%);
        padding: var(--space-2xs);
      }

      .u-tabs__trigger {
        flex: 1 1 auto;
        text-align: center;
        padding: var(--space-sm) var(--space-md);
        border-radius: var(--radius-md);
        font-size: 0.9rem;
        color: var(--color-text-muted);
        cursor: pointer;
        transition: background-color var(--transition-base), color var(--transition-base);
      }

      .u-tabs__trigger.is-active {
        background: var(--color-surface);
        color: var(--color-text);
        box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--color-border) 80%, transparent 20%);
      }

      .u-modal {
        position: fixed;
        inset: 0;
        display: none;
        place-items: center;
        padding: var(--space-xl);
        background: rgba(12, 16, 28, 0.45);
        backdrop-filter: blur(10px);
      }

      .u-modal.is-open {
        display: grid;
      }

      .u-modal__dialog {
        background: var(--color-elevated);
        padding: var(--space-xl);
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-lg);
        max-width: 28rem;
        width: min(100%, 28rem);
      }

      .u-copy {
        display: flex;
        gap: var(--space-sm);
        align-items: center;
        padding: var(--space-sm) var(--space-md);
        border-radius: var(--radius-md);
        border: 1px dashed color-mix(in srgb, var(--color-border) 75%, transparent 25%);
        background: color-mix(in srgb, var(--color-surface) 80%, transparent 20%);
      }

      .u-copy__value {
        flex: 1 1 auto;
        font-family: var(--font-mono);
        font-size: 0.95rem;
        overflow-wrap: anywhere;
      }

      .u-copy__button {
        padding: var(--space-2xs) var(--space-sm);
        border-radius: var(--radius-sm);
        background: transparent;
        color: var(--color-accent-strong);
        border: 1px solid color-mix(in srgb, var(--color-accent) 35%, transparent 65%);
        cursor: pointer;
      }

      .stack {
        display: flex;
        flex-direction: column;
        gap: var(--space-md);
      }

      .stack--lg {
        gap: var(--space-lg);
      }

      .upload-card__dropzone {
        position: relative;
        border-radius: var(--radius-lg);
        border: 2px dashed color-mix(in srgb, var(--color-border) 70%, transparent 30%);
        padding: clamp(var(--space-lg), 6vw, var(--space-2xl));
        text-align: center;
        display: grid;
        gap: var(--space-md);
        background: color-mix(
          in srgb,
          var(--color-surface) 85%,
          rgba(255, 255, 255, 0.85) 15%
        );
        transition: border-color var(--transition-base),
          background-color var(--transition-base),
          transform var(--transition-base);
      }

      .upload-card__dropzone.is-dragover {
        border-color: color-mix(in srgb, var(--color-accent) 60%, transparent 40%);
        background: color-mix(in srgb, var(--color-surface) 75%, rgba(75, 107, 251, 0.12) 25%);
        transform: translateY(-2px);
      }

      .upload-card__dropzone input[type="file"] {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        pointer-events: none;
      }

      .upload-card__accepted {
        margin: 0;
        font-size: 0.9rem;
        color: var(--color-text-muted);
      }

      .upload-card__dropzone svg {
        width: 3rem;
        height: 3rem;
        margin: 0 auto;
        color: var(--color-accent-strong);
      }

      .upload-card__actions {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-sm);
        justify-content: center;
      }

      .form-grid {
        display: grid;
        gap: var(--space-md);
      }

      .form-grid--split {
        grid-template-columns: repeat(auto-fit, minmax(12rem, 1fr));
        gap: var(--space-md);
      }

      .image-gallery__toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-sm);
        justify-content: space-between;
        align-items: center;
      }

      .image-gallery__search {
        flex: 1 1 16rem;
      }

      .image-gallery__views {
        display: inline-flex;
        gap: var(--space-2xs);
        padding: var(--space-2xs);
        border-radius: var(--radius-md);
        background: color-mix(in srgb, var(--color-surface) 65%, transparent 35%);
      }

      .image-gallery__view {
        border: none;
        background: transparent;
        color: var(--color-text-muted);
        padding: var(--space-2xs) var(--space-sm);
        border-radius: var(--radius-md);
        font-size: 0.85rem;
        cursor: pointer;
        transition: background-color var(--transition-base), color var(--transition-base);
      }

      .image-gallery__view.is-active {
        background: var(--color-surface);
        color: var(--color-text);
        box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--color-border) 80%, transparent 20%);
      }

      .image-gallery__items {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: var(--space-md);
      }

      .image-gallery__items--grid {
        grid-template-columns: repeat(auto-fill, minmax(10rem, 1fr));
      }

      .image-gallery__items--list {
        grid-template-columns: 1fr;
      }

      .image-gallery__item {
        min-width: 0;
      }

      .image-gallery__thumb {
        width: 100%;
        display: grid;
        gap: var(--space-sm);
        padding: var(--space-sm);
        border-radius: var(--radius-lg);
        border: 1px solid color-mix(in srgb, var(--color-border) 80%, transparent 20%);
        background: color-mix(in srgb, var(--color-surface) 88%, transparent 12%);
        cursor: pointer;
        text-align: left;
        transition: border-color var(--transition-base), box-shadow var(--transition-base), transform var(--transition-base);
      }

      .image-gallery__thumb:hover,
      .image-gallery__thumb:focus-visible {
        outline: none;
        border-color: color-mix(in srgb, var(--color-accent) 50%, transparent 50%);
        box-shadow: 0 12px 24px rgba(75, 107, 251, 0.16);
        transform: translateY(-1px);
      }

      .image-gallery__thumb.is-selected {
        border-color: color-mix(in srgb, var(--color-accent) 65%, transparent 35%);
        box-shadow: 0 16px 32px rgba(75, 107, 251, 0.24);
      }

      .image-gallery__thumb-media {
        position: relative;
        aspect-ratio: 4 / 3;
        overflow: hidden;
        border-radius: var(--radius-md);
        background: color-mix(in srgb, var(--color-surface-muted) 85%, transparent 15%);
      }

      .image-gallery__thumb-media img {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        transition: transform var(--transition-base);
      }

      .image-gallery__thumb:hover .image-gallery__thumb-media img,
      .image-gallery__thumb:focus-visible .image-gallery__thumb-media img {
        transform: scale(1.03);
      }

      .image-gallery__thumb-meta {
        display: grid;
        gap: var(--space-2xs);
        font-size: 0.85rem;
        color: var(--color-text-muted);
      }

      .image-gallery__meta-title {
        font-weight: 600;
        font-size: 0.95rem;
        color: var(--color-text);
      }

      .image-gallery__meta-subtitle {
        color: var(--color-text-muted);
      }

      .image-gallery__thumb-extra {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-2xs);
        font-size: 0.75rem;
        color: var(--color-text-muted);
      }

      .image-gallery__items--list .image-gallery__thumb {
        grid-template-columns: minmax(0, 9rem) minmax(0, 1fr);
        align-items: center;
      }

      .image-gallery__items--list .image-gallery__thumb-media {
        width: 100%;
      }

      .image-gallery__items--list .image-gallery__thumb-meta {
        align-self: stretch;
      }

      .image-gallery__thumb-actions {
        display: flex;
        gap: var(--space-2xs);
      }

      .image-gallery__delete {
        border: none;
        background: transparent;
        color: var(--color-danger);
        font-size: 0.8rem;
        cursor: pointer;
        padding: var(--space-2xs) var(--space-sm);
        border-radius: var(--radius-sm);
        transition: background-color var(--transition-base), color var(--transition-base);
      }

      .image-gallery__delete:hover,
      .image-gallery__delete:focus-visible {
        background: color-mix(in srgb, var(--color-danger) 15%, transparent 85%);
        color: var(--color-danger);
        outline: none;
      }

      .image-gallery__empty {
        margin: 0;
        padding: var(--space-md);
        text-align: center;
        font-size: 0.9rem;
        color: var(--color-text-muted);
        border-radius: var(--radius-md);
        background: color-mix(in srgb, var(--color-surface) 85%, transparent 15%);
      }

      .image-viewer__canvas {
        position: relative;
        min-height: 20rem;
        border-radius: var(--radius-lg);
        border: 1px solid color-mix(in srgb, var(--color-border) 75%, transparent 25%);
        background: color-mix(in srgb, var(--color-surface) 82%, transparent 18%);
        display: grid;
        place-items: center;
        overflow: hidden;
      }

      .image-viewer__canvas[data-fit="actual"] {
        overflow: auto;
      }

      .image-viewer__canvas img {
        max-width: 100%;
        max-height: 100%;
        width: 100%;
        height: 100%;
        object-fit: contain;
        transform-origin: center;
        transition: transform 160ms ease, object-fit var(--transition-base);
      }

      .image-viewer__canvas[data-fit="cover"] img {
        object-fit: cover;
      }

      .image-viewer__canvas[data-fit="actual"] img {
        width: auto;
        height: auto;
        max-width: none;
        max-height: none;
        object-fit: contain;
      }

      .image-viewer__empty {
        text-align: center;
        display: grid;
        gap: var(--space-2xs);
        color: var(--color-text-muted);
      }

      .image-viewer__controls {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-sm);
        justify-content: space-between;
        align-items: center;
      }

      .image-viewer__control-group {
        display: inline-flex;
        gap: var(--space-2xs);
        padding: var(--space-2xs);
        border-radius: var(--radius-md);
        background: color-mix(in srgb, var(--color-surface) 65%, transparent 35%);
      }

      .image-viewer__control {
        border: none;
        background: transparent;
        color: var(--color-text-muted);
        padding: var(--space-2xs) var(--space-sm);
        border-radius: var(--radius-md);
        font-size: 0.85rem;
        cursor: pointer;
        transition: background-color var(--transition-base), color var(--transition-base);
      }

      .image-viewer__control.is-active {
        background: var(--color-surface);
        color: var(--color-text);
        box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--color-border) 80%, transparent 20%);
      }

      .image-viewer__slider {
        min-width: 10rem;
        accent-color: var(--color-accent);
      }

      .image-viewer__meta {
        display: grid;
        gap: var(--space-lg);
      }

      .image-viewer__details {
        display: grid;
        gap: var(--space-md);
        grid-template-columns: repeat(auto-fit, minmax(12rem, 1fr));
      }

      .image-viewer__details dt {
        margin: 0;
        font-size: 0.8rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--color-text-muted);
      }

      .image-viewer__details dd {
        margin: 0;
        font-weight: 600;
        font-size: 0.95rem;
      }

      .image-viewer__exif {
        border-top: 1px solid color-mix(in srgb, var(--color-border) 75%, transparent 25%);
        padding-top: var(--space-md);
        display: grid;
        gap: var(--space-sm);
      }

      .image-viewer__exif h3 {
        margin: 0;
        font-size: 1rem;
      }

      .image-viewer__exif-list {
        display: grid;
        gap: var(--space-2xs);
        font-size: 0.85rem;
        color: var(--color-text-muted);
      }

      .library-card__table {
        border-radius: var(--radius-lg);
        border: 1px solid color-mix(in srgb, var(--color-border) 80%, transparent 20%);
        background: color-mix(in srgb, var(--color-surface) 92%, transparent 8%);
        overflow: hidden;
      }

      .library-table {
        width: 100%;
        border-collapse: collapse;
        min-width: 100%;
      }

      .library-table thead {
        background: color-mix(in srgb, var(--color-surface) 70%, transparent 30%);
        color: color-mix(in srgb, var(--color-text) 90%, white 10%);
      }

      .library-table th,
      .library-table td {
        padding: var(--space-sm) var(--space-md);
        text-align: left;
        font-size: 0.9rem;
      }

      .library-table th {
        font-weight: 600;
        border-bottom: 1px solid color-mix(in srgb, var(--color-border) 80%, transparent 20%);
      }

      .library-table td {
        border-bottom: 1px solid color-mix(in srgb, var(--color-border) 70%, transparent 30%);
        vertical-align: top;
      }

      .library-table tr.is-selected {
        background: color-mix(in srgb, var(--color-accent) 12%, transparent 88%);
      }

      .library-table tr:last-child td {
        border-bottom: none;
      }

      .library-table__title {
        display: grid;
        gap: var(--space-2xs);
      }

      .library-table__title strong {
        font-weight: 600;
      }

      .library-table__title span {
        color: var(--color-text-muted);
        font-size: 0.85rem;
      }

      .library-table__actions-heading {
        text-align: right;
      }

      .library-table__actions {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-2xs);
        justify-content: flex-end;
      }

      .library-action {
        border: 1px solid color-mix(in srgb, var(--color-border) 75%, transparent 25%);
        background: color-mix(in srgb, var(--color-surface) 88%, transparent 12%);
        border-radius: var(--radius-sm);
        padding: var(--space-2xs) var(--space-sm);
        font-size: 0.8rem;
        cursor: pointer;
        color: var(--color-text);
        transition: background-color var(--transition-base), border-color var(--transition-base);
      }

      .library-action:hover,
      .library-action:focus-visible {
        border-color: color-mix(in srgb, var(--color-accent) 50%, transparent 50%);
        background: color-mix(in srgb, var(--color-accent) 12%, var(--color-surface) 88%);
        outline: none;
      }

      .library-action.is-disabled {
        pointer-events: none;
        opacity: 0.5;
      }

      .library-card__empty {
        margin: 0;
        padding: var(--space-md);
        font-size: 0.9rem;
        color: var(--color-text-muted);
        text-align: center;
        background: color-mix(in srgb, var(--color-surface) 85%, transparent 15%);
      }


      .upload-progress {
        display: grid;
        gap: var(--space-2xs);
        background: color-mix(in srgb, var(--color-surface) 82%, transparent 18%);
        border-radius: var(--radius-md);
        border: 1px solid color-mix(in srgb, var(--color-border) 75%, transparent 25%);
        padding: var(--space-sm) var(--space-md);
      }

      .upload-progress__bar {
        position: relative;
        width: 100%;
        height: 0.75rem;
        border-radius: var(--radius-sm);
        background: color-mix(in srgb, var(--color-surface) 70%, transparent 30%);
        overflow: hidden;
      }

      .upload-progress__fill {
        position: absolute;
        inset: 0;
        width: 0%;
        background: linear-gradient(135deg, var(--color-accent), var(--color-accent-strong));
        border-radius: inherit;
        transition: width 120ms ease;
      }

      .upload-progress__label {
        margin: 0;
        font-size: 0.85rem;
        color: var(--color-text-muted);
      }

      .upload-feedback {
        margin: 0;
        font-size: 0.9rem;
        border-radius: var(--radius-md);
        padding: var(--space-sm) var(--space-md);
        border: 1px solid transparent;
      }

      .upload-feedback.is-error {
        color: var(--color-danger);
        border-color: color-mix(in srgb, var(--color-danger) 40%, transparent 60%);
        background: color-mix(in srgb, var(--color-danger) 8%, var(--color-surface) 92%);
      }

      .upload-feedback.is-success {
        color: var(--color-success);
        border-color: color-mix(in srgb, var(--color-success) 40%, transparent 60%);
        background: color-mix(in srgb, var(--color-success) 10%, var(--color-surface) 90%);
      }

      .viewer-card__preview {
        min-height: 18rem;
        border-radius: var(--radius-lg);
        border: 1px solid color-mix(in srgb, var(--color-border) 80%, transparent 20%);
        background: color-mix(in srgb, var(--color-surface) 70%, transparent 30%);
        display: grid;
        place-items: center;
        text-align: center;
        padding: var(--space-xl);
        position: relative;
      }

      .viewer-card__preview object,
      .viewer-card__preview iframe {
        width: 100%;
        height: 100%;
        border: none;
        border-radius: var(--radius-md);
        background: white;
      }

      .viewer-card__fallback {
        display: grid;
        gap: var(--space-xs);
      }

      .viewer-card__meta {
        display: grid;
        gap: var(--space-lg);
      }

      .viewer-card__details {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(14rem, 1fr));
        gap: var(--space-sm);
        margin: 0;
      }

      .viewer-card__details div {
        background: color-mix(in srgb, var(--color-surface) 85%, transparent 15%);
        padding: var(--space-sm);
        border-radius: var(--radius-md);
        border: 1px solid color-mix(in srgb, var(--color-border) 75%, transparent 25%);
      }

      .viewer-card__details dt {
        margin: 0;
        font-size: 0.75rem;
        text-transform: uppercase;
        color: var(--color-text-muted);
        letter-spacing: 0.06em;
      }

      .viewer-card__details dd {
        margin: var(--space-2xs) 0 0;
        font-weight: 600;
      }

      .viewer-card__description {
        margin: 0;
        font-size: 0.9rem;
        color: var(--color-text-muted);
      }

      .viewer-card__link {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-sm);
        align-items: center;
      }

      .viewer-card__link-input {
        flex: 1 1 16rem;
        min-width: 0;
      }

      .viewer-card__empty {
        display: grid;
        gap: var(--space-sm);
      }

      footer {
        text-align: center;
        padding-bottom: var(--space-xl);
        color: color-mix(in srgb, var(--color-text) 70%, white 30%);
        font-size: 0.85rem;
      }
    </style>
  </head>
  <body class="theme theme--immersive">
    <main class="portal" id="support-portal">
      <header class="portal__header">
        <p class="u-copy" role="status" aria-live="polite">
          <span class="u-copy__value">Drop files or paste links to begin a support case.</span>
          <button class="u-copy__button" type="button" data-copy="support@invisible.support">
            Copy contact
          </button>
        </p>
        <h1 class="portal__heading">Invisible Support Upload Hub</h1>
        <p class="portal__lede">
          Prioritize rich context uploads while staying immersed in your operations. Consolidate files,
          notes, and case metadata without losing the cinematic feel of the workspace.
        </p>
        <section
          class="storage-meter"
          role="region"
          aria-live="polite"
          aria-label="Storage usage"
          data-storage-meter
        >
          <div class="storage-meter__heading">
            <span data-i18n-key="labels.storageUsed"></span>
            <span data-storage-limit></span>
          </div>
          <div class="storage-meter__values">
            <span data-storage-summary></span>
            <button
              class="u-btn u-btn--ghost storage-meter__button"
              type="button"
              data-storage-manage
              data-i18n-key="labels.storageManageCta"
            ></button>
          </div>
          <div class="storage-meter__progress" role="progressbar" aria-valuemin="0" aria-valuemax="100" data-storage-progress>
            <span class="storage-meter__progress-bar" data-storage-progress-bar></span>
          </div>
          <p class="storage-meter__warning" data-storage-warning hidden></p>
        </section>
      </header>

      <div class="portal__grid">
        <!-- Primary column: Upload workflow -->
        <section class="portal__column portal__column--primary">
          <article class="u-card upload-card" aria-labelledby="upload-workflow">
            <div class="u-card__header">
              <h2 class="u-card__title" id="upload-workflow">Upload workflow</h2>
              <p class="u-card__subtitle">
                Centralize artifacts by dragging, dropping, or linking your diagnostic assets.
              </p>
            </div>

            <form class="stack stack--lg" id="document-upload-form" aria-label="Document upload" novalidate>
              <div
                class="upload-card__dropzone"
                role="region"
                aria-label="Upload dropzone"
                data-dropzone
              >
                <svg viewBox="0 0 24 24" aria-hidden="true">
                  <path
                    fill="currentColor"
                    d="M12 3c.55 0 1 .45 1 1v8.59l2.3-2.3a1 1 0 1 1 1.4 1.42l-4 4a1 1 0 0 1-1.4 0l-4-4a1 1 0 1 1 1.4-1.42l2.3 2.3V4c0-.55.45-1 1-1Zm-7 9a1 1 0 0 1 1 1v4c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2v-4a1 1 0 1 1 2 0v4a4 4 0 0 1-4 4H8a4 4 0 0 1-4-4v-4a1 1 0 0 1-1Z"
                  />
                </svg>
                <div class="stack">
                  <p class="portal__lede" style="font-size: 1rem;">
                    Drop files here or browse to upload.
                  </p>
                  <div class="upload-card__actions">
                    <label class="u-btn u-btn--primary" for="primary-upload">Browse files</label>
                    <span aria-hidden="true">or</span>
                    <span class="u-card__subtitle">Paste from clipboard (⌘/Ctrl + V)</span>
                  </div>
                  <p class="upload-card__accepted">PDF, DOCX, PPTX, XLSX, images, CSV, and more.</p>
                </div>
                <input
                  class="u-input"
                  type="file"
                  id="primary-upload"
                  name="documents"
                  multiple
                  accept=".pdf,.doc,.docx,.ppt,.pptx,.xls,.xlsx,.csv,.txt,.rtf,.png,.jpg,.jpeg,.gif,.webp,.heic,.mp4,.mov,.json,.log,.zip"
                  aria-label="Upload files"
                  data-file-input
                />
              </div>

              <div class="form-grid form-grid--split">
                <label class="stack" for="document-title">
                  <span class="u-card__subtitle">Title <span aria-hidden="true">(optional)</span></span>
                  <input
                    class="u-input"
                    type="text"
                    id="document-title"
                    name="title"
                    placeholder="e.g. Database latency analysis"
                    data-title-input
                  />
                </label>
                <label class="stack" for="document-description">
                  <span class="u-card__subtitle">Description <span aria-hidden="true">(optional)</span></span>
                  <input
                    class="u-input"
                    type="text"
                    id="document-description"
                    name="description"
                    placeholder="Short note about the document"
                    data-description-input
                  />
                </label>
              </div>

              <div class="stack">
                <span class="u-card__subtitle">Upload progress</span>
                <div class="upload-progress" data-upload-progress hidden>
                  <div class="upload-progress__bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                    <span class="upload-progress__fill" data-progress-fill></span>
                  </div>
                  <p class="upload-progress__label" data-progress-label>Waiting for files…</p>
                </div>
              </div>

              <p class="upload-feedback" data-upload-feedback role="alert" hidden></p>

              <div class="upload-card__actions" style="justify-content: flex-start;">
                <button class="u-btn u-btn--primary" type="submit">Upload documents</button>
                <button class="u-btn u-btn--ghost" type="reset">Reset</button>
              </div>
            </form>
          </article>
        </section>

        <!-- Secondary column: Library and viewer panels -->
        <section class="portal__column portal__column--secondary">
          <article class="u-card library-card" aria-labelledby="asset-library">
            <div class="u-card__header">
              <h2 class="u-card__title" id="asset-library">Asset library</h2>
              <p class="u-card__subtitle">
                Reference previously uploaded artifacts to accelerate triage.
              </p>
            </div>

            <div class="stack" role="region" aria-live="polite">
              <label class="stack" for="library-search">
                <span class="u-card__subtitle">Filter library</span>
                <input
                  class="u-input"
                  type="search"
                  id="library-search"
                  placeholder="Search by title, file name, or type"
                  autocomplete="off"
                  data-library-search
                />
              </label>

              <div class="library-card__table" role="region" aria-label="Document library table">
                <table class="library-table">
                  <thead>
                    <tr>
                      <th scope="col">Title</th>
                      <th scope="col">Type</th>
                      <th scope="col">Size</th>
                      <th scope="col">Last updated</th>
                      <th scope="col" class="library-table__actions-heading">Actions</th>
                    </tr>
                  </thead>
                  <tbody data-library-rows></tbody>
                </table>
                <p class="library-card__empty" data-library-empty hidden>No documents uploaded yet.</p>
              </div>
            </div>
          </article>
          <article class="u-card viewer-card" aria-labelledby="asset-viewer">
            <div class="u-card__header">
              <h2 class="u-card__title" id="asset-viewer">Asset viewer</h2>
              <p class="u-card__subtitle">Preview assets inline or open them in immersive mode.</p>
            </div>

            <div class="viewer-card__preview" data-viewer-preview>
              <div class="viewer-card__empty" data-viewer-empty>
                <h3>Nothing selected yet</h3>
                <p class="portal__lede" style="font-size: 0.95rem;">
                  Choose an item from the library to load a preview, transcript, or streaming session.
                </p>
              </div>
            </div>

            <div class="viewer-card__meta" data-viewer-meta hidden>
              <div class="stack">
                <span class="u-card__subtitle">Document details</span>
                <dl class="viewer-card__details">
                  <div>
                    <dt>Title</dt>
                    <dd data-viewer-name>—</dd>
                  </div>
                  <div>
                    <dt>File name</dt>
                    <dd data-viewer-filename>—</dd>
                  </div>
                  <div>
                    <dt>Type</dt>
                    <dd data-viewer-type>—</dd>
                  </div>
                  <div>
                    <dt>Size</dt>
                    <dd data-viewer-size>—</dd>
                  </div>
                  <div>
                    <dt>Last updated</dt>
                    <dd data-viewer-updated>—</dd>
                  </div>
                </dl>
                <p class="viewer-card__description" data-viewer-description hidden></p>
              </div>

              <div class="stack">
                <span class="u-card__subtitle">Shareable link</span>
                <div class="viewer-card__link">
                  <input
                    class="u-input viewer-card__link-input"
                    type="text"
                    readonly
                    id="viewer-direct-link"
                    data-viewer-link
                    value=""
                  />
                  <button class="u-btn u-btn--ghost" type="button" data-viewer-copy>Copy</button>
                  <a class="u-btn u-btn--primary" href="#" target="_blank" rel="noopener" data-viewer-open>
                    Open in new tab
                  </a>
                </div>
              </div>
            </div>
          </article>
        </section>
      </div>

      <section class="image-portal" aria-labelledby="image-management">
        <div class="image-portal__header">
          <h2 class="portal__heading" id="image-management">Image management</h2>
          <p class="portal__lede">
            Curate high-resolution imagery with validation, EXIF awareness, and adaptive previews tailored for operations hand-offs.
          </p>
        </div>

        <div class="image-portal__grid">
          <div class="image-portal__column">
            <article class="u-card image-upload-card" aria-labelledby="image-upload-title">
              <div class="u-card__header">
                <h2 class="u-card__title" id="image-upload-title">Image upload</h2>
                <p class="u-card__subtitle">
                  Drop incident captures, dashboards, or product screenshots with automatic checks for type and dimensions.
                </p>
              </div>

              <form class="stack stack--lg" data-image-form novalidate>
                <div class="stack">
                  <div class="upload-card__dropzone" role="region" aria-label="Image upload dropzone" data-image-dropzone>
                    <svg viewBox="0 0 48 48" role="presentation" aria-hidden="true">
                      <path
                        fill="currentColor"
                        d="M24 6a12 12 0 0 0-12 12v3H8a6 6 0 0 0 0 12h32a6 6 0 0 0 1-11.9V18A12 12 0 0 0 24 6Zm0 4a8 8 0 0 1 8 8v3h-4.5a1.5 1.5 0 0 0-1.07.44L24 23.86l-2.43-2.42A1.5 1.5 0 0 0 20.5 21H16v-3a8 8 0 0 1 8-8Zm-2 11.62 1.43 1.43a1.5 1.5 0 0 0 2.12 0L27 21.05l3.45 3.45a1.5 1.5 0 0 0 1.06.44H36a2 2 0 0 1 0 4H12a2 2 0 1 1 0-4h4.5l4.5-4.38Z"
                      />
                    </svg>
                    <p class="portal__lede">
                      Drag and drop visual assets or browse your workstation. Files are inspected before upload.
                    </p>
                    <div class="upload-card__actions">
                      <label class="u-btn u-btn--primary" for="image-upload-input">Browse images</label>
                      <span aria-hidden="true">or</span>
                      <span class="u-card__subtitle">Drop anywhere to upload</span>
                    </div>
                    <p class="upload-card__accepted">
                      JPEG, PNG, WebP, AVIF, GIF, and HEIC · Max dimension 8,192&nbsp;px on either side.
                    </p>
                  </div>
                  <input
                    class="u-input"
                    type="file"
                    id="image-upload-input"
                    name="images"
                    accept="image/*"
                    multiple
                    data-image-file-input
                  />
                </div>

                <div class="form-grid form-grid--split">
                  <label class="stack" for="image-title">
                    <span class="u-card__subtitle">Title <span aria-hidden="true">(optional)</span></span>
                    <input
                      class="u-input"
                      type="text"
                      id="image-title"
                      placeholder="e.g. PagerDuty status overview"
                      data-image-title
                    />
                  </label>
                  <label class="stack" for="image-alt">
                    <span class="u-card__subtitle">Alt text <span aria-hidden="true">(optional)</span></span>
                    <input
                      class="u-input"
                      type="text"
                      id="image-alt"
                      placeholder="Accessible description for screen readers"
                      data-image-alt
                    />
                  </label>
                </div>

                <div class="stack">
                  <span class="u-card__subtitle">Upload progress</span>
                  <div class="upload-progress" data-image-progress hidden>
                    <div
                      class="upload-progress__bar"
                      role="progressbar"
                      aria-valuemin="0"
                      aria-valuemax="100"
                      aria-valuenow="0"
                      data-image-progress-bar
                    >
                      <span class="upload-progress__fill" data-image-progress-fill></span>
                    </div>
                    <p class="upload-progress__label" data-image-progress-label>Waiting for images…</p>
                  </div>
                </div>

                <p class="upload-feedback" data-image-feedback role="alert" hidden></p>

                <div class="upload-card__actions" style="justify-content: flex-start;">
                  <button class="u-btn u-btn--primary" type="submit">Upload images</button>
                  <button class="u-btn u-btn--ghost" type="reset">Reset</button>
                </div>
              </form>
            </article>

            <article class="u-card image-gallery-card" aria-labelledby="image-gallery">
              <div class="u-card__header">
                <h2 class="u-card__title" id="image-gallery">Image gallery</h2>
                <p class="u-card__subtitle">Switch between grid and list layouts while thumbnails lazy-load in view.</p>
              </div>

              <div class="stack">
                <div class="image-gallery__toolbar">
                  <label class="stack image-gallery__search" for="image-gallery-search">
                    <span class="u-card__subtitle">Filter images</span>
                    <input
                      class="u-input"
                      type="search"
                      id="image-gallery-search"
                      placeholder="Search by title, file name, or EXIF metadata"
                      autocomplete="off"
                      data-image-search
                    />
                  </label>
                  <div class="image-gallery__views" role="group" aria-label="Select gallery view">
                    <button class="image-gallery__view is-active" type="button" data-image-view="grid">Grid</button>
                    <button class="image-gallery__view" type="button" data-image-view="list">List</button>
                  </div>
                </div>

                <ul class="image-gallery__items image-gallery__items--grid" data-image-gallery-items aria-live="polite"></ul>
                <p class="image-gallery__empty" data-image-gallery-empty hidden>No images uploaded yet.</p>
              </div>
            </article>
          </div>

          <div class="image-portal__column">
            <article class="u-card image-viewer-card" aria-labelledby="image-viewer">
              <div class="u-card__header">
                <h2 class="u-card__title" id="image-viewer">Image viewer</h2>
                <p class="u-card__subtitle">Fine-tune preview scaling, review metadata, and grab direct share links.</p>
              </div>

              <div class="stack" data-image-viewer>
                <div class="image-viewer__canvas" data-image-canvas data-fit="contain">
                  <div class="image-viewer__empty" data-image-empty>
                    <h3>Waiting for a selection</h3>
                    <p class="portal__lede" style="font-size: 0.95rem;">
                      Choose a thumbnail to open a rich preview with zoom controls and EXIF-aware metadata.
                    </p>
                  </div>
                  <img data-image-preview alt="" hidden />
                </div>

                <div class="image-viewer__controls" data-image-controls hidden>
                  <div class="image-viewer__control-group" role="group" aria-label="Fit controls">
                    <button class="image-viewer__control is-active" type="button" data-image-fit="contain">Fit</button>
                    <button class="image-viewer__control" type="button" data-image-fit="cover">Fill</button>
                    <button class="image-viewer__control" type="button" data-image-fit="actual">Actual</button>
                  </div>
                  <label class="stack" style="gap: var(--space-2xs); min-width: 10rem;">
                    <span class="u-card__subtitle">Zoom</span>
                    <input
                      class="image-viewer__slider"
                      type="range"
                      min="25"
                      max="200"
                      step="5"
                      value="100"
                      data-image-zoom
                    />
                  </label>
                </div>

                <div class="image-viewer__meta" data-image-meta hidden>
                  <dl class="image-viewer__details">
                    <div>
                      <dt>Title</dt>
                      <dd data-image-name>—</dd>
                    </div>
                    <div>
                      <dt>File name</dt>
                      <dd data-image-filename>—</dd>
                    </div>
                    <div>
                      <dt>Dimensions</dt>
                      <dd data-image-dimensions>—</dd>
                    </div>
                    <div>
                      <dt>Size</dt>
                      <dd data-image-size>—</dd>
                    </div>
                    <div>
                      <dt>Type</dt>
                      <dd data-image-type>—</dd>
                    </div>
                    <div>
                      <dt>Alt text</dt>
                      <dd data-image-alt>—</dd>
                    </div>
                    <div>
                      <dt>Captured</dt>
                      <dd data-image-taken>—</dd>
                    </div>
                  </dl>

                  <div class="image-viewer__exif" data-image-exif hidden>
                    <h3>EXIF metadata</h3>
                    <div class="image-viewer__exif-list" data-image-exif-list></div>
                  </div>

                  <div class="stack">
                    <span class="u-card__subtitle">Direct link</span>
                    <div class="viewer-card__link">
                      <input
                        class="u-input viewer-card__link-input"
                        type="text"
                        readonly
                        id="image-direct-link"
                        data-image-link
                        value=""
                      />
                      <button class="u-btn u-btn--ghost" type="button" data-copy-target="#image-direct-link">Copy</button>
                      <a class="u-btn u-btn--primary" href="#" target="_blank" rel="noopener" data-image-open aria-disabled="true">
                        Open in new tab
                      </a>
                    </div>
                  </div>
                </div>
              </div>
            </article>
          </div>
        </div>
      </section>
    </main>

    <div class="toast-stack" role="status" aria-live="polite" aria-atomic="false" data-toast-stack></div>

    <div class="u-modal" id="clipboard-confirm" role="dialog" aria-modal="true" aria-labelledby="clipboard-title">
      <div class="u-modal__dialog">
        <div class="stack">
          <h2 class="u-card__title" id="clipboard-title">Copied to clipboard</h2>
          <p class="u-card__subtitle" id="clipboard-description">
            The requested value is available for sharing. Paste it into any chat or ticket.
          </p>
          <button class="u-btn u-btn--primary" type="button" data-close-modal>Continue</button>
        </div>
      </div>
    </div>

    <div class="u-modal" id="storage-modal" role="dialog" aria-modal="true" aria-labelledby="storage-title" aria-describedby="storage-description">
      <div class="u-modal__dialog">
        <div class="stack">
          <h2 class="u-card__title" id="storage-title" data-i18n-key="labels.storageDialogTitle"></h2>
          <p class="u-card__subtitle" id="storage-description" data-i18n-key="labels.storageDialogDescription"></p>
          <div class="upload-card__actions" style="justify-content: flex-end;">
            <button class="u-btn u-btn--primary" type="button" data-storage-clear data-i18n-key="labels.storageClearCta"></button>
            <button class="u-btn u-btn--ghost" type="button" data-storage-cancel data-i18n-key="labels.storageCancelCta"></button>
          </div>
        </div>
      </div>
    </div>

    <footer>
      Invisible Support · Seamless context hand-offs for modern ops teams
    </footer>

    <script>
      const Localization = (() => {
        const defaultLocale = document.documentElement.lang || "en";
        const fallbackLocale = "en";
        const locales = {
          en: {
            common: {
              copySuccess: "Link copied to clipboard.",
              copyFailure: "Copy failed. Please copy manually.",
              dismiss: "Dismiss notification",
              remove: "Remove",
              manageStorage: "Manage storage",
              usageSummary: "{used} of {limit}",
              storageWarning: "Storage is almost full ({percent}% used).",
              unknownFile: "File",
            },
            notifications: {
              documentRemoved: "Document removed from library.",
              imageRemoved: "Image removed from gallery.",
              imageUploadSuccess: "Images uploaded successfully.",
              imageUploadSelectPrompt: "Select at least one image to upload.",
              documentUploadSuccess: "Documents uploaded successfully.",
              documentUploadSelectPrompt: "Select at least one document to upload.",
              storageQuotaExceeded: "Storage quota exceeded. Remove items or clear space to continue.",
              duplicateName: "An item with this name already exists. Renamed automatically.",
              largeFileWarning: "File is large and may exceed available space.",
              storageCleared: "Stored items cleared successfully.",
            },
            errors: {
              quotaExceeded: "Unable to save changes because storage is full.",
              persistFailure: "Unable to persist items. Try clearing storage and retrying.",
              invalidDocument: "Invalid document file.",
              invalidImage: "Invalid image file.",
              unsupportedImageType: "Unsupported image type.",
              imageDimensions: "Unable to read image dimensions.",
              imageTooLarge: "Image exceeds maximum supported dimensions.",
            },
            labels: {
              storageUsed: "Storage used",
              storageLimit: "Storage limit",
              storageDialogTitle: "Storage management",
              storageDialogDescription:
                "Local storage is near capacity. Clear older items or export data to continue uploading.",
              storageClearCta: "Clear all stored items",
              storageCancelCta: "Keep items",
              storageManageCta: "Manage stored data",
              storageWarningCta: "Review storage",
            },
            upload: {
              waitingImages: "Waiting for images…",
              waitingDocuments: "Waiting for files…",
              validating: "{name} • validating",
              progress: "{name} • {percent}%",
              summaryImagesSingle: "{name} uploaded",
              summaryImagesMultiple: "{count} images uploaded",
              summaryDocumentsSingle: "{name} uploaded",
              summaryDocumentsMultiple: "{count} documents uploaded",
              completeImages: "Upload complete. Images are ready in the gallery.",
              completeDocuments: "Upload complete. Documents are ready in the library.",
              errorSelectImages: "Select at least one image to upload.",
              errorSelectDocuments: "Select at least one document to upload.",
              errorUnsupportedImage: "{name} is not a supported image type.",
              errorImageTooLarge: "{name} exceeds the {limit}px dimension limit.",
              errorImageDimensions: "Unable to read dimensions for {name}.",
              errorUploadFailed: "Upload failed for {name}.",
            },
            gallery: {
              selectImage: "Select {name}",
            },
          },
        };

        let activeLocale = locales[defaultLocale] ? defaultLocale : fallbackLocale;

        function getString(key) {
          const segments = key.split(".");
          let current = locales[activeLocale] || locales[fallbackLocale];
          for (const segment of segments) {
            if (current && typeof current === "object" && segment in current) {
              current = current[segment];
            } else {
              return key;
            }
          }
          return typeof current === "string" ? current : key;
        }

        function format(template, replacements = {}) {
          return template.replace(/\{(.*?)\}/g, (_, token) => {
            const value = replacements[token.trim()];
            return value ?? "";
          });
        }

        function t(key, replacements) {
          const template = getString(key);
          return typeof template === "string" ? format(template, replacements) : key;
        }

        function apply(root = document) {
          root
            .querySelectorAll?.("[data-i18n-key]")
            .forEach((node) => {
              const key = node.getAttribute("data-i18n-key");
              if (!key) return;
              const text = t(key);
              if (node instanceof HTMLInputElement || node instanceof HTMLTextAreaElement) {
                node.placeholder = text;
              } else {
                node.textContent = text;
              }
            });
        }

        function setLocale(locale) {
          if (!locales[locale]) return;
          activeLocale = locale;
          apply();
        }

        function getLocale() {
          return activeLocale;
        }

        return { t, apply, setLocale, getLocale };
      })();

      Localization.apply();

      const StorageManager = (() => {
        const LIMIT_BYTES = 4.5 * 1024 * 1024; // 4.5 MB heuristic limit for localStorage
        const BASE64_OVERHEAD = 1.37;
        const WARNING_THRESHOLD = 0.8;
        const trackedSizes = new Map();
        const listeners = new Set();
        const encoder = typeof TextEncoder !== "undefined" ? new TextEncoder() : null;

        function measure(value) {
          if (!value) return 0;
          try {
            if (encoder) {
              return encoder.encode(value).length;
            }
            return unescape(encodeURIComponent(value)).length;
          } catch (error) {
            console.warn("Unable to measure storage value", error);
            return value.length ?? 0;
          }
        }

        function buildSnapshot(overrideKey, overrideSize) {
          let used = 0;
          trackedSizes.forEach((size, key) => {
            if (overrideKey && key === overrideKey && typeof overrideSize === "number") {
              used += overrideSize;
            } else {
              used += size;
            }
          });
          if (overrideKey && !trackedSizes.has(overrideKey) && typeof overrideSize === "number") {
            // Account for the incoming key even if we have not seen it before so quota checks stay accurate.
            used += overrideSize;
          }
          const limit = LIMIT_BYTES;
          const ratio = limit > 0 ? used / limit : 0;
          return {
            used,
            limit,
            ratio,
            isWarning: ratio >= WARNING_THRESHOLD && ratio < 1,
            isExceeded: ratio >= 1,
          };
        }

        function notify(snapshot = buildSnapshot()) {
          listeners.forEach((listener) => {
            try {
              listener({ ...snapshot });
            } catch (error) {
              console.warn("Storage listener error", error);
            }
          });
        }

        function register(key) {
          if (!trackedSizes.has(key)) {
            trackedSizes.set(key, 0);
          }
        }

        function persist(key, value) {
          register(key);
          const serialized = JSON.stringify(value);
          const size = measure(serialized);
          // Build a snapshot that pretends the new payload already exists to proactively detect quota issues.
          const snapshot = buildSnapshot(key, size);
          if (snapshot.isExceeded) {
            const error = new Error(Localization.t("errors.quotaExceeded"));
            error.code = "quota";
            error.snapshot = snapshot;
            throw error;
          }
          try {
            localStorage.setItem(key, serialized);
            trackedSizes.set(key, size);
            notify(snapshot);
          } catch (error) {
            if (error && (error.name === "QuotaExceededError" || error.code === 22)) {
              // Align thrown error shape when the browser rejects due to quota so consumers can surface consistent UI.
              const quotaError = new Error(Localization.t("errors.quotaExceeded"));
              quotaError.code = "quota";
              quotaError.snapshot = snapshot;
              throw quotaError;
            }
            const persistError = new Error(Localization.t("errors.persistFailure"));
            persistError.code = "persist";
            persistError.cause = error;
            throw persistError;
          }
        }

        function read(key) {
          register(key);
          const stored = localStorage.getItem(key);
          // Measuring the stored payload keeps the live usage meter in sync even if external tabs mutate storage.
          const size = measure(stored ?? "");
          trackedSizes.set(key, size);
          notify();
          if (!stored) return null;
          return JSON.parse(stored);
        }

        function clear(key) {
          register(key);
          localStorage.removeItem(key);
          trackedSizes.set(key, 0);
          notify();
        }

        function clearAll() {
          trackedSizes.forEach((_, key) => {
            localStorage.removeItem(key);
            trackedSizes.set(key, 0);
          });
          notify();
        }

        function subscribe(listener) {
          if (typeof listener !== "function") return () => {};
          listeners.add(listener);
          listener(buildSnapshot());
          return () => listeners.delete(listener);
        }

        function getSnapshot() {
          return buildSnapshot();
        }

        function estimateImpact(bytes) {
          if (!Number.isFinite(bytes) || bytes <= 0) return 0;
          // Stored assets are serialized to base64; multiply to approximate the encoded footprint before persisting.
          return Math.ceil(bytes * BASE64_OVERHEAD);
        }

        function getRemainingCapacity() {
          const snapshot = buildSnapshot();
          return Math.max(snapshot.limit - snapshot.used, 0);
        }

        function canStore(additionalBytes) {
          if (!Number.isFinite(additionalBytes) || additionalBytes <= 0) return true;
          const snapshot = buildSnapshot();
          // Compare against the projected usage to determine if we should block the upload and prompt the user.
          return snapshot.used + additionalBytes <= snapshot.limit;
        }

        return {
          persist,
          read,
          clear,
          clearAll,
          subscribe,
          getSnapshot,
          estimateImpact,
          getRemainingCapacity,
          canStore,
        };
      })();

      const Utils = (() => {
        const relativeTimeFormatter = new Intl.RelativeTimeFormat(undefined, { numeric: "auto" });
        const bytesFormatter = new Intl.NumberFormat(undefined, { maximumFractionDigits: 1 });
        const dateTimeFormatter = new Intl.DateTimeFormat(undefined, {
          dateStyle: "medium",
          timeStyle: "short",
        });
        const blobRegistry = new Set();

        function formatBytes(bytes) {
          if (!Number.isFinite(bytes) || bytes < 0) return "—";
          if (bytes === 0) return "0 B";
          const units = ["B", "KB", "MB", "GB", "TB"];
          const exponent = Math.min(Math.floor(Math.log(bytes) / Math.log(1024)), units.length - 1);
          const value = bytes / 1024 ** exponent;
          return `${bytesFormatter.format(value)} ${units[exponent]}`;
        }

        function formatRelativeTime(isoString) {
          if (!isoString) return "—";
          const date = new Date(isoString);
          if (Number.isNaN(date.getTime())) return "—";
          const diffMs = date.getTime() - Date.now();
          const units = [
            { unit: "year", ms: 1000 * 60 * 60 * 24 * 365 },
            { unit: "month", ms: 1000 * 60 * 60 * 24 * 30 },
            { unit: "day", ms: 1000 * 60 * 60 * 24 },
            { unit: "hour", ms: 1000 * 60 * 60 },
            { unit: "minute", ms: 1000 * 60 },
            { unit: "second", ms: 1000 },
          ];
          for (const { unit, ms } of units) {
            if (Math.abs(diffMs) >= ms || unit === "second") {
              const value = Math.round(diffMs / ms);
              return relativeTimeFormatter.format(value, unit);
            }
          }
          return relativeTimeFormatter.format(0, "second");
        }

        function formatDateTime(isoString) {
          if (!isoString) return "—";
          const date = new Date(isoString);
          if (Number.isNaN(date.getTime())) return "—";
          return dateTimeFormatter.format(date);
        }

        function createObjectUrl(value) {
          if (!value) return "";
          try {
            const url = URL.createObjectURL(value);
            blobRegistry.add(url);
            return url;
          } catch (error) {
            console.warn("Failed to create object URL", error);
            return "";
          }
        }

        function revokeObjectUrl(url) {
          if (!url) return;
          blobRegistry.delete(url);
          try {
            URL.revokeObjectURL(url);
          } catch (error) {
            console.warn("Failed to revoke object URL", error);
          }
        }

        function revokeAllObjectUrls() {
          blobRegistry.forEach((url) => {
            try {
              URL.revokeObjectURL(url);
            } catch (error) {
              console.warn("Failed to revoke object URL", error);
            }
          });
          blobRegistry.clear();
        }

        function dataUrlToBlob(dataUrl, fallbackType = "application/octet-stream") {
          if (!dataUrl) {
            return { blob: new Blob([], { type: fallbackType }), type: fallbackType };
          }
          const [header, payload] = dataUrl.split(",");
          try {
            const match = header?.match(/data:(.*?);base64/);
            const mime = match?.[1] || fallbackType;
            const binary = atob(payload ?? "");
            const length = binary.length;
            const bytes = new Uint8Array(length);
            for (let index = 0; index < length; index += 1) {
              bytes[index] = binary.charCodeAt(index);
            }
            return { blob: new Blob([bytes], { type: mime }), type: mime };
          } catch (error) {
            console.error("Failed to parse stored file", error);
            return { blob: new Blob([], { type: fallbackType }), type: fallbackType };
          }
        }

        function readFileAsDataUrl(file, progressCallback) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onerror = () => reject(reader.error);
            reader.onprogress = (event) => {
              if (event.lengthComputable) {
                const progress = event.total > 0 ? event.loaded / event.total : 0;
                progressCallback?.(progress);
              }
            };
            reader.onload = () => {
              resolve(typeof reader.result === "string" ? reader.result : "");
            };
            reader.readAsDataURL(file);
          });
        }

        async function copyToClipboard(text) {
          if (!text) return false;
          try {
            await navigator.clipboard.writeText(text);
            return true;
          } catch (error) {
            console.warn("Async clipboard failed, attempting fallback", error);
          }
          const textarea = document.createElement("textarea");
          textarea.value = text;
          textarea.setAttribute("readonly", "true");
          textarea.style.position = "fixed";
          textarea.style.top = "-9999px";
          document.body.appendChild(textarea);
          const selection = document.getSelection();
          const range = selection && selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
          textarea.select();
          let success = false;
          try {
            success = document.execCommand("copy");
          } catch (error) {
            console.error("Fallback copy failed", error);
            success = false;
          }
          textarea.blur();
          document.body.removeChild(textarea);
          if (range && selection) {
            selection.removeAllRanges();
            selection.addRange(range);
          }
          return success;
        }

        return {
          formatBytes,
          formatRelativeTime,
          formatDateTime,
          dataUrlToBlob,
          readFileAsDataUrl,
          createObjectUrl,
          revokeObjectUrl,
          revokeAllObjectUrls,
          copyToClipboard,
        };
      })();

      const Notifications = (() => {
        const stack = document.querySelector("[data-toast-stack]");
        const hideDelay = 5000;
        const tones = new Map([
          ["success", { icon: "✓", className: "toast--success" }],
          ["error", { icon: "⚠", className: "toast--error" }],
          ["info", { icon: "ℹ", className: "toast--info" }],
        ]);

        function buildToast(message, tone = "info") {
          const meta = tones.get(tone) || tones.get("info");
          const toast = document.createElement("div");
          toast.className = `toast ${meta?.className ?? ""}`.trim();
          toast.setAttribute("role", tone === "error" ? "alert" : "status");
          toast.setAttribute("aria-live", tone === "error" ? "assertive" : "polite");
          toast.tabIndex = 0;

          const icon = document.createElement("span");
          icon.className = "toast__icon";
          icon.setAttribute("aria-hidden", "true");
          icon.textContent = meta?.icon ?? "ℹ";

          const textNode = document.createElement("span");
          textNode.className = "toast__message";
          textNode.textContent = message;

          const dismissButton = document.createElement("button");
          dismissButton.className = "toast__dismiss";
          dismissButton.type = "button";
          dismissButton.textContent = Localization.t("common.dismiss");
          dismissButton.setAttribute("aria-label", Localization.t("common.dismiss"));

          toast.append(icon, textNode, dismissButton);
          toast.dataset.dismissButton = "";
          return toast;
        }

        function toast(message, tone = "info", { duration = hideDelay } = {}) {
          if (!stack || !message) return;
          const toastEl = buildToast(message, tone);
          stack.appendChild(toastEl);
          requestAnimationFrame(() => {
            toastEl.classList.add("is-visible");
          });
          const dismiss = () => {
            toastEl.classList.remove("is-visible");
            toastEl.addEventListener(
              "transitionend",
              () => {
                toastEl.remove();
              },
              { once: true }
            );
          };
          const timer = window.setTimeout(dismiss, duration);
          toastEl.addEventListener("click", (event) => {
            if (event.target instanceof HTMLButtonElement) return;
            window.clearTimeout(timer);
            dismiss();
          });
          toastEl.querySelector(".toast__dismiss")?.addEventListener("click", (event) => {
            event.stopPropagation();
            window.clearTimeout(timer);
            dismiss();
          });
          toastEl.addEventListener("keydown", (event) => {
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              window.clearTimeout(timer);
              dismiss();
            }
          });
        }

        function inline(target, message, tone) {
          if (!target) return;
          const normalized = message?.trim() ?? "";
          target.classList.remove("is-error", "is-success");
          if (!normalized) {
            target.hidden = true;
            target.textContent = "";
            target.removeAttribute("role");
            return;
          }
          target.hidden = false;
          target.textContent = normalized;
          if (tone === "error") {
            target.classList.add("is-error");
          } else if (tone === "success") {
            target.classList.add("is-success");
          }
          target.setAttribute("role", "alert");
        }

        return { toast, inline };
      })();

      let lastCopyTrigger = null;
      const modal = document.getElementById("clipboard-confirm");
      const modalClose = modal?.querySelector("[data-close-modal]");

      function openModal(trigger) {
        if (!modal) return;
        lastCopyTrigger = trigger ?? null;
        modal.classList.add("is-open");
        modalClose?.focus({ preventScroll: true });
      }

      function closeModal() {
        if (!modal) return;
        modal.classList.remove("is-open");
        if (lastCopyTrigger) {
          lastCopyTrigger.focus({ preventScroll: true });
          lastCopyTrigger = null;
        }
      }

      modalClose?.addEventListener("click", closeModal);
      modal?.addEventListener("click", (event) => {
        if (event.target === modal) {
          closeModal();
        }
      });

      function resolveCopyValue(trigger) {
        const explicit = trigger.getAttribute("data-copy");
        if (explicit) return explicit;
        const selector = trigger.getAttribute("data-copy-target");
        if (!selector) return "";
        const target = document.querySelector(selector);
        if (!target) return "";
        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {
          return target.value?.trim() ?? "";
        }
        return target.textContent?.trim() ?? "";
      }

      async function copyFromTrigger(trigger) {
        const value = resolveCopyValue(trigger);
        if (!value) return;
        const success = await Utils.copyToClipboard(value);
        if (success) {
          Notifications.toast(Localization.t("common.copySuccess"), "success");
          if (modal) {
            openModal(trigger);
          }
        } else {
          Notifications.toast(Localization.t("common.copyFailure"), "error");
          const selector = trigger.getAttribute("data-copy-target");
          if (selector) {
            const target = document.querySelector(selector);
            if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {
              target.focus();
              target.select();
            }
          }
        }
      }

      document.addEventListener("click", (event) => {
        const trigger = event.target.closest("[data-copy], [data-copy-target]");
        if (!trigger) return;
        event.preventDefault();
        copyFromTrigger(trigger);
      });

      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          closeModal();
        }
      });

      window.addEventListener("beforeunload", () => {
        Utils.revokeAllObjectUrls();
      });

      function guessMimeType(name, fallback = "application/octet-stream") {
        if (!name) return fallback;
        const extension = name.split(".").pop()?.toLowerCase();
        const lookup = {
          pdf: "application/pdf",
          doc: "application/msword",
          docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
          ppt: "application/vnd.ms-powerpoint",
          pptx: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
          xls: "application/vnd.ms-excel",
          xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
          csv: "text/csv",
          txt: "text/plain",
          rtf: "application/rtf",
          json: "application/json",
          log: "text/plain",
          png: "image/png",
          jpg: "image/jpeg",
          jpeg: "image/jpeg",
          gif: "image/gif",
          webp: "image/webp",
          heic: "image/heic",
          mp4: "video/mp4",
          mov: "video/quicktime",
          zip: "application/zip",
        };
        return lookup[extension] || fallback;
      }

      function formatExifDate(value) {
        if (!value || typeof value !== "string") return null;
        const cleaned = value.replace(/\0/g, "").trim();
        const match = cleaned.match(/^(\d{4}):(\d{2}):(\d{2}) (\d{2}):(\d{2}):(\d{2})$/);
        if (!match) return cleaned || null;
        const iso = `${match[1]}-${match[2]}-${match[3]}T${match[4]}:${match[5]}:${match[6]}`;
        const date = new Date(iso);
        if (Number.isNaN(date.getTime())) return cleaned || null;
        return date.toISOString();
      }

      const SUPPORTED_IMAGE_TYPES = new Set([
        "image/jpeg",
        "image/png",
        "image/webp",
        "image/avif",
        "image/gif",
        "image/heic",
        "image/heif",
        "image/svg+xml",
        "image/tiff",
      ]);

      const MAX_IMAGE_DIMENSION = 8192;

      function isSupportedImageType(type) {
        if (!type) return false;
        const normalized = type.toLowerCase();
        if (SUPPORTED_IMAGE_TYPES.has(normalized)) return true;
        return normalized.startsWith("image/");
      }

      function getImageDimensions(file) {
        return new Promise((resolve, reject) => {
          const url = URL.createObjectURL(file);
          const image = new Image();
          image.onload = () => {
            const width = image.naturalWidth || image.width;
            const height = image.naturalHeight || image.height;
            URL.revokeObjectURL(url);
            resolve({ width, height });
          };
          image.onerror = (error) => {
            URL.revokeObjectURL(url);
            reject(error);
          };
          image.src = url;
        });
      }
      function parseExifFromArrayBuffer(buffer) {
        if (!buffer || !(buffer instanceof ArrayBuffer)) return {};
        try {
          const view = new DataView(buffer);
          if (view.byteLength < 4) return {};
          // Only JPEG containers expose the SOI marker (0xffd8); bail fast for other formats.
          if (view.getUint16(0) !== 0xffd8) {
            return {};
          }
          let offset = 2;
          while (offset + 4 < view.byteLength) {
            if (view.getUint8(offset) !== 0xff) break;
            const marker = view.getUint8(offset + 1);
            const length = view.getUint16(offset + 2);
            if (marker === 0xe1 && length > 8) {
              const start = offset + 4;
              const header = String.fromCharCode(
                view.getUint8(start),
                view.getUint8(start + 1),
                view.getUint8(start + 2),
                view.getUint8(start + 3)
              );
              if (header === "Exif") {
                // EXIF payloads start after the 6-byte TIFF header ("Exif\0\0"); parse the nested TIFF records.
                return parseExifSegment(view, start + 6, length - 6);
              }
            }
            // Advance past the current JPEG segment (length includes the size field itself).
            offset += 2 + length;
          }
        } catch (error) {
          console.warn("Failed to parse EXIF metadata", error);
        }
        return {};
      }

      function parseExifSegment(view, offset, length) {
        if (!view || typeof offset !== "number" || typeof length !== "number") return {};
        if (offset + length > view.byteLength) return {};
        const tiffOffset = offset;
        const byteOrder = view.getUint16(tiffOffset);
        const littleEndian = byteOrder === 0x4949;
        if (byteOrder !== 0x4949 && byteOrder !== 0x4d4d) return {};
        const magic = view.getUint16(tiffOffset + 2, littleEndian);
        if (magic !== 0x002a) return {};
        const firstIfdOffset = view.getUint32(tiffOffset + 4, littleEndian);
        const visited = new Set();
        const queue = [firstIfdOffset];
        const exif = {};

        const TYPE_SIZES = {
          1: 1,
          2: 1,
          3: 2,
          4: 4,
          5: 8,
          7: 1,
          10: 8,
        };

        function readValue(type, count, valueOffset, entryOffset) {
          const typeSize = TYPE_SIZES[type];
          if (!typeSize) return null;
          const valueSize = typeSize * count;
          let dataOffset;
          if (valueSize <= 4) {
            dataOffset = entryOffset + 8;
          } else {
            dataOffset = tiffOffset + valueOffset;
          }
          if (dataOffset + valueSize > tiffOffset + length) return null;
          switch (type) {
            case 2: {
              // ASCII strings are null-terminated; iterate until the sentinel to avoid trailing garbage.
              let text = "";
              for (let index = 0; index < valueSize; index += 1) {
                const code = view.getUint8(dataOffset + index);
                if (code === 0) break;
                text += String.fromCharCode(code);
              }
              return text.trim();
            }
            case 3: {
              if (count === 1) {
                return view.getUint16(dataOffset, littleEndian);
              }
              return Array.from({ length: count }, (_, i) =>
                view.getUint16(dataOffset + i * 2, littleEndian)
              );
            }
            case 4: {
              if (count === 1) {
                return view.getUint32(dataOffset, littleEndian);
              }
              return Array.from({ length: count }, (_, i) =>
                view.getUint32(dataOffset + i * 4, littleEndian)
              );
            }
            case 5: {
              const values = Array.from({ length: count }, (_, i) => {
                const numerator = view.getUint32(dataOffset + i * 8, littleEndian);
                const denominator = view.getUint32(dataOffset + i * 8 + 4, littleEndian);
                // Rational values encode numerator/denominator pairs; guard against divide-by-zero.
                return denominator ? numerator / denominator : 0;
              });
              return count === 1 ? values[0] : values;
            }
            case 10: {
              const values = Array.from({ length: count }, (_, i) => {
                const numerator = view.getInt32(dataOffset + i * 8, littleEndian);
                const denominator = view.getInt32(dataOffset + i * 8 + 4, littleEndian);
                // Signed rationals behave similarly but can include negative exposure bias values.
                return denominator ? numerator / denominator : 0;
              });
              return count === 1 ? values[0] : values;
            }
            case 7:
            case 1: {
              if (count === 1) {
                return view.getUint8(dataOffset);
              }
              return Array.from({ length: count }, (_, i) => view.getUint8(dataOffset + i));
            }
            default:
              return null;
          }
        }

        function queueIfd(offsetValue) {
          if (typeof offsetValue !== "number") return;
          if (offsetValue === 0) return;
          if (visited.has(offsetValue)) return;
          // Queue additional IFD (Image File Directory) blocks so we traverse thumbnails and sub-IFDs breadth-first.
          queue.push(offsetValue);
        }

        while (queue.length) {
          const ifdOffset = queue.shift();
          if (typeof ifdOffset !== "number") continue;
          if (visited.has(ifdOffset)) continue;
          visited.add(ifdOffset);
          const absolute = tiffOffset + ifdOffset;
          if (absolute + 2 > tiffOffset + length) continue;
          const entryCount = view.getUint16(absolute, littleEndian);
          for (let index = 0; index < entryCount; index += 1) {
            const entryOffset = absolute + 2 + index * 12;
            if (entryOffset + 12 > tiffOffset + length) break;
            const tag = view.getUint16(entryOffset, littleEndian);
            const type = view.getUint16(entryOffset + 2, littleEndian);
            const count = view.getUint32(entryOffset + 4, littleEndian);
            const valueOffset = view.getUint32(entryOffset + 8, littleEndian);
            if (tag === 0x8769 || tag === 0xa005) {
              queueIfd(valueOffset);
              continue;
            }
            const value = readValue(type, count, valueOffset, entryOffset);
            switch (tag) {
              case 0x010f:
                if (value) exif.make = value;
                break;
              case 0x0110:
                if (value) exif.model = value;
                break;
              case 0x0112:
                if (typeof value === "number") exif.orientation = value;
                break;
              case 0x0131:
                if (value) exif.software = value;
                break;
              case 0x0132:
                if (value && !exif.dateTimeOriginal) exif.dateTimeOriginal = value;
                break;
              case 0x829a:
                if (value) exif.exposureTime = value;
                break;
              case 0x829d:
                if (value) exif.fNumber = value;
                break;
              case 0x8827:
                if (value) {
                  exif.iso = Array.isArray(value) ? value[0] : value;
                }
                break;
              case 0x9003:
                if (value) exif.dateTimeOriginal = value;
                break;
              case 0x9201:
                if (value) exif.shutterSpeed = value;
                break;
              case 0x9204:
                if (value) exif.exposureBias = value;
                break;
              case 0x920a:
                if (value) exif.focalLength = value;
                break;
              case 0xa405:
                if (value) exif.focalLength35mm = value;
                break;
              case 0xa434:
                if (value) exif.lensModel = value;
                break;
              default:
                break;
            }
          }
          const nextIfdOffset = view.getUint32(absolute + 2 + entryCount * 12, littleEndian);
          if (nextIfdOffset) {
            queueIfd(nextIfdOffset);
          }
        }

        return exif;
      }

      function describeOrientation(value) {
        switch (value) {
          case 2:
            return "Mirrored horizontally";
          case 3:
            return "Rotated 180°";
          case 4:
            return "Mirrored vertically";
          case 5:
            return "Mirrored horizontally & rotated 90°";
          case 6:
            return "Rotated 90° clockwise";
          case 7:
            return "Mirrored horizontally & rotated 270°";
          case 8:
            return "Rotated 90° counter-clockwise";
          default:
            return value ? `Orientation ${value}` : null;
        }
      }

      const DocumentStore = (() => {
        const STORAGE_KEY = "invisibleSupport.documents";
        const listeners = new Set();
        let documents = [];

        function toSerializable(items) {
          return items.map(({ blobUrl, ...rest }) => rest);
        }

        function notify() {
          listeners.forEach((listener) => listener([...documents]));
        }

        function persist(nextDocuments) {
          const serializable = toSerializable(nextDocuments);
          StorageManager.persist(STORAGE_KEY, serializable);
        }

        function hydrate(rawDocs) {
          return rawDocs.map((doc) => {
            const { blob, type } = Utils.dataUrlToBlob(doc.dataUrl, doc.type);
            const blobUrl = blob ? Utils.createObjectUrl(blob) : "";
            // Persisted entries only store Data URLs; rebuild transient blob URLs for preview/open actions on load.
            return { ...doc, type, blobUrl };
          });
        }

        function load() {
          try {
            const stored = StorageManager.read(STORAGE_KEY);
            if (Array.isArray(stored)) {
              // Rehydrate and sort newest-first so recent uploads are surfaced prominently in the UI.
              documents = hydrate(stored).sort(
                (a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
              );
            }
          } catch (error) {
            console.error("Failed to load stored documents", error);
            documents = [];
            StorageManager.clear(STORAGE_KEY);
          }
        }

        function generateId() {
          return typeof crypto !== "undefined" && crypto.randomUUID
            ? crypto.randomUUID()
            : `doc-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;
        }

        function ensureUniqueName(name) {
          if (!name) return name;
          const trimmed = name.trim();
          if (!trimmed) return trimmed;
          const [base, extension] = (() => {
            const lastDot = trimmed.lastIndexOf(".");
            if (lastDot > 0 && lastDot < trimmed.length - 1) {
              return [trimmed.slice(0, lastDot), trimmed.slice(lastDot)];
            }
            return [trimmed, ""];
          })();
          let candidate = trimmed;
          let counter = 2;
          while (documents.some((doc) => doc.name === candidate)) {
            // Mirror desktop OS renaming conventions: append " (n)" before the extension until unique.
            candidate = `${base} (${counter})${extension}`;
            counter += 1;
          }
          if (candidate !== trimmed) {
            Notifications.toast(Localization.t("notifications.duplicateName"), "info");
          }
          return candidate;
        }

        function normalizeDocument(file, extras, dataUrl) {
          const now = new Date().toISOString();
          const title = extras.title?.trim();
          const description = extras.description?.trim() ?? "";
          const type = file.type || guessMimeType(file.name);
          const blobUrl = Utils.createObjectUrl(file);
          const normalizedName = ensureUniqueName(file.name);
          // Data URLs power persistence, while blob URLs enable ephemeral previews without exceeding storage quotas.
          return {
            id: generateId(),
            name: normalizedName,
            title: title || normalizedName,
            description,
            type,
            size: file.size,
            updatedAt: now,
            blobUrl,
            dataUrl,
          };
        }

        function addDocument(doc) {
          const nextDocuments = [doc, ...documents].sort(
            (a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
          );
          persist(nextDocuments);
          documents = nextDocuments;
          notify();
        }

        async function createDocument(file, extras = {}, progressCallback) {
          if (!(file instanceof File)) {
            const error = new Error(Localization.t("errors.invalidDocument"));
            error.code = "invalid";
            throw error;
          }
          // Stream the FileReader updates into the supplied callback so the upload meter reflects actual progress.
          const dataUrl = await Utils.readFileAsDataUrl(file, progressCallback);
          const documentRecord = normalizeDocument(file, extras, dataUrl);
          try {
            addDocument(documentRecord);
          } catch (error) {
            if (documentRecord?.blobUrl) {
              Utils.revokeObjectUrl(documentRecord.blobUrl);
            }
            throw error;
          }
          return documentRecord;
        }

        function removeDocument(id) {
          const index = documents.findIndex((doc) => doc.id === id);
          if (index === -1) return;
          const [removed] = documents.splice(index, 1);
          if (removed?.blobUrl) {
            // Release blob URLs immediately so long-lived tabs do not leak memory across many removals.
            Utils.revokeObjectUrl(removed.blobUrl);
          }
          try {
            persist(documents);
          } catch (error) {
            console.error("Unable to persist after removal", error);
            Notifications.toast(Localization.t("errors.persistFailure"), "error");
          }
          notify();
        }

        function clearAll() {
          documents.forEach((doc) => {
            if (doc?.blobUrl) {
              // Clearing all documents aggressively revokes each blob URL so stale direct links cannot be reused.
              Utils.revokeObjectUrl(doc.blobUrl);
            }
          });
          documents = [];
          StorageManager.clear(STORAGE_KEY);
          notify();
        }

        function subscribe(listener) {
          listeners.add(listener);
          listener([...documents]);
          return () => listeners.delete(listener);
        }

        function getDocument(id) {
          return documents.find((doc) => doc.id === id) ?? null;
        }

        function getDocuments() {
          return [...documents];
        }

        load();

        return { subscribe, createDocument, removeDocument, getDocument, getDocuments, clearAll };
      })();

      const ImageStore = (() => {
        const STORAGE_KEY = "invisibleSupport.images";
        const listeners = new Set();
        let images = [];

        function toSerializable(items) {
          return items.map(({ blobUrl, ...rest }) => rest);
        }

        function notify() {
          listeners.forEach((listener) => listener([...images]));
        }

        function persist(nextImages) {
          const serializable = toSerializable(nextImages);
          StorageManager.persist(STORAGE_KEY, serializable);
        }

        function hydrate(rawImages) {
          return rawImages.map((image) => {
            const { blob, type } = Utils.dataUrlToBlob(image.dataUrl, image.type || "image/png");
            const blobUrl = blob ? Utils.createObjectUrl(blob) : "";
            return { ...image, type, blobUrl };
          });
        }

        function load() {
          try {
            const stored = StorageManager.read(STORAGE_KEY);
            if (Array.isArray(stored)) {
              images = hydrate(stored).sort(
                (a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
              );
            }
          } catch (error) {
            console.error("Failed to load stored images", error);
            images = [];
            StorageManager.clear(STORAGE_KEY);
          }
        }

        function generateId() {
          return typeof crypto !== "undefined" && crypto.randomUUID
            ? crypto.randomUUID()
            : `img-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;
        }

        function ensureUniqueName(name) {
          if (!name) return name;
          const trimmed = name.trim();
          if (!trimmed) return trimmed;
          const [base, extension] = (() => {
            const lastDot = trimmed.lastIndexOf(".");
            if (lastDot > 0 && lastDot < trimmed.length - 1) {
              return [trimmed.slice(0, lastDot), trimmed.slice(lastDot)];
            }
            return [trimmed, ""];
          })();
          let candidate = trimmed;
          let counter = 2;
          while (images.some((image) => image.name === candidate)) {
            // Keep appending suffixes until the filename is unique for gallery lookups and blob URL maps.
            candidate = `${base} (${counter})${extension}`;
            counter += 1;
          }
          if (candidate !== trimmed) {
            Notifications.toast(Localization.t("notifications.duplicateName"), "info");
          }
          return candidate;
        }

        function normalizeImage(file, extras, dataUrl, dimensions, exif) {
          const now = new Date().toISOString();
          const title = extras.title?.trim();
          const alt = extras.alt?.trim();
          const type = file.type || guessMimeType(file.name, "image/png");
          const blobUrl = Utils.createObjectUrl(file);
          const capturedAtIso = formatExifDate(exif.dateTimeOriginal);
          const normalizedName = ensureUniqueName(file.name);
          // Persist raw metadata plus derived EXIF so filters/renderers avoid recomputing expensive operations client-side.
          return {
            id: generateId(),
            name: normalizedName,
            title: title || normalizedName,
            alt: alt || "",
            type,
            size: file.size,
            width: dimensions.width,
            height: dimensions.height,
            updatedAt: now,
            capturedAt: capturedAtIso,
            exif,
            blobUrl,
            dataUrl,
          };
        }

        function addImage(image) {
          const nextImages = [image, ...images].sort(
            (a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
          );
          persist(nextImages);
          images = nextImages;
          notify();
        }

        async function createImage(file, extras = {}, progressCallback) {
          if (!(file instanceof File)) {
            const error = new Error(Localization.t("errors.invalidImage"));
            error.code = "invalid";
            throw error;
          }
          const mimeType = file.type || guessMimeType(file.name, "image/png");
          if (!isSupportedImageType(mimeType)) {
            const error = new Error(Localization.t("errors.unsupportedImageType"));
            error.code = "type";
            throw error;
          }

          let dimensions;
          try {
            // Load the image up-front to validate its true dimensions before we commit to storage.
            dimensions = await getImageDimensions(file);
          } catch (error) {
            const dimensionError = new Error(Localization.t("errors.imageDimensions"));
            dimensionError.code = "dimensions";
            throw dimensionError;
          }

          if (
            !dimensions ||
            dimensions.width > MAX_IMAGE_DIMENSION ||
            dimensions.height > MAX_IMAGE_DIMENSION
          ) {
            const sizeError = new Error(Localization.t("errors.imageTooLarge"));
            sizeError.code = "max-dimensions";
            sizeError.details = dimensions;
            throw sizeError;
          }

          // Request the ArrayBuffer in parallel with the Data URL so EXIF parsing does not block the progress indicator.
          const arrayBufferPromise = file.arrayBuffer().catch(() => null);
          const dataUrl = await Utils.readFileAsDataUrl(file, progressCallback);
          let exif = {};
          try {
            const buffer = await arrayBufferPromise;
            if (buffer) {
              exif = parseExifFromArrayBuffer(buffer);
            }
          } catch (error) {
            console.warn("Unable to parse EXIF data", error);
          }

          const imageRecord = normalizeImage(file, extras, dataUrl, dimensions, exif);
          try {
            addImage(imageRecord);
          } catch (error) {
            if (imageRecord?.blobUrl) {
              Utils.revokeObjectUrl(imageRecord.blobUrl);
            }
            throw error;
          }
          return imageRecord;
        }

        function removeImage(id) {
          const index = images.findIndex((image) => image.id === id);
          if (index === -1) return;
          const [removed] = images.splice(index, 1);
          if (removed?.blobUrl) {
            // Revoke the gallery blob immediately so we do not leak memory or allow stale links to persist.
            Utils.revokeObjectUrl(removed.blobUrl);
          }
          try {
            persist(images);
          } catch (error) {
            console.error("Unable to persist images after removal", error);
            Notifications.toast(Localization.t("errors.persistFailure"), "error");
          }
          notify();
        }

        function subscribe(listener) {
          listeners.add(listener);
          listener([...images]);
          return () => listeners.delete(listener);
        }

        function getImage(id) {
          return images.find((image) => image.id === id) ?? null;
        }

        function getImages() {
          return [...images];
        }

        function clearAll() {
          images.forEach((image) => {
            if (image?.blobUrl) {
              // Clearing the gallery wipes each blob URL, immediately invalidating any open preview tabs.
              Utils.revokeObjectUrl(image.blobUrl);
            }
          });
          images = [];
          StorageManager.clear(STORAGE_KEY);
          notify();
        }

        load();

        return { subscribe, createImage, removeImage, getImage, getImages, clearAll };
      })();

      const StorageUI = (() => {
        const meter = document.querySelector("[data-storage-meter]");
        const summaryEl = meter?.querySelector("[data-storage-summary]");
        const limitEl = meter?.querySelector("[data-storage-limit]");
        const progressRegion = meter?.querySelector("[data-storage-progress]");
        const progressBar = meter?.querySelector("[data-storage-progress-bar]");
        const warningEl = meter?.querySelector("[data-storage-warning]");
        const manageButton = meter?.querySelector("[data-storage-manage]");
        const storageModal = document.getElementById("storage-modal");
        const clearButton = storageModal?.querySelector("[data-storage-clear]");
        const cancelButton = storageModal?.querySelector("[data-storage-cancel]");
        if (!meter) return null;
        let lastState = "normal";
        let lastTrigger = null;

        function formatSummary(snapshot) {
          return Localization.t("common.usageSummary", {
            used: Utils.formatBytes(snapshot.used),
            limit: Utils.formatBytes(snapshot.limit),
          });
        }

        function update(snapshot = StorageManager.getSnapshot()) {
          if (!snapshot) return;
          const percent = snapshot.limit ? Math.min((snapshot.used / snapshot.limit) * 100, 100) : 0;
          // Keep assistive tech in sync with the latest values while also powering the visible progress bar.
          meter.setAttribute("aria-label", Localization.t("labels.storageUsed"));
          if (limitEl) {
            limitEl.textContent = `${Localization.t("labels.storageLimit")}: ${Utils.formatBytes(
              snapshot.limit
            )}`;
          }
          if (summaryEl) {
            summaryEl.textContent = formatSummary(snapshot);
          }
          if (progressBar) {
            progressBar.style.width = `${percent}%`;
          }
          if (progressRegion) {
            progressRegion.setAttribute("aria-valuenow", String(Math.round(percent)));
          }
          const state = snapshot.isExceeded ? "error" : snapshot.isWarning ? "warning" : "normal";
          meter.classList.toggle("is-warning", state !== "normal");
          if (warningEl) {
            if (state === "error") {
              warningEl.textContent = Localization.t("notifications.storageQuotaExceeded");
              warningEl.hidden = false;
            } else if (state === "warning") {
              warningEl.textContent = Localization.t("common.storageWarning", {
                percent: Math.round(percent),
              });
              warningEl.hidden = false;
            } else {
              warningEl.textContent = "";
              warningEl.hidden = true;
            }
          }
          if (lastState !== state) {
            // Notify the user only when we transition into a new severity to avoid notification spam while uploading.
            if (state === "warning") {
              Notifications.toast(
                Localization.t("common.storageWarning", { percent: Math.round(percent) }),
                "info"
              );
            } else if (state === "error") {
              Notifications.toast(Localization.t("notifications.storageQuotaExceeded"), "error");
            }
          }
          lastState = state;
        }

        function openDialog(trigger) {
          if (!storageModal) return;
          lastTrigger = trigger ?? null;
          storageModal.classList.add("is-open");
          cancelButton?.focus({ preventScroll: true });
        }

        function closeDialog() {
          if (!storageModal) return;
          storageModal.classList.remove("is-open");
          if (lastTrigger) {
            lastTrigger.focus?.({ preventScroll: true });
            lastTrigger = null;
          }
        }

        manageButton?.addEventListener("click", (event) => {
          openDialog(event.currentTarget);
        });

        cancelButton?.addEventListener("click", closeDialog);
        storageModal?.addEventListener("click", (event) => {
          if (event.target === storageModal) {
            closeDialog();
          }
        });
        storageModal?.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            event.preventDefault();
            closeDialog();
          }
        });

        clearButton?.addEventListener("click", () => {
          DocumentStore.clearAll();
          ImageStore.clearAll();
          StorageManager.clearAll();
          Notifications.toast(Localization.t("notifications.storageCleared"), "success");
          closeDialog();
        });

        StorageManager.subscribe(update);
        update(StorageManager.getSnapshot());

        return { update };
      })();

      const DocumentViewer = (() => {
        const preview = document.querySelector("[data-viewer-preview]");
        const meta = document.querySelector("[data-viewer-meta]");
        const linkInput = document.querySelector("[data-viewer-link]");
        const openLink = document.querySelector("[data-viewer-open]");
        const copyButton = document.querySelector("[data-viewer-copy]");
        const nameEl = document.querySelector("[data-viewer-name]");
        const filenameEl = document.querySelector("[data-viewer-filename]");
        const typeEl = document.querySelector("[data-viewer-type]");
        const sizeEl = document.querySelector("[data-viewer-size]");
        const updatedEl = document.querySelector("[data-viewer-updated]");
        const descriptionEl = document.querySelector("[data-viewer-description]");
        const emptyTemplate = preview?.querySelector("[data-viewer-empty]")?.cloneNode(true) ?? null;
        let currentId = null;

        function focusPreview() {
          if (preview) {
            preview.setAttribute("tabindex", "-1");
            preview.focus({ preventScroll: true });
          }
        }

        function emitSelectionChange() {
          document.dispatchEvent(new CustomEvent("documentviewerchange", { detail: { id: currentId } }));
        }

        function renderEmpty() {
          if (!preview) return;
          preview.innerHTML = "";
          if (emptyTemplate) {
            preview.appendChild(emptyTemplate.cloneNode(true));
          }
          if (meta) meta.hidden = true;
          if (linkInput) linkInput.value = "";
          if (copyButton) copyButton.setAttribute("data-copy", "");
          if (openLink) {
            openLink.href = "#";
            openLink.setAttribute("aria-disabled", "true");
          }
          currentId = null;
          emitSelectionChange();
          focusPreview();
        }

        function isPreviewSupported(type) {
          if (!type) return false;
          return (
            type.startsWith("image/") ||
            type === "application/pdf" ||
            type.startsWith("text/") ||
            type.startsWith("video/") ||
            type.startsWith("audio/")
          );
        }

        function renderDocument(doc) {
          if (!preview) return;
          if (!doc) {
            renderEmpty();
            return;
          }

          preview.innerHTML = "";
          if (isPreviewSupported(doc.type) && doc.blobUrl) {
            const objectEl = document.createElement("object");
            objectEl.data = doc.blobUrl;
            objectEl.type = doc.type || "application/octet-stream";
            objectEl.className = "viewer-card__object";
            objectEl.innerHTML = `<p>Preview unavailable. <a href="${doc.blobUrl}" target="_blank" rel="noopener">Open in new tab</a>.</p>`;
            preview.appendChild(objectEl);
          } else {
            const fallback = document.createElement("div");
            fallback.className = "viewer-card__fallback";
            const heading = document.createElement("h3");
            heading.textContent = "Preview unavailable";
            const message = document.createElement("p");
            message.className = "portal__lede";
            message.style.fontSize = "0.95rem";
            message.textContent = `This file type (${doc.type || "unknown"}) cannot be previewed inline. Use the controls below to open or download the document.`;
            fallback.append(heading, message);
            preview.appendChild(fallback);
          }

          if (meta) meta.hidden = false;
          if (nameEl) nameEl.textContent = doc.title || doc.name;
          if (filenameEl) filenameEl.textContent = doc.name;
          if (typeEl) typeEl.textContent = doc.type || "Unknown";
          if (sizeEl) sizeEl.textContent = Utils.formatBytes(doc.size);
          if (updatedEl) updatedEl.textContent = Utils.formatRelativeTime(doc.updatedAt);
          if (descriptionEl) {
            if (doc.description) {
              descriptionEl.hidden = false;
              descriptionEl.textContent = doc.description;
            } else {
              descriptionEl.hidden = true;
              descriptionEl.textContent = "";
            }
          }
          if (linkInput) linkInput.value = doc.blobUrl || "";
          if (copyButton) copyButton.setAttribute("data-copy", doc.blobUrl || "");
          if (openLink) {
            if (doc.blobUrl) {
              openLink.href = doc.blobUrl;
              openLink.removeAttribute("aria-disabled");
            } else {
              openLink.href = "#";
              openLink.setAttribute("aria-disabled", "true");
            }
          }
          currentId = doc.id;
          emitSelectionChange();
          focusPreview();
        }

        DocumentStore.subscribe((docs) => {
          if (!currentId) {
            if (docs.length === 0) {
              renderEmpty();
            }
            return;
          }
          const match = docs.find((doc) => doc.id === currentId);
          if (!match) {
            renderEmpty();
          } else {
            renderDocument(match);
          }
        });

        renderEmpty();

        return {
          selectDocument(id) {
            const doc = DocumentStore.getDocument(id);
            renderDocument(doc);
          },
          getSelectedId() {
            return currentId;
          },
        };
      })();

      const LibraryView = (() => {
        const rows = document.querySelector("[data-library-rows]");
        const emptyState = document.querySelector("[data-library-empty]");
        const searchInput = document.querySelector("[data-library-search]");
        let docs = [];
        let query = "";
        let pendingFocusTarget = null;

        function matches(doc) {
          if (!query) return true;
          const value = query.toLowerCase();
          return [doc.title, doc.name, doc.type, doc.description]
            .filter(Boolean)
            .some((field) => field.toLowerCase().includes(value));
        }

        function getRowSelector(id) {
          if (!id) return null;
          if (typeof CSS !== "undefined" && CSS.escape) {
            return `tr[data-id="${CSS.escape(id)}"]`;
          }
          const safe = String(id).replace(/"/g, '\"');
          return `tr[data-id="${safe}"]`;
        }

        function focusRow(id) {
          const selector = getRowSelector(id);
          if (!rows || !selector) return;
          const target = rows.querySelector(selector);
          target?.focus({ preventScroll: false });
        }

        function markSelection(row, isSelected) {
          row.classList.toggle("is-selected", isSelected);
          if (isSelected) {
            row.setAttribute("aria-selected", "true");
          } else {
            row.removeAttribute("aria-selected");
          }
        }

        function syncSelection() {
          const selectedId = typeof DocumentViewer?.getSelectedId === "function"
            ? DocumentViewer.getSelectedId()
            : null;
          rows?.querySelectorAll("tr[data-id]").forEach((row) => {
            markSelection(row, row.dataset.id === selectedId);
          });
        }

        function applyPendingFocus() {
          if (!pendingFocusTarget) return;
          if (pendingFocusTarget === "search") {
            searchInput?.focus({ preventScroll: false });
          } else {
            focusRow(pendingFocusTarget);
          }
          pendingFocusTarget = null;
        }

        function render() {
          if (!rows) return;
          rows.textContent = "";
          const filtered = docs.filter(matches);
          if (emptyState) {
            emptyState.hidden = filtered.length > 0;
          }
          if (filtered.length === 0) {
            applyPendingFocus();
            return;
          }

          const selectedId = typeof DocumentViewer?.getSelectedId === "function"
            ? DocumentViewer.getSelectedId()
            : null;

          filtered.forEach((doc) => {
            const row = document.createElement("tr");
            row.dataset.id = doc.id;
            row.tabIndex = -1;
            markSelection(row, doc.id === selectedId);

            const titleCell = document.createElement("td");
            const titleWrapper = document.createElement("div");
            titleWrapper.className = "library-table__title";
            const title = document.createElement("strong");
            title.textContent = doc.title || doc.name;
            const subtitle = document.createElement("span");
            subtitle.textContent = doc.description || doc.name;
            titleWrapper.append(title, subtitle);
            titleCell.appendChild(titleWrapper);
            row.appendChild(titleCell);

            const typeCell = document.createElement("td");
            typeCell.textContent = doc.type || "Unknown";
            row.appendChild(typeCell);

            const sizeCell = document.createElement("td");
            sizeCell.textContent = Utils.formatBytes(doc.size);
            row.appendChild(sizeCell);

            const updatedCell = document.createElement("td");
            updatedCell.textContent = Utils.formatRelativeTime(doc.updatedAt);
            row.appendChild(updatedCell);

            const actionsCell = document.createElement("td");
            actionsCell.className = "library-table__actions";

            const viewButton = document.createElement("button");
            viewButton.type = "button";
            viewButton.className = "library-action";
            viewButton.dataset.action = "view";
            viewButton.textContent = "View";
            actionsCell.appendChild(viewButton);

            const copyBtn = document.createElement("button");
            copyBtn.type = "button";
            copyBtn.className = "library-action";
            copyBtn.dataset.copy = doc.blobUrl || "";
            copyBtn.textContent = "Copy link";
            actionsCell.appendChild(copyBtn);

            const downloadLink = document.createElement("a");
            downloadLink.className = "library-action";
            downloadLink.href = doc.blobUrl || "#";
            downloadLink.target = "_blank";
            downloadLink.rel = "noopener";
            downloadLink.download = doc.name;
            downloadLink.textContent = "Download";
            if (!doc.blobUrl) {
              downloadLink.classList.add("is-disabled");
              downloadLink.setAttribute("aria-disabled", "true");
            }
            actionsCell.appendChild(downloadLink);

            const deleteButton = document.createElement("button");
            deleteButton.type = "button";
            deleteButton.className = "library-action";
            deleteButton.dataset.action = "delete";
            deleteButton.textContent = "Delete";
            actionsCell.appendChild(deleteButton);

            row.appendChild(actionsCell);
            rows.appendChild(row);
          });

          applyPendingFocus();
          syncSelection();
        }

        DocumentStore.subscribe((nextDocs) => {
          docs = nextDocs;
          render();
        });

        searchInput?.addEventListener("input", (event) => {
          query = event.target.value.trim().toLowerCase();
          render();
        });

        rows?.addEventListener("click", (event) => {
          const actionTarget = event.target.closest("[data-action]");
          if (!actionTarget) return;
          const row = actionTarget.closest("tr[data-id]");
          const id = row?.dataset.id;
          if (!id) return;
          if (actionTarget.dataset.action === "view") {
            DocumentViewer.selectDocument(id);
            pendingFocusTarget = id;
            syncSelection();
          } else if (actionTarget.dataset.action === "delete") {
            const fallback = row.previousElementSibling?.dataset.id || row.nextElementSibling?.dataset.id || "search";
            pendingFocusTarget = fallback;
            DocumentStore.removeDocument(id);
            Notifications.toast(Localization.t("notifications.documentRemoved"), "info");
          }
        });

        rows?.addEventListener("keydown", (event) => {
          const row = event.target.closest("tr[data-id]");
          if (!row || event.target !== row) return;
          const id = row.dataset.id;
          if (!id) return;
          if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            DocumentViewer.selectDocument(id);
            pendingFocusTarget = id;
            syncSelection();
          } else if (event.key === "Delete") {
            event.preventDefault();
            const fallback = row.previousElementSibling?.dataset.id || row.nextElementSibling?.dataset.id || "search";
            pendingFocusTarget = fallback;
            DocumentStore.removeDocument(id);
            Notifications.toast(Localization.t("notifications.documentRemoved"), "info");
          }
        });

        document.addEventListener("documentviewerchange", () => {
          syncSelection();
        });

        return {
          focusRow,
          focusFirst() {
            const firstRow = rows?.querySelector("tr[data-id]");
            firstRow?.focus({ preventScroll: false });
          },
        };
      })();

      const ImageViewer = (() => {
      })();

      const ImageViewer = (() => {
        const canvas = document.querySelector("[data-image-canvas]");
        const preview = canvas?.querySelector("[data-image-preview]");
        const emptyState = canvas?.querySelector("[data-image-empty]");
        const controls = document.querySelector("[data-image-controls]");
        const fitButtons = controls ? Array.from(controls.querySelectorAll("[data-image-fit]")) : [];
        const zoomSlider = controls?.querySelector("[data-image-zoom]");
        const meta = document.querySelector("[data-image-meta]");
        const nameEl = document.querySelector("[data-image-name]");
        const filenameEl = document.querySelector("[data-image-filename]");
        const dimensionsEl = document.querySelector("[data-image-dimensions]");
        const sizeEl = document.querySelector("[data-image-size]");
        const typeEl = document.querySelector("[data-image-type]");
        const altEl = document.querySelector("[data-image-alt]");
        const takenEl = document.querySelector("[data-image-taken]");
        const linkInput = document.querySelector("[data-image-link]");
        const openLink = document.querySelector("[data-image-open]");
        const exifContainer = document.querySelector("[data-image-exif]");
        const exifList = document.querySelector("[data-image-exif-list]");
        let currentId = null;
        let currentFit = "contain";
        let zoom = 100;
        let currentOrientation = 1;

        function focusCanvas() {
          if (canvas) {
            canvas.setAttribute("tabindex", "-1");
            canvas.focus({ preventScroll: true });
          }
        }

        function emitSelectionChange() {
          document.dispatchEvent(
            new CustomEvent("imageviewerchange", { detail: { id: currentId } })
          );
        }

        function resolveOrientationTransform(value) {
          switch (value) {
            case 2:
              return "scaleX(-1)";
            case 3:
              return "rotate(180deg)";
            case 4:
              return "scaleY(-1)";
            case 5:
              return "rotate(90deg) scaleX(-1)";
            case 6:
              return "rotate(90deg)";
            case 7:
              return "rotate(-90deg) scaleX(-1)";
            case 8:
              return "rotate(-90deg)";
            default:
              return "";
          }
        }

        function applyTransform() {
          if (!preview) return;
          const scale = zoom / 100;
          const orientationTransform = resolveOrientationTransform(currentOrientation);
          if (orientationTransform) {
            preview.style.transform = `${orientationTransform} scale(${scale})`;
          } else {
            preview.style.transform = `scale(${scale})`;
          }
        }

        function setZoom(value) {
          const clamped = Math.max(25, Math.min(200, Number(value) || 100));
          zoom = clamped;
          if (zoomSlider && zoomSlider.value !== String(clamped)) {
            zoomSlider.value = String(clamped);
          }
          applyTransform();
        }

        function setFit(nextFit) {
          currentFit = nextFit;
          if (canvas) {
            canvas.dataset.fit = nextFit;
          }
          fitButtons.forEach((button) => {
            button.classList.toggle("is-active", button.dataset.imageFit === nextFit);
          });
          applyTransform();
        }

        function clearMeta() {
          if (nameEl) nameEl.textContent = "—";
          if (filenameEl) filenameEl.textContent = "—";
          if (dimensionsEl) dimensionsEl.textContent = "—";
          if (sizeEl) sizeEl.textContent = "—";
          if (typeEl) typeEl.textContent = "—";
          if (altEl) altEl.textContent = "—";
          if (takenEl) takenEl.textContent = "—";
          if (linkInput) linkInput.value = "";
          if (openLink) {
            openLink.href = "#";
            openLink.setAttribute("aria-disabled", "true");
          }
          if (exifList) {
            exifList.textContent = "";
          }
          if (exifContainer) {
            exifContainer.hidden = true;
          }
        }

        function renderEmpty() {
          currentId = null;
          currentOrientation = 1;
          zoom = 100;
          if (zoomSlider) {
            zoomSlider.value = "100";
          }
          if (canvas) {
            canvas.dataset.fit = currentFit;
          }
          if (preview) {
            preview.hidden = true;
            preview.removeAttribute("src");
            preview.style.transform = "scale(1)";
          }
          if (emptyState) {
            emptyState.hidden = false;
          }
          if (controls) controls.hidden = true;
          if (meta) meta.hidden = true;
          clearMeta();
          setFit(currentFit);
          emitSelectionChange();
          focusCanvas();
        }

        function formatExifEntries(exif) {
          if (!exif || typeof exif !== "object") return [];
          const entries = [];
          const camera = [exif.make, exif.model].filter(Boolean).join(" ").trim();
          if (camera) {
            entries.push({ label: "Camera", value: camera });
          }
          if (exif.lensModel) {
            entries.push({ label: "Lens", value: exif.lensModel });
          }
          if (typeof exif.exposureTime === "number" && exif.exposureTime > 0) {
            const exposure = exif.exposureTime < 1
              ? `1/${Math.round(1 / exif.exposureTime)} s`
              : `${exif.exposureTime.toFixed(2)} s`;
            entries.push({ label: "Exposure", value: exposure });
          }
          if (typeof exif.shutterSpeed === "number" && !Number.isNaN(exif.shutterSpeed)) {
            entries.push({ label: "Shutter speed", value: `${exif.shutterSpeed.toFixed(2)} EV` });
          }
          if (typeof exif.fNumber === "number" && exif.fNumber > 0) {
            entries.push({ label: "Aperture", value: `ƒ/${exif.fNumber.toFixed(1)}` });
          }
          if (typeof exif.iso === "number" && exif.iso > 0) {
            entries.push({ label: "ISO", value: `ISO ${exif.iso}` });
          }
          if (typeof exif.exposureBias === "number" && !Number.isNaN(exif.exposureBias)) {
            const bias = exif.exposureBias.toFixed(2);
            entries.push({ label: "Exposure bias", value: `${bias} EV` });
          }
          if (typeof exif.focalLength === "number" && exif.focalLength > 0) {
            entries.push({ label: "Focal length", value: `${exif.focalLength.toFixed(1)} mm` });
          }
          if (typeof exif.focalLength35mm === "number" && exif.focalLength35mm > 0) {
            entries.push({ label: "35mm equivalent", value: `${exif.focalLength35mm} mm` });
          }
          if (exif.software) {
            entries.push({ label: "Software", value: exif.software });
          }
          const orientationDescription = describeOrientation(exif.orientation);
          if (orientationDescription) {
            entries.push({ label: "Orientation", value: orientationDescription });
          }
          return entries;
        }

        function renderExif(exif) {
          if (!exifContainer || !exifList) return;
          const entries = formatExifEntries(exif);
          exifList.textContent = "";
          if (!entries.length) {
            exifContainer.hidden = true;
            return;
          }
          entries.forEach(({ label, value }) => {
            const item = document.createElement("div");
            const strong = document.createElement("strong");
            strong.textContent = `${label}:`;
            item.append(strong, document.createTextNode(` ${value}`));
            exifList.appendChild(item);
          });
          exifContainer.hidden = false;
        }

        function renderImage(image) {
          if (!image) {
            renderEmpty();
            return;
          }
          currentId = image.id;
          currentOrientation = typeof image.exif?.orientation === "number" ? image.exif.orientation : 1;
          if (zoomSlider) {
            zoomSlider.value = "100";
          }
          zoom = 100;
          if (preview) {
            const src = image.blobUrl || image.dataUrl || "";
            if (src) {
              preview.src = src;
            }
            preview.alt = image.alt || image.title || image.name;
            preview.hidden = false;
          }
          if (emptyState) {
            emptyState.hidden = true;
          }
          if (controls) controls.hidden = false;
          if (meta) meta.hidden = false;
          setFit(currentFit || "contain");

          if (nameEl) nameEl.textContent = image.title || image.name;
          if (filenameEl) filenameEl.textContent = image.name;
          if (dimensionsEl) {
            dimensionsEl.textContent = image.width && image.height ? `${image.width} × ${image.height}px` : "—";
          }
          if (sizeEl) sizeEl.textContent = Utils.formatBytes(image.size);
          if (typeEl) typeEl.textContent = image.type || "Unknown";
          if (altEl) altEl.textContent = image.alt || "—";
          if (takenEl) {
            let capturedLabel = "—";
            if (image.capturedAt) {
              const formatted = Utils.formatDateTime(image.capturedAt);
              capturedLabel = formatted !== "—" ? formatted : image.capturedAt;
            } else if (image.exif?.dateTimeOriginal) {
              capturedLabel = image.exif.dateTimeOriginal.replace(/\0/g, "").trim();
            }
            takenEl.textContent = capturedLabel || "—";
          }

          if (linkInput) {
            linkInput.value = image.blobUrl || image.dataUrl || "";
          }
          if (openLink) {
            if (image.blobUrl || image.dataUrl) {
              openLink.href = image.blobUrl || image.dataUrl || "#";
              openLink.removeAttribute("aria-disabled");
            } else {
              openLink.href = "#";
              openLink.setAttribute("aria-disabled", "true");
            }
          }

          renderExif(image.exif);
          applyTransform();
          emitSelectionChange();
          focusCanvas();
        }

        fitButtons.forEach((button) => {
          button.addEventListener("click", () => {
            const fit = button.dataset.imageFit;
            if (!fit) return;
            setFit(fit);
          });
        });

        if (zoomSlider) {
          zoomSlider.addEventListener("input", (event) => {
            setZoom(event.target.value);
          });
          zoomSlider.addEventListener("change", (event) => {
            setZoom(event.target.value);
          });
        }

        ImageStore.subscribe((items) => {
          if (!currentId) {
            if (items.length === 0) {
              renderEmpty();
            }
            return;
          }
          const match = items.find((image) => image.id === currentId);
          if (!match) {
            renderEmpty();
          } else {
            renderImage(match);
          }
        });

        renderEmpty();

        return {
          selectImage(id) {
            const image = ImageStore.getImage(id);
            if (image) {
              renderImage(image);
            } else {
              renderEmpty();
            }
          },
          getSelectedId() {
            return currentId;
          },
        };
      })();

      const ImageGallery = (() => {
        const items = document.querySelector("[data-image-gallery-items]");
        const emptyState = document.querySelector("[data-image-gallery-empty]");
        const searchInput = document.querySelector("[data-image-search]");
        const viewButtons = Array.from(document.querySelectorAll("[data-image-view]"));
        if (!items) return null;
        let images = [];
        let query = "";
        let viewMode = "grid";
        let pendingFocusId = null;

        const observer = typeof IntersectionObserver !== "undefined"
          ? new IntersectionObserver((entries, obs) => {
              entries.forEach((entry) => {
                if (!entry.isIntersecting) return;
                const target = entry.target;
                const src = target.dataset.src;
                if (src) {
                  target.src = src;
                  target.removeAttribute("data-src");
                }
                obs.unobserve(target);
              });
            }, { rootMargin: "120px", threshold: 0.1 })
          : null;

        function getButtonSelector(id) {
          if (!id) return null;
          if (typeof CSS !== "undefined" && CSS.escape) {
            return `.image-gallery__thumb[data-id="${CSS.escape(id)}"]`;
          }
          const safe = String(id).replace(/"/g, '\"');
          return `.image-gallery__thumb[data-id="${safe}"]`;
        }

        function focusItem(id) {
          const selector = getButtonSelector(id);
          if (!selector) return;
          const button = items.querySelector(selector);
          button?.focus({ preventScroll: false });
        }

        function clearObserver() {
          observer?.disconnect();
        }

        function matches(image) {
          if (!query) return true;
          const value = query.toLowerCase();
          const fields = [
            image.title,
            image.name,
            image.type,
            image.alt,
            image.exif?.make,
            image.exif?.model,
            image.exif?.lensModel,
            image.exif?.software,
          ];
          return fields
            .filter(Boolean)
            .some((field) => String(field).toLowerCase().includes(value));
        }

        function syncSelection() {
          const selectedId = ImageViewer.getSelectedId();
          items.querySelectorAll(".image-gallery__thumb").forEach((thumb) => {
            thumb.classList.toggle("is-selected", thumb.dataset.id === selectedId);
            if (thumb.dataset.id === selectedId) {
              thumb.setAttribute("aria-current", "true");
            } else {
              thumb.removeAttribute("aria-current");
            }
          });
        }

        function applyPendingFocus() {
          if (!pendingFocusId) return;
          if (pendingFocusId === "search") {
            searchInput?.focus({ preventScroll: false });
          } else {
            focusItem(pendingFocusId);
          }
          pendingFocusId = null;
        }

        function render() {
          clearObserver();
          items.textContent = "";
          const filtered = images.filter(matches);
          if (emptyState) {
            emptyState.hidden = filtered.length > 0;
          }
          items.classList.toggle("image-gallery__items--grid", viewMode === "grid");
          items.classList.toggle("image-gallery__items--list", viewMode === "list");
          if (filtered.length === 0) {
            syncSelection();
            applyPendingFocus();
            return;
          }

          filtered.forEach((image) => {
            const listItem = document.createElement("li");
            listItem.className = "image-gallery__item";

            const button = document.createElement("button");
            button.type = "button";
            button.className = "image-gallery__thumb";
            button.dataset.id = image.id;
            const labelName = image.title || image.name || Localization.t("common.unknownFile");
            button.setAttribute("aria-label", Localization.t("gallery.selectImage", { name: labelName }));

            const media = document.createElement("span");
            media.className = "image-gallery__thumb-media";
            const img = document.createElement("img");
            img.alt = image.alt || image.title || image.name;
            img.decoding = "async";
            img.loading = "lazy";
            const previewSrc = image.blobUrl || image.dataUrl;
            if (previewSrc) {
              if (observer) {
                img.dataset.src = previewSrc;
                observer.observe(img);
              } else {
                img.src = previewSrc;
              }
            }
            media.appendChild(img);

            const meta = document.createElement("div");
            meta.className = "image-gallery__thumb-meta";
            const title = document.createElement("span");
            title.className = "image-gallery__meta-title";
            title.textContent = image.title || image.name;
            const subtitle = document.createElement("span");
            subtitle.className = "image-gallery__meta-subtitle";
            subtitle.textContent = image.name;
            const extra = document.createElement("div");
            extra.className = "image-gallery__thumb-extra";
            if (image.width && image.height) {
              const dimensions = document.createElement("span");
              dimensions.textContent = `${image.width}×${image.height}px`;
              extra.appendChild(dimensions);
            }
            if (image.size) {
              const size = document.createElement("span");
              size.textContent = Utils.formatBytes(image.size);
              extra.appendChild(size);
            }
            meta.append(title, subtitle, extra);

            const actions = document.createElement("div");
            actions.className = "image-gallery__thumb-actions";
            const removeButton = document.createElement("button");
            removeButton.type = "button";
            removeButton.className = "image-gallery__delete";
            removeButton.textContent = Localization.t("common.remove");
            removeButton.addEventListener("click", (event) => {
              event.stopPropagation();
              const fallback = listItem.nextElementSibling?.querySelector(".image-gallery__thumb")?.dataset.id
                || listItem.previousElementSibling?.querySelector(".image-gallery__thumb")?.dataset.id
                || "search";
              pendingFocusId = fallback;
              ImageStore.removeImage(image.id);
              Notifications.toast(Localization.t("notifications.imageRemoved"), "info");
            });
            actions.appendChild(removeButton);

            button.append(media, meta, actions);
            button.addEventListener("click", () => {
              ImageViewer.selectImage(image.id);
              syncSelection();
            });

            listItem.appendChild(button);
            items.appendChild(listItem);
          });

          syncSelection();
          applyPendingFocus();
        }

        ImageStore.subscribe((nextImages) => {
          images = nextImages;
          render();
        });

        viewButtons.forEach((button) => {
          button.addEventListener("click", () => {
            const nextView = button.dataset.imageView;
            if (!nextView) return;
            viewMode = nextView;
            viewButtons.forEach((toggle) => {
              toggle.classList.toggle("is-active", toggle.dataset.imageView === nextView);
            });
            render();
          });
        });

        searchInput?.addEventListener("input", (event) => {
          query = event.target.value.trim().toLowerCase();
          render();
        });

        items.addEventListener("keydown", (event) => {
          const targetButton = event.target.closest(".image-gallery__thumb");
          if (!targetButton || event.target !== targetButton) return;
          const id = targetButton.dataset.id;
          if (!id) return;
          if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            ImageViewer.selectImage(id);
            syncSelection();
          } else if (event.key === "Delete") {
            event.preventDefault();
            const listItem = targetButton.closest("li");
            const fallback = listItem?.nextElementSibling?.querySelector(".image-gallery__thumb")?.dataset.id
              || listItem?.previousElementSibling?.querySelector(".image-gallery__thumb")?.dataset.id
              || "search";
            pendingFocusId = fallback;
            ImageStore.removeImage(id);
            Notifications.toast(Localization.t("notifications.imageRemoved"), "info");
          }
        });

        document.addEventListener("imageviewerchange", () => {
          syncSelection();
        });

        return {
          focusItem,
        };
      })();

      const ImageUpload = (() => {
      })();

      const ImageUpload = (() => {
        const form = document.querySelector("[data-image-form]");
        if (!form) return null;
        const fileInput = form.querySelector("[data-image-file-input]");
        const titleInput = form.querySelector("[data-image-title]");
        const altInput = form.querySelector("[data-image-alt]");
        const progressContainer = form.querySelector("[data-image-progress]");
        const progressBar = progressContainer?.querySelector("[data-image-progress-bar]");
        const progressFill = form.querySelector("[data-image-progress-fill]");
        const progressLabel = form.querySelector("[data-image-progress-label]");
        const feedback = form.querySelector("[data-image-feedback]");
        const dropzone = form.querySelector("[data-image-dropzone]");

        function resetFeedback() {
          Notifications.inline(feedback, "");
        }

        function showFeedback(message, tone) {
          Notifications.inline(feedback, message, tone);
        }

        function hideProgress() {
          if (!progressContainer || !progressFill || !progressLabel || !progressBar) return;
          progressContainer.hidden = true;
          progressFill.style.width = "0%";
          progressBar.setAttribute("aria-valuenow", "0");
          progressLabel.textContent = Localization.t("upload.waitingImages");
        }

        function updateProgress(percent, label) {
          if (!progressContainer || !progressFill || !progressLabel || !progressBar) return;
          const clamped = Math.max(0, Math.min(100, percent));
          progressContainer.hidden = false;
          progressFill.style.width = `${clamped}%`;
          progressBar.setAttribute("aria-valuenow", String(Math.round(clamped)));
          if (label) {
            progressLabel.textContent = label;
          }
        }

        function describeError(file, error) {
          const fileName = file?.name ?? Localization.t("common.unknownFile");
          switch (error?.code) {
            case "type":
              return Localization.t("upload.errorUnsupportedImage", { name: fileName });
            case "max-dimensions":
              return Localization.t("upload.errorImageTooLarge", {
                name: fileName,
                limit: MAX_IMAGE_DIMENSION,
              });
            case "dimensions":
              return Localization.t("upload.errorImageDimensions", { name: fileName });
            case "quota":
              return Localization.t("notifications.storageQuotaExceeded");
            case "persist":
              return Localization.t("errors.persistFailure");
            default:
              return Localization.t("upload.errorUploadFailed", { name: fileName });
          }
        }

        async function processFiles(fileList) {
          const files = Array.from(fileList ?? []).filter((item) => item instanceof File);
          if (!files.length) {
            const message = Localization.t("upload.errorSelectImages");
            showFeedback(message, "error");
            Notifications.toast(message, "error");
            return;
          }

          resetFeedback();
          let lastImage = null;
          const baseTitle = titleInput?.value.trim() ?? "";
          const baseAlt = altInput?.value.trim() ?? "";
          let warnedLarge = false;

          for (const [index, file] of files.entries()) {
            const estimatedImpact = StorageManager.estimateImpact(file.size);
            const snapshot = StorageManager.getSnapshot();
            if (!StorageManager.canStore(estimatedImpact)) {
              const message = Localization.t("notifications.storageQuotaExceeded");
              showFeedback(message, "error");
              Notifications.toast(message, "error");
              hideProgress();
              return;
            }
            const predictedRatio = snapshot.limit
              ? Math.round(((snapshot.used + estimatedImpact) / snapshot.limit) * 100)
              : 100;
            if (!warnedLarge && predictedRatio >= 85) {
              Notifications.toast(Localization.t("notifications.largeFileWarning"), "info");
              warnedLarge = true;
            }
            updateProgress(
              (index / files.length) * 100,
              Localization.t("upload.validating", { name: file.name })
            );
            try {
              const imageRecord = await ImageStore.createImage(
                file,
                {
                  title: baseTitle
                    ? files.length > 1
                      ? `${baseTitle} (${index + 1})`
                      : baseTitle
                    : undefined,
                  alt: baseAlt
                    ? files.length > 1
                      ? `${baseAlt} (${index + 1})`
                      : baseAlt
                    : undefined,
                },
                (progress) => {
                  const overall = ((index + progress) / files.length) * 100;
                  updateProgress(
                    overall,
                    Localization.t("upload.progress", {
                      name: file.name,
                      percent: Math.round(progress * 100),
                    })
                  );
                }
              );
              lastImage = imageRecord;
            } catch (error) {
              console.error("Image upload failed", error);
              const message = describeError(file, error);
              showFeedback(message, "error");
              Notifications.toast(message, "error");
              hideProgress();
              return;
            }
          }

          const firstImageName = files[0]?.name ?? Localization.t("common.unknownFile");
          const summary =
            files.length > 1
              ? Localization.t("upload.summaryImagesMultiple", { count: files.length })
              : Localization.t("upload.summaryImagesSingle", { name: firstImageName });
          updateProgress(100, summary);
          showFeedback(Localization.t("upload.completeImages"), "success");
          Notifications.toast(Localization.t("notifications.imageUploadSuccess"), "success");
          form.reset();
          if (fileInput) {
            fileInput.value = "";
          }
          setTimeout(() => {
            hideProgress();
          }, 600);
          if (lastImage) {
            ImageViewer.selectImage(lastImage.id);
            if (ImageGallery?.focusItem) {
              window.setTimeout(() => ImageGallery.focusItem(lastImage.id), 0);
            }
          }
        }

        form.addEventListener("submit", (event) => {
          event.preventDefault();
          processFiles(fileInput?.files ?? []);
        });

        form.addEventListener("reset", () => {
          hideProgress();
          resetFeedback();
        });

        fileInput?.addEventListener("change", () => {
          resetFeedback();
        });

        if (dropzone) {
          ["dragenter", "dragover"].forEach((eventName) => {
            dropzone.addEventListener(eventName, (event) => {
              event.preventDefault();
              dropzone.classList.add("is-dragover");
            });
          });

          ["dragleave", "dragend"].forEach((eventName) => {
            dropzone.addEventListener(eventName, () => {
              dropzone.classList.remove("is-dragover");
            });
          });

          dropzone.addEventListener("drop", (event) => {
            event.preventDefault();
            dropzone.classList.remove("is-dragover");
            if (event.dataTransfer?.files?.length) {
              processFiles(event.dataTransfer.files);
            }
          });
        }

        return null;
      })();

      const UploadController = (() => {
        const form = document.getElementById("document-upload-form");
        if (!form) return null;
        const fileInput = form.querySelector("[data-file-input]");
        const titleInput = form.querySelector("[data-title-input]");
        const descriptionInput = form.querySelector("[data-description-input]");
        const progressContainer = form.querySelector("[data-upload-progress]");
        const progressBar = progressContainer?.querySelector(".upload-progress__bar");
        const progressFill = form.querySelector("[data-progress-fill]");
        const progressLabel = form.querySelector("[data-progress-label]");
        const feedback = form.querySelector("[data-upload-feedback]");
        const dropzone = form.querySelector("[data-dropzone]");

        function resetFeedback() {
          Notifications.inline(feedback, "");
        }

        function showFeedback(message, tone) {
          Notifications.inline(feedback, message, tone);
        }

        function hideProgress() {
          if (!progressContainer || !progressFill || !progressLabel || !progressBar) return;
          progressContainer.hidden = true;
          progressFill.style.width = "0%";
          progressBar.setAttribute("aria-valuenow", "0");
          progressLabel.textContent = Localization.t("upload.waitingDocuments");
        }

        function updateProgress(percent, label) {
          if (!progressContainer || !progressFill || !progressLabel || !progressBar) return;
          const clamped = Math.max(0, Math.min(100, percent));
          progressContainer.hidden = false;
          progressFill.style.width = `${clamped}%`;
          progressBar.setAttribute("aria-valuenow", String(Math.round(clamped)));
          if (label) {
            progressLabel.textContent = label;
          }
        }

        async function processFiles(fileList) {
          const files = Array.from(fileList ?? []).filter((item) => item instanceof File);
          if (!files.length) {
            const message = Localization.t("upload.errorSelectDocuments");
            showFeedback(message, "error");
            Notifications.toast(message, "error");
            return;
          }

          resetFeedback();
          let lastDocument = null;
          const baseTitle = titleInput?.value.trim() ?? "";
          const description = descriptionInput?.value.trim() ?? "";
          let warnedLarge = false;

          for (const [index, file] of files.entries()) {
            const estimatedImpact = StorageManager.estimateImpact(file.size);
            const snapshot = StorageManager.getSnapshot();
            if (!StorageManager.canStore(estimatedImpact)) {
              const message = Localization.t("notifications.storageQuotaExceeded");
              showFeedback(message, "error");
              Notifications.toast(message, "error");
              hideProgress();
              return;
            }
            const predictedRatio = snapshot.limit
              ? Math.round(((snapshot.used + estimatedImpact) / snapshot.limit) * 100)
              : 100;
            if (!warnedLarge && predictedRatio >= 85) {
              Notifications.toast(Localization.t("notifications.largeFileWarning"), "info");
              warnedLarge = true;
            }
            updateProgress(
              (index / files.length) * 100,
              Localization.t("upload.progress", { name: file.name, percent: 0 })
            );
            try {
              const documentRecord = await DocumentStore.createDocument(
                file,
                {
                  title: baseTitle
                    ? files.length > 1
                      ? `${baseTitle} (${index + 1})`
                      : baseTitle
                    : undefined,
                  description,
                },
                (progress) => {
                  const overall = ((index + progress) / files.length) * 100;
                  updateProgress(
                    overall,
                    Localization.t("upload.progress", {
                      name: file.name,
                      percent: Math.round(progress * 100),
                    })
                  );
                }
              );
              lastDocument = documentRecord;
            } catch (error) {
              console.error("Upload failed", error);
              const fileName = file?.name ?? Localization.t("common.unknownFile");
              const message =
                error?.code === "quota"
                  ? Localization.t("notifications.storageQuotaExceeded")
                  : error?.code === "persist"
                  ? Localization.t("errors.persistFailure")
                  : Localization.t("upload.errorUploadFailed", { name: fileName });
              showFeedback(message, "error");
              Notifications.toast(message, "error");
              hideProgress();
              return;
            }
          }

          const firstDocName = files[0]?.name ?? Localization.t("common.unknownFile");
          const summary =
            files.length > 1
              ? Localization.t("upload.summaryDocumentsMultiple", { count: files.length })
              : Localization.t("upload.summaryDocumentsSingle", { name: firstDocName });
          updateProgress(100, summary);
          showFeedback(Localization.t("upload.completeDocuments"), "success");
          Notifications.toast(Localization.t("notifications.documentUploadSuccess"), "success");
          form.reset();
          if (fileInput) {
            fileInput.value = "";
          }
          setTimeout(() => {
            hideProgress();
          }, 600);
          if (lastDocument) {
            DocumentViewer.selectDocument(lastDocument.id);
            if (LibraryView?.focusRow) {
              window.setTimeout(() => LibraryView.focusRow(lastDocument.id), 0);
            }
          }
        }

        form.addEventListener("submit", (event) => {
          event.preventDefault();
          processFiles(fileInput?.files ?? []);
        });

        form.addEventListener("reset", () => {
          hideProgress();
          resetFeedback();
        });

        fileInput?.addEventListener("change", () => {
          resetFeedback();
        });

        if (dropzone) {
          ["dragenter", "dragover"].forEach((eventName) => {
            dropzone.addEventListener(eventName, (event) => {
              event.preventDefault();
              dropzone.classList.add("is-dragover");
            });
          });

          ["dragleave", "dragend"].forEach((eventName) => {
            dropzone.addEventListener(eventName, () => {
              dropzone.classList.remove("is-dragover");
            });
          });

          dropzone.addEventListener("drop", (event) => {
            event.preventDefault();
            dropzone.classList.remove("is-dragover");
            if (event.dataTransfer?.files?.length) {
              processFiles(event.dataTransfer.files);
            }
          });
        }

        document.addEventListener("paste", (event) => {
          if (event.clipboardData?.files?.length) {
            event.preventDefault();
            processFiles(event.clipboardData.files);
          }
        });

        return null;
      })();
    </script>
  </body>
</html>
