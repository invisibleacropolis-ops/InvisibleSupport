<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Invisible Support Portal</title>
    <style>
      /*
        Design tokens create a consistent visual system for engineers and designers.
        Tokens are exposed as CSS custom properties so themes can be swapped or extended.
      */
      :root {
        color-scheme: light dark;
        --color-surface: #ffffff;
        --color-surface-muted: #f5f7fa;
        --color-elevated: #ffffffee;
        --color-border: #d8dee6;
        --color-text: #1c2333;
        --color-text-muted: #546173;
        --color-accent: #4b6bfb;
        --color-accent-strong: #2e51f0;
        --color-success: #3bb273;
        --color-danger: #f25757;
        --color-immersive: 200 56% 16%;

        --document-viewer-width: 40%;
        --image-viewer-width: 40%;

        --font-sans: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
        --font-mono: "JetBrains Mono", "SFMono-Regular", ui-monospace, monospace;

        --space-2xs: 0.25rem;
        --space-xs: 0.5rem;
        --space-sm: 0.75rem;
        --space-md: 1rem;
        --space-lg: 1.5rem;
        --space-xl: 2rem;
        --space-2xl: 3rem;

        --radius-sm: 0.5rem;
        --radius-md: 0.75rem;
        --radius-lg: 1.5rem;

        --shadow-sm: 0 8px 20px rgba(28, 35, 51, 0.08);
        --shadow-lg: 0 24px 60px rgba(28, 35, 51, 0.16);

        --transition-base: 180ms ease;
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --color-surface: #101321;
          --color-surface-muted: #161a2d;
          --color-elevated: rgba(18, 22, 38, 0.9);
          --color-border: rgba(119, 131, 160, 0.3);
          --color-text: #f5f7ff;
          --color-text-muted: #a6b2d2;
        }
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      .visually-hidden {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      html {
        height: 100%;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: var(--font-sans);
        background: var(--color-surface-muted);
        color: var(--color-text);
        overflow-y: auto;
        overflow-x: hidden;
        scrollbar-gutter: stable;
      }

      body::-webkit-scrollbar {
        width: 0.75rem;
      }

      body::-webkit-scrollbar-track {
        background: color-mix(in srgb, var(--color-surface-muted) 80%, transparent 20%);
      }

      body::-webkit-scrollbar-thumb {
        background: color-mix(in srgb, var(--color-accent) 45%, transparent 55%);
        border-radius: var(--radius-md);
      }

      .theme {
        position: relative;
        overflow-x: hidden;
        overflow-y: visible;
      }

      .theme--immersive::before {
        content: "";
        position: fixed;
        inset: 0;
        background: radial-gradient(
            circle at 10% 20%,
            hsla(var(--color-immersive) / 0.6) 0,
            transparent 55%
          ),
          radial-gradient(
            circle at 80% 10%,
            hsla(220 60% 40% / 0.55) 0,
            transparent 50%
          ),
          radial-gradient(
            circle at 50% 100%,
            hsla(260 65% 45% / 0.45) 0,
            transparent 60%
          );
        pointer-events: none;
        opacity: 0.9;
        z-index: -2;
      }

      .theme--immersive::after {
        content: "";
        position: fixed;
        inset: 0;
        background: linear-gradient(
          180deg,
          rgba(12, 16, 28, 0.35) 0%,
          rgba(12, 16, 28, 0.1) 35%,
          rgba(12, 16, 28, 0.65) 100%
        );
        mix-blend-mode: multiply;
        pointer-events: none;
        z-index: -1;
      }

      .portal {
        position: relative;
        padding: var(--space-2xl) clamp(var(--space-md), 6vw, var(--space-2xl));
        display: flex;
        flex-direction: column;
        gap: var(--space-xl);
      }

      .portal__header {
        display: flex;
        flex-direction: column;
        gap: var(--space-sm);
        max-width: 48rem;
      }

      .storage-meter {
        display: grid;
        gap: var(--space-xs);
        padding: var(--space-sm) var(--space-md);
        border-radius: var(--radius-md);
        border: 1px solid color-mix(in srgb, var(--color-border) 75%, transparent 25%);
        background: color-mix(in srgb, var(--color-surface) 88%, transparent 12%);
        max-width: min(24rem, 100%);
      }

      .storage-meter__heading {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: var(--space-sm);
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--color-text-muted);
      }

      .storage-meter__values {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: var(--space-sm);
        font-size: 0.9rem;
        font-weight: 600;
      }

      .storage-meter__progress {
        position: relative;
        height: 0.5rem;
        border-radius: var(--radius-md);
        background: color-mix(in srgb, var(--color-border) 50%, transparent 50%);
        overflow: hidden;
      }

      .storage-meter__progress-bar {
        position: absolute;
        inset: 0;
        width: 0%;
        border-radius: inherit;
        background: linear-gradient(90deg, var(--color-accent), var(--color-accent-strong));
        transition: width var(--transition-base);
      }

      .storage-meter.is-warning .storage-meter__progress-bar {
        background: linear-gradient(90deg, var(--color-danger), color-mix(in srgb, var(--color-danger) 70%, var(--color-accent) 30%));
      }

      .storage-meter.is-exceeded .storage-meter__progress-bar {
        background: var(--color-danger);
      }

      .storage-meter__warning {
        margin: 0;
        font-size: 0.85rem;
        color: var(--color-danger);
      }

      .storage-meter__actions {
        display: flex;
        justify-content: flex-end;
      }

      .storage-meter__button {
        font-size: 0.85rem;
        padding: var(--space-2xs) var(--space-sm);
      }

      .portal__heading {
        font-size: clamp(2rem, 3vw, 2.75rem);
        font-weight: 700;
        letter-spacing: -0.01em;
        margin: 0;
      }

      .portal__lede {
        margin: 0;
        color: var(--color-text-muted);
        font-size: 1.05rem;
        line-height: 1.6;
      }

      .portal__grid {
        display: grid;
        grid-template-columns:
          minmax(0, calc(100% - var(--document-viewer-width)))
          minmax(0, var(--document-viewer-width));
        gap: var(--space-xl);
        align-items: start;
      }

      @media (max-width: 960px) {
        .portal__grid {
          --document-viewer-width: 100%;
          grid-template-columns: 1fr;
        }

        .portal__column--secondary {
          order: -1;
        }
      }

      .image-portal {
        display: grid;
        gap: var(--space-xl);
      }

      .image-portal__header {
        display: flex;
        flex-direction: column;
        gap: var(--space-sm);
        max-width: 48rem;
      }

      .image-portal__grid {
        display: grid;
        grid-template-columns:
          minmax(0, calc(100% - var(--image-viewer-width)))
          minmax(0, var(--image-viewer-width));
        gap: var(--space-xl);
        align-items: start;
      }

      .image-portal__column {
        display: grid;
        gap: var(--space-xl);
      }

      @media (max-width: 960px) {
        .image-portal__grid {
          --image-viewer-width: 100%;
          grid-template-columns: 1fr;
        }
      }

      .toast-stack {
        position: fixed;
        bottom: var(--space-xl);
        right: var(--space-xl);
        display: grid;
        gap: var(--space-sm);
        width: min(24rem, calc(100vw - 2 * var(--space-xl)));
        z-index: 1000;
        pointer-events: none;
      }

      .toast {
        display: flex;
        align-items: center;
        gap: var(--space-sm);
        border-radius: var(--radius-md);
        padding: var(--space-sm) var(--space-md);
        background: var(--color-elevated);
        border: 1px solid color-mix(in srgb, var(--color-border) 70%, transparent 30%);
        box-shadow: var(--shadow-sm);
        color: var(--color-text);
        opacity: 0;
        transform: translateY(10px);
        transition: opacity var(--transition-base), transform var(--transition-base);
        pointer-events: auto;
      }

      .toast.is-visible {
        opacity: 1;
        transform: translateY(0);
      }

      .toast__icon {
        font-size: 1.2rem;
      }

      .toast__message {
        flex: 1 1 auto;
      }

      .toast__dismiss {
        margin-left: auto;
        appearance: none;
        border: none;
        background: transparent;
        color: var(--color-text-muted);
        font-weight: 600;
        cursor: pointer;
        padding: var(--space-2xs) var(--space-xs);
      }

      .toast__dismiss:hover {
        color: var(--color-text);
      }

      .toast__dismiss:focus-visible {
        outline: 2px solid color-mix(in srgb, var(--color-accent) 65%, white 35%);
        outline-offset: 2px;
        border-radius: var(--radius-sm);
      }

      .toast--success {
        border-color: color-mix(in srgb, var(--color-success) 40%, transparent 60%);
      }

      .toast--success .toast__icon {
        color: var(--color-success);
      }

      .toast--error {
        border-color: color-mix(in srgb, var(--color-danger) 40%, transparent 60%);
      }

      .toast--error .toast__icon {
        color: var(--color-danger);
      }

      .toast--info {
        border-color: color-mix(in srgb, var(--color-accent) 40%, transparent 60%);
      }

      .toast--info .toast__icon {
        color: var(--color-accent-strong);
      }

      @media (max-width: 640px) {
        .toast-stack {
          left: var(--space-md);
          right: var(--space-md);
          width: auto;
          bottom: var(--space-lg);
        }
      }

      /* Utility foundation */
      .u-card {
        background: var(--color-elevated);
        border-radius: var(--radius-lg);
        border: 1px solid var(--color-border);
        box-shadow: var(--shadow-sm);
        padding: var(--space-xl) clamp(var(--space-lg), 4vw, var(--space-xl));
        backdrop-filter: blur(14px);
        display: flex;
        flex-direction: column;
        gap: var(--space-lg);
      }

      .u-card__header {
        display: flex;
        flex-direction: column;
        gap: var(--space-xs);
      }

      .u-card__title {
        font-size: 1.35rem;
        font-weight: 600;
        margin: 0;
      }

      .u-card__subtitle {
        margin: 0;
        color: var(--color-text-muted);
        font-size: 0.95rem;
      }

      .u-btn {
        appearance: none;
        border: none;
        border-radius: var(--radius-md);
        padding: var(--space-sm) var(--space-lg);
        font-size: 0.95rem;
        font-weight: 600;
        letter-spacing: 0.01em;
        cursor: pointer;
        transition: transform var(--transition-base),
          box-shadow var(--transition-base),
          background-color var(--transition-base);
      }

      .u-btn--sm {
        padding: var(--space-2xs) var(--space-sm);
        font-size: 0.85rem;
      }

      .u-btn:focus-visible {
        outline: 3px solid color-mix(in srgb, var(--color-accent) 60%, white 40%);
        outline-offset: 2px;
      }

      .u-btn--primary {
        background: linear-gradient(135deg, var(--color-accent), var(--color-accent-strong));
        color: white;
        box-shadow: 0 12px 24px rgba(75, 107, 251, 0.32);
      }

      .u-btn--primary:hover {
        transform: translateY(-1px);
      }

      .u-btn--ghost {
        background: color-mix(in srgb, var(--color-accent) 12%, transparent 88%);
        color: var(--color-accent-strong);
        border: 1px solid color-mix(in srgb, var(--color-accent) 40%, transparent 60%);
      }

      .u-input {
        width: 100%;
        border-radius: var(--radius-md);
        border: 1px solid var(--color-border);
        background: color-mix(in srgb, var(--color-surface) 90%, transparent 10%);
        padding: var(--space-sm) var(--space-md);
        font-size: 1rem;
        color: var(--color-text);
        transition: border-color var(--transition-base), box-shadow var(--transition-base);
      }

      .u-input:focus {
        border-color: color-mix(in srgb, var(--color-accent) 60%, var(--color-border) 40%);
        box-shadow: 0 0 0 4px color-mix(in srgb, var(--color-accent) 16%, transparent 84%);
        outline: none;
      }

      .u-input[type="file"] {
        padding: var(--space-sm);
      }

      .u-tabs {
        display: flex;
        gap: var(--space-xs);
        border-radius: var(--radius-md);
        background: color-mix(in srgb, var(--color-surface) 65%, transparent 35%);
        padding: var(--space-2xs);
      }

      .u-tabs__trigger {
        flex: 1 1 auto;
        text-align: center;
        padding: var(--space-sm) var(--space-md);
        border-radius: var(--radius-md);
        font-size: 0.9rem;
        color: var(--color-text-muted);
        cursor: pointer;
        transition: background-color var(--transition-base), color var(--transition-base);
      }

      .u-tabs__trigger.is-active {
        background: var(--color-surface);
        color: var(--color-text);
        box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--color-border) 80%, transparent 20%);
      }

      .u-modal {
        position: fixed;
        inset: 0;
        display: none;
        place-items: center;
        padding: var(--space-xl);
        background: rgba(12, 16, 28, 0.45);
        backdrop-filter: blur(10px);
      }

      .u-modal.is-open {
        display: grid;
      }

      .storage-modal__summary {
        border-top: 1px solid color-mix(in srgb, var(--color-border) 80%, transparent 20%);
        padding-top: var(--space-md);
        display: grid;
        gap: var(--space-md);
      }

      .storage-summary {
        margin: 0;
        display: grid;
        gap: var(--space-xs);
      }

      .storage-summary__row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: var(--space-sm);
      }

      .storage-summary__label {
        font-size: 0.9rem;
        color: var(--color-text-muted);
      }

      .storage-summary__value {
        font-size: 0.95rem;
        font-weight: 600;
      }

      .storage-breakdown {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: var(--space-xs);
      }

      .storage-breakdown__item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: var(--space-sm);
        font-size: 0.9rem;
      }

      .storage-breakdown__label {
        color: var(--color-text-muted);
      }

      .storage-breakdown__value {
        font-weight: 600;
      }

      .u-modal__dialog {
        background: var(--color-elevated);
        padding: var(--space-xl);
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-lg);
        max-width: 28rem;
        width: min(100%, 28rem);
      }

      .u-copy {
        display: flex;
        gap: var(--space-sm);
        align-items: center;
        padding: var(--space-sm) var(--space-md);
        border-radius: var(--radius-md);
        border: 1px dashed color-mix(in srgb, var(--color-border) 75%, transparent 25%);
        background: color-mix(in srgb, var(--color-surface) 80%, transparent 20%);
      }

      .u-copy__value {
        flex: 1 1 auto;
        font-family: var(--font-mono);
        font-size: 0.95rem;
        overflow-wrap: anywhere;
      }

      .u-copy__button {
        padding: var(--space-2xs) var(--space-sm);
        border-radius: var(--radius-sm);
        background: transparent;
        color: var(--color-accent-strong);
        border: 1px solid color-mix(in srgb, var(--color-accent) 35%, transparent 65%);
        cursor: pointer;
      }

      .stack {
        display: flex;
        flex-direction: column;
        gap: var(--space-md);
      }

      .stack--lg {
        gap: var(--space-lg);
      }

      .upload-card__dropzone {
        position: relative;
        border-radius: var(--radius-lg);
        border: 2px dashed color-mix(in srgb, var(--color-border) 70%, transparent 30%);
        padding: clamp(var(--space-lg), 6vw, var(--space-2xl));
        text-align: center;
        display: grid;
        gap: var(--space-md);
        background: color-mix(
          in srgb,
          var(--color-surface) 85%,
          rgba(255, 255, 255, 0.85) 15%
        );
        transition: border-color var(--transition-base),
          background-color var(--transition-base),
          transform var(--transition-base);
      }

      .upload-card__dropzone.is-dragover {
        border-color: color-mix(in srgb, var(--color-accent) 60%, transparent 40%);
        background: color-mix(in srgb, var(--color-surface) 75%, rgba(75, 107, 251, 0.12) 25%);
        transform: translateY(-2px);
      }

      .upload-card__dropzone input[type="file"] {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        pointer-events: none;
      }

      .upload-card__accepted {
        margin: 0;
        font-size: 0.9rem;
        color: var(--color-text-muted);
      }

      .upload-card__dropzone svg {
        width: 3rem;
        height: 3rem;
        margin: 0 auto;
        color: var(--color-accent-strong);
      }

      .upload-card__queue {
        border-radius: var(--radius-md);
        border: 1px solid color-mix(in srgb, var(--color-border) 80%, transparent 20%);
        background: color-mix(in srgb, var(--color-surface) 92%, transparent 8%);
        padding: var(--space-md);
        display: grid;
        gap: var(--space-sm);
      }

      .upload-card__queue-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: var(--space-sm);
      }

      .upload-card__queue-summary {
        margin: 0;
        font-size: 0.9rem;
        color: var(--color-text);
      }

      .upload-card__queue-empty {
        margin: 0;
        font-size: 0.9rem;
        color: var(--color-text-muted);
      }

      .upload-card__queue-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: var(--space-xs);
      }

      .upload-card__queue-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: var(--space-sm);
        padding: var(--space-xs) var(--space-sm);
        border-radius: var(--radius-sm);
        background: color-mix(in srgb, var(--color-surface-muted) 70%, transparent 30%);
      }

      .upload-card__queue-item strong {
        display: block;
        font-size: 0.95rem;
      }

      .upload-card__queue-meta {
        margin: 0;
        font-size: 0.8rem;
        color: var(--color-text-muted);
      }

      .upload-card__queue-remove {
        border: none;
        background: none;
        color: var(--color-accent-strong);
        font-weight: 600;
        cursor: pointer;
        padding: var(--space-2xs) var(--space-xs);
      }

      .upload-card__queue-remove:hover {
        text-decoration: underline;
      }

      .upload-card__actions {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-sm);
        justify-content: center;
      }

      .form-grid {
        display: grid;
        gap: var(--space-md);
      }

      .form-grid--split {
        grid-template-columns: repeat(auto-fit, minmax(12rem, 1fr));
        gap: var(--space-md);
      }

      .image-gallery__toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-sm);
        justify-content: space-between;
        align-items: center;
      }

      .image-gallery__search {
        flex: 1 1 16rem;
      }

      .image-gallery__views {
        display: inline-flex;
        gap: var(--space-2xs);
        padding: var(--space-2xs);
        border-radius: var(--radius-md);
        background: color-mix(in srgb, var(--color-surface) 65%, transparent 35%);
      }

      .image-gallery__view {
        border: none;
        background: transparent;
        color: var(--color-text-muted);
        padding: var(--space-2xs) var(--space-sm);
        border-radius: var(--radius-md);
        font-size: 0.85rem;
        cursor: pointer;
        transition: background-color var(--transition-base), color var(--transition-base);
      }

      .image-gallery__view.is-active {
        background: var(--color-surface);
        color: var(--color-text);
        box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--color-border) 80%, transparent 20%);
      }

      .image-gallery__items {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: var(--space-md);
      }

      .image-gallery__items--grid {
        grid-template-columns: repeat(auto-fill, minmax(10rem, 1fr));
      }

      .image-gallery__items--list {
        grid-template-columns: 1fr;
      }

      .image-gallery__item {
        min-width: 0;
      }

      .image-gallery__thumb {
        width: 100%;
        display: grid;
        gap: var(--space-sm);
        padding: var(--space-sm);
        border-radius: var(--radius-lg);
        border: 1px solid color-mix(in srgb, var(--color-border) 80%, transparent 20%);
        background: color-mix(in srgb, var(--color-surface) 88%, transparent 12%);
        cursor: pointer;
        text-align: left;
        transition: border-color var(--transition-base), box-shadow var(--transition-base), transform var(--transition-base);
      }

      .image-gallery__thumb:hover,
      .image-gallery__thumb:focus-visible {
        outline: none;
        border-color: color-mix(in srgb, var(--color-accent) 50%, transparent 50%);
        box-shadow: 0 12px 24px rgba(75, 107, 251, 0.16);
        transform: translateY(-1px);
      }

      .image-gallery__thumb.is-selected {
        border-color: color-mix(in srgb, var(--color-accent) 65%, transparent 35%);
        box-shadow: 0 16px 32px rgba(75, 107, 251, 0.24);
      }

      .image-gallery__thumb-media {
        position: relative;
        aspect-ratio: 4 / 3;
        overflow: hidden;
        border-radius: var(--radius-md);
        background: color-mix(in srgb, var(--color-surface-muted) 85%, transparent 15%);
      }

      .image-gallery__thumb-media img {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        transition: transform var(--transition-base);
      }

      .image-gallery__thumb:hover .image-gallery__thumb-media img,
      .image-gallery__thumb:focus-visible .image-gallery__thumb-media img {
        transform: scale(1.03);
      }

      .image-gallery__thumb-meta {
        display: grid;
        gap: var(--space-2xs);
        font-size: 0.85rem;
        color: var(--color-text-muted);
      }

      .image-gallery__meta-title {
        font-weight: 600;
        font-size: 0.95rem;
        color: var(--color-text);
      }

      .image-gallery__meta-subtitle {
        color: var(--color-text-muted);
      }

      .image-gallery__thumb-extra {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-2xs);
        font-size: 0.75rem;
        color: var(--color-text-muted);
      }

      .image-gallery__items--list .image-gallery__thumb {
        grid-template-columns: minmax(0, 9rem) minmax(0, 1fr);
        align-items: center;
      }

      .image-gallery__items--list .image-gallery__thumb-media {
        width: 100%;
      }

      .image-gallery__items--list .image-gallery__thumb-meta {
        align-self: stretch;
      }

      .image-gallery__thumb-actions {
        display: flex;
        gap: var(--space-2xs);
      }

      .image-gallery__delete {
        border: none;
        background: transparent;
        color: var(--color-danger);
        font-size: 0.8rem;
        cursor: pointer;
        padding: var(--space-2xs) var(--space-sm);
        border-radius: var(--radius-sm);
        transition: background-color var(--transition-base), color var(--transition-base);
      }

      .image-gallery__delete:hover,
      .image-gallery__delete:focus-visible {
        background: color-mix(in srgb, var(--color-danger) 15%, transparent 85%);
        color: var(--color-danger);
        outline: none;
      }

      .image-gallery__empty {
        margin: 0;
        padding: var(--space-md);
        text-align: center;
        font-size: 0.9rem;
        color: var(--color-text-muted);
        border-radius: var(--radius-md);
        background: color-mix(in srgb, var(--color-surface) 85%, transparent 15%);
      }

      .image-viewer__toolbar {
        display: flex;
        flex-wrap: wrap;
        justify-content: flex-end;
        align-items: center;
        gap: var(--space-sm);
        margin-bottom: var(--space-md);
      }

      .image-viewer__canvas {
        position: relative;
        min-height: 20rem;
        border-radius: var(--radius-lg);
        border: 1px solid color-mix(in srgb, var(--color-border) 75%, transparent 25%);
        background: color-mix(in srgb, var(--color-surface) 82%, transparent 18%);
        display: grid;
        place-items: center;
        overflow: hidden;
      }

      .image-viewer__canvas[data-fit="actual"] {
        overflow: auto;
      }

      .image-viewer__canvas img {
        max-width: 100%;
        max-height: 100%;
        width: 100%;
        height: 100%;
        object-fit: contain;
        transform-origin: center;
        transition: transform 160ms ease, object-fit var(--transition-base);
      }

      .image-viewer__canvas[data-fit="cover"] img {
        object-fit: cover;
      }

      .image-viewer__canvas[data-fit="actual"] img {
        width: auto;
        height: auto;
        max-width: none;
        max-height: none;
        object-fit: contain;
      }

      .image-viewer__empty {
        text-align: center;
        display: grid;
        gap: var(--space-2xs);
        color: var(--color-text-muted);
      }

      .image-viewer__controls {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-sm);
        justify-content: space-between;
        align-items: center;
      }

      .image-viewer__control-group {
        display: inline-flex;
        gap: var(--space-2xs);
        padding: var(--space-2xs);
        border-radius: var(--radius-md);
        background: color-mix(in srgb, var(--color-surface) 65%, transparent 35%);
      }

      .image-viewer__control {
        border: none;
        background: transparent;
        color: var(--color-text-muted);
        padding: var(--space-2xs) var(--space-sm);
        border-radius: var(--radius-md);
        font-size: 0.85rem;
        cursor: pointer;
        transition: background-color var(--transition-base), color var(--transition-base);
      }

      .image-viewer__control.is-active {
        background: var(--color-surface);
        color: var(--color-text);
        box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--color-border) 80%, transparent 20%);
      }

      .image-viewer__slider {
        min-width: 10rem;
        accent-color: var(--color-accent);
      }

      .image-viewer__meta {
        display: grid;
        gap: var(--space-lg);
      }

      .image-viewer__details {
        display: grid;
        gap: var(--space-md);
        grid-template-columns: repeat(auto-fit, minmax(12rem, 1fr));
      }

      .image-viewer__details dt {
        margin: 0;
        font-size: 0.8rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--color-text-muted);
      }

      .image-viewer__details dd {
        margin: 0;
        font-weight: 600;
        font-size: 0.95rem;
      }

      .image-viewer__exif {
        border-top: 1px solid color-mix(in srgb, var(--color-border) 75%, transparent 25%);
        padding-top: var(--space-md);
        display: grid;
        gap: var(--space-sm);
      }

      .image-viewer__exif h3 {
        margin: 0;
        font-size: 1rem;
      }

      .image-viewer__exif-list {
        display: grid;
        gap: var(--space-2xs);
        font-size: 0.85rem;
        color: var(--color-text-muted);
      }

      .library-card__table {
        border-radius: var(--radius-lg);
        border: 1px solid color-mix(in srgb, var(--color-border) 80%, transparent 20%);
        background: color-mix(in srgb, var(--color-surface) 92%, transparent 8%);
        overflow: hidden;
      }

      .library-table {
        width: 100%;
        border-collapse: collapse;
        min-width: 100%;
      }

      .library-table thead {
        background: color-mix(in srgb, var(--color-surface) 70%, transparent 30%);
        color: color-mix(in srgb, var(--color-text) 90%, white 10%);
      }

      .library-table th,
      .library-table td {
        padding: var(--space-sm) var(--space-md);
        text-align: left;
        font-size: 0.9rem;
      }

      .library-table th {
        font-weight: 600;
        border-bottom: 1px solid color-mix(in srgb, var(--color-border) 80%, transparent 20%);
      }

      .library-table td {
        border-bottom: 1px solid color-mix(in srgb, var(--color-border) 70%, transparent 30%);
        vertical-align: top;
      }

      .library-table tr.is-selected {
        background: color-mix(in srgb, var(--color-accent) 12%, transparent 88%);
      }

      .library-table tr:last-child td {
        border-bottom: none;
      }

      .library-table__title {
        display: grid;
        gap: var(--space-2xs);
      }

      .library-table__title strong {
        font-weight: 600;
      }

      .library-table__title span {
        color: var(--color-text-muted);
        font-size: 0.85rem;
      }

      .library-table__actions-heading {
        text-align: right;
      }

      .library-table__actions {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-2xs);
        justify-content: flex-end;
      }

      .library-action {
        border: 1px solid color-mix(in srgb, var(--color-border) 75%, transparent 25%);
        background: color-mix(in srgb, var(--color-surface) 88%, transparent 12%);
        border-radius: var(--radius-sm);
        padding: var(--space-2xs) var(--space-sm);
        font-size: 0.8rem;
        cursor: pointer;
        color: var(--color-text);
        transition: background-color var(--transition-base), border-color var(--transition-base);
      }

      .library-action:hover,
      .library-action:focus-visible {
        border-color: color-mix(in srgb, var(--color-accent) 50%, transparent 50%);
        background: color-mix(in srgb, var(--color-accent) 12%, var(--color-surface) 88%);
        outline: none;
      }

      .library-action.is-disabled {
        pointer-events: none;
        opacity: 0.5;
      }

      .library-card__empty {
        margin: 0;
        padding: var(--space-md);
        font-size: 0.9rem;
        color: var(--color-text-muted);
        text-align: center;
        background: color-mix(in srgb, var(--color-surface) 85%, transparent 15%);
      }


      .upload-progress {
        display: grid;
        gap: var(--space-2xs);
        background: color-mix(in srgb, var(--color-surface) 82%, transparent 18%);
        border-radius: var(--radius-md);
        border: 1px solid color-mix(in srgb, var(--color-border) 75%, transparent 25%);
        padding: var(--space-sm) var(--space-md);
      }

      .upload-progress__bar {
        position: relative;
        width: 100%;
        height: 0.75rem;
        border-radius: var(--radius-sm);
        background: color-mix(in srgb, var(--color-surface) 70%, transparent 30%);
        overflow: hidden;
      }

      .upload-progress__fill {
        position: absolute;
        inset: 0;
        width: 0%;
        background: linear-gradient(135deg, var(--color-accent), var(--color-accent-strong));
        border-radius: inherit;
        transition: width 120ms ease;
      }

      .upload-progress__label {
        margin: 0;
        font-size: 0.85rem;
        color: var(--color-text-muted);
      }

      .upload-feedback {
        margin: 0;
        font-size: 0.9rem;
        border-radius: var(--radius-md);
        padding: var(--space-sm) var(--space-md);
        border: 1px solid transparent;
      }

      .upload-feedback.is-error {
        color: var(--color-danger);
        border-color: color-mix(in srgb, var(--color-danger) 40%, transparent 60%);
        background: color-mix(in srgb, var(--color-danger) 8%, var(--color-surface) 92%);
      }

      .upload-feedback.is-success {
        color: var(--color-success);
        border-color: color-mix(in srgb, var(--color-success) 40%, transparent 60%);
        background: color-mix(in srgb, var(--color-success) 10%, var(--color-surface) 90%);
      }

      .viewer-card__toolbar {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: var(--space-sm);
        margin-bottom: var(--space-md);
      }

      .viewer-card__selector {
        flex: 1 1 16rem;
        min-width: 12rem;
      }

      .viewer-card__select {
        width: 100%;
      }

      .viewer-card__resize,
      .image-viewer__resize {
        display: flex;
        align-items: center;
        gap: var(--space-xs);
        font-size: 0.85rem;
        color: var(--color-text-muted);
      }

      .viewer-card__resize input,
      .image-viewer__resize input {
        width: min(12rem, 40vw);
        accent-color: var(--color-accent);
      }

      .viewer-card__resize-value,
      .image-viewer__resize-value {
        font-variant-numeric: tabular-nums;
        font-weight: 600;
        color: var(--color-text);
      }

      .viewer-card__preview {
        min-height: 18rem;
        border-radius: var(--radius-lg);
        border: 1px solid color-mix(in srgb, var(--color-border) 80%, transparent 20%);
        background: color-mix(in srgb, var(--color-surface) 70%, transparent 30%);
        display: grid;
        gap: var(--space-md);
        padding: var(--space-lg);
      }

      .viewer-card__preview > * {
        justify-self: stretch;
      }

      .viewer-card__preview[data-state="empty"],
      .viewer-card__preview[data-state="loading"] {
        justify-items: center;
        align-content: center;
        text-align: center;
      }

      .viewer-card__preview[data-state="empty"] > *,
      .viewer-card__preview[data-state="loading"] > * {
        justify-self: center;
      }

      .viewer-card__preview iframe,
      .viewer-card__preview object,
      .viewer-card__preview embed {
        width: 100%;
        height: min(70vh, 42rem);
        border: none;
        border-radius: var(--radius-md);
        background: white;
        box-shadow: var(--shadow-sm);
      }

      .viewer-card__pdf {
        position: relative;
        width: 100%;
        min-height: min(70vh, 42rem);
        border-radius: var(--radius-md);
        background: white;
        box-shadow: var(--shadow-sm);
        overflow: hidden;
        display: grid;
        place-items: center;
        padding: var(--space-md);
        color: var(--color-text-muted);
        font-size: 0.95rem;
        text-align: center;
      }

      .viewer-card__pdf[data-state="ready"] {
        padding: 0;
        color: inherit;
        display: block;
      }

      .viewer-card__pdf-message {
        margin: 0;
      }

      .viewer-card__docx {
        width: 100%;
        max-height: min(70vh, 42rem);
        overflow-y: auto;
        border-radius: var(--radius-md);
        background: white;
        box-shadow: var(--shadow-sm);
        padding: var(--space-md);
        color: #111;
        line-height: 1.65;
      }

      .viewer-card__docx * {
        color: inherit !important;
      }

      .viewer-card__docx[data-state="loading"] {
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        color: var(--color-text-muted);
      }

      .viewer-card__docx-message {
        margin: 0;
        font-size: 0.95rem;
      }

      .viewer-card__preview img {
        width: 100%;
        height: auto;
        border-radius: var(--radius-md);
        box-shadow: var(--shadow-sm);
      }

      .viewer-card__preview video,
      .viewer-card__preview audio {
        width: 100%;
        border-radius: var(--radius-md);
        box-shadow: var(--shadow-sm);
      }

      .viewer-card__preview pre {
        margin: 0;
        width: 100%;
        max-height: min(70vh, 42rem);
        overflow: auto;
        border-radius: var(--radius-md);
        padding: var(--space-md);
        background: color-mix(in srgb, var(--color-surface) 85%, transparent 15%);
        text-align: left;
        font-family: var(--font-mono);
        font-size: 0.9rem;
        line-height: 1.5;
        white-space: pre-wrap;
      }

      .viewer-card__loading {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--space-sm);
        color: var(--color-text-muted);
        font-size: 0.95rem;
      }

      .viewer-card__loading::before {
        content: "";
        width: 1.25rem;
        height: 1.25rem;
        border-radius: 50%;
        border: 2px solid color-mix(in srgb, var(--color-accent) 60%, transparent 40%);
        border-top-color: var(--color-accent);
        animation: viewer-spin 1s linear infinite;
      }

      @keyframes viewer-spin {
        to {
          transform: rotate(360deg);
        }
      }

      .viewer-card__fallback {
        display: grid;
        gap: var(--space-xs);
        text-align: center;
      }

      .viewer-card__meta {
        display: grid;
        gap: var(--space-lg);
      }

      .viewer-card__details {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(14rem, 1fr));
        gap: var(--space-sm);
        margin: 0;
      }

      .viewer-card__details div {
        background: color-mix(in srgb, var(--color-surface) 85%, transparent 15%);
        padding: var(--space-sm);
        border-radius: var(--radius-md);
        border: 1px solid color-mix(in srgb, var(--color-border) 75%, transparent 25%);
      }

      .viewer-card__details dt {
        margin: 0;
        font-size: 0.75rem;
        text-transform: uppercase;
        color: var(--color-text-muted);
        letter-spacing: 0.06em;
      }

      .viewer-card__details dd {
        margin: var(--space-2xs) 0 0;
        font-weight: 600;
      }

      .viewer-card__description {
        margin: 0;
        font-size: 0.9rem;
        color: var(--color-text-muted);
      }

      .viewer-card__link {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-sm);
        align-items: center;
      }

      .viewer-card__link-input {
        flex: 1 1 16rem;
        min-width: 0;
      }

      .viewer-card__empty {
        display: grid;
        gap: var(--space-sm);
      }

      footer {
        text-align: center;
        padding-bottom: var(--space-xl);
        color: color-mix(in srgb, var(--color-text) 70%, white 30%);
        font-size: 0.85rem;
      }
    </style>
    <script src="https://documentcloud.adobe.com/view-sdk/main.js" defer></script>
  </head>
  <body class="theme theme--immersive">
    <main class="portal" id="support-portal">
      <header class="portal__header">
        <p class="u-copy" role="status" aria-live="polite">         
        </p>
        <h1 class="portal__heading">Invisible Support Upload Hub</h1>
        <p class="portal__lede">
        </p>
        <section
          class="storage-meter"
          role="region"
          aria-live="polite"
          aria-label="Storage usage"
          data-storage-meter
        >
          <div class="storage-meter__heading">
            <span data-i18n-key="labels.storageUsed"></span>
            <span data-storage-limit></span>
          </div>
          <div class="storage-meter__values">
            <span data-storage-summary></span>
            <button
              class="u-btn u-btn--ghost storage-meter__button"
              type="button"
              data-storage-manage
              data-i18n-key="labels.storageManageCta"
            ></button>
          </div>
          <div class="storage-meter__progress" role="progressbar" aria-valuemin="0" aria-valuemax="100" data-storage-progress>
            <span class="storage-meter__progress-bar" data-storage-progress-bar></span>
          </div>
          <p class="storage-meter__warning" data-storage-warning hidden></p>
        </section>
      </header>

      <div class="portal__grid">
        <!-- Primary column: Upload workflow -->
        <section class="portal__column portal__column--primary">
          <article class="u-card upload-card" aria-labelledby="upload-workflow">
            <div class="u-card__header">
              <h2 class="u-card__title" id="upload-workflow">Upload workflow</h2>
              <p class="u-card__subtitle">
                Centralize artifacts by dragging, dropping, or linking your diagnostic assets.
              </p>
            </div>

            <form class="stack stack--lg" id="document-upload-form" aria-label="Document upload" novalidate>
              <div
                class="upload-card__dropzone"
                role="region"
                aria-label="Upload dropzone"
                data-dropzone
              >
                <svg viewBox="0 0 24 24" aria-hidden="true" role="presentation">
                  <path
                    fill="currentColor"
                    d="M12 3a1 1 0 0 1 1 1v8.586l2.293-2.293a1 1 0 0 1 1.414 1.414l-4 4a1 1 0 0 1-1.414 0l-4-4a1 1 0 1 1 1.414-1.414L11 12.586V4a1 1 0 0 1 1-1Zm-7 9a1 1 0 0 1 1 1v4a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-4a1 1 0 1 1 2 0v4a4 4 0 0 1-4 4H8a4 4 0 0 1-4-4v-4a1 1 0 0 1 1-1Z"
                  />
                </svg>
                <div class="stack">
                  <p class="portal__lede" style="font-size: 1rem;">
                    Drop files here or browse to upload.
                  </p>
                  <div class="upload-card__actions">
                    <label class="u-btn u-btn--primary" for="primary-upload">Browse files</label>
                    <span aria-hidden="true">or</span>
                    <span class="u-card__subtitle">Paste from clipboard (⌘/Ctrl + V)</span>
                  </div>
                  <p class="upload-card__accepted">PDF, DOCX, PPTX, XLSX, images, CSV, and more.</p>
                </div>
                <input
                  class="u-input"
                  type="file"
                  id="primary-upload"
                  name="documents"
                  multiple
                  accept=".pdf,.doc,.docx,.ppt,.pptx,.xls,.xlsx,.csv,.txt,.rtf,.png,.jpg,.jpeg,.gif,.webp,.heic,.mp4,.mov,.json,.log,.zip"
                  aria-label="Upload files"
                  data-file-input
                />
              </div>

              <section
                class="upload-card__queue stack"
                data-upload-queue
                hidden
                aria-live="polite"
              >
                <div class="upload-card__queue-header">
                  <span class="u-card__subtitle" data-i18n-key="upload.queueTitle"></span>
                  <button
                    class="u-btn u-btn--ghost u-btn--sm"
                    type="button"
                    data-queue-clear
                    data-i18n-key="upload.queueClear"
                  ></button>
                </div>
                <p class="upload-card__queue-summary" data-queue-summary hidden></p>
                <p class="upload-card__queue-empty" data-queue-empty data-i18n-key="upload.queueEmpty"></p>
                <ul class="upload-card__queue-list" data-queue-list></ul>
              </section>

              <div class="form-grid form-grid--split">
                <label class="stack" for="document-title">
                  <span class="u-card__subtitle">Title <span aria-hidden="true">(optional)</span></span>
                  <input
                    class="u-input"
                    type="text"
                    id="document-title"
                    name="title"
                    placeholder="e.g. Database latency analysis"
                    data-title-input
                  />
                </label>
                <label class="stack" for="document-description">
                  <span class="u-card__subtitle">Description <span aria-hidden="true">(optional)</span></span>
                  <input
                    class="u-input"
                    type="text"
                    id="document-description"
                    name="description"
                    placeholder="Short note about the document"
                    data-description-input
                  />
                </label>
              </div>

              <div class="stack">
                <span class="u-card__subtitle">Upload progress</span>
                <div class="upload-progress" data-upload-progress hidden>
                  <div class="upload-progress__bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                    <span class="upload-progress__fill" data-progress-fill></span>
                  </div>
                  <p class="upload-progress__label" data-progress-label>Waiting for files…</p>
                </div>
              </div>

              <p class="upload-feedback" data-upload-feedback role="alert" hidden></p>

              <div class="upload-card__actions" style="justify-content: flex-start;">
                <button class="u-btn u-btn--primary" type="submit">Upload documents</button>
                <button class="u-btn u-btn--ghost" type="reset">Reset</button>
              </div>
            </form>
          </article>
        </section>

        <!-- Secondary column: Library and viewer panels -->
        <section class="portal__column portal__column--secondary">
          <article class="u-card" aria-labelledby="repo-storage">
            <div class="u-card__header">
              <h2 class="u-card__title" id="repo-storage">Repository storage</h2>
              <p class="u-card__subtitle">
                Configure GitHub integration so uploads persist to this repository.
              </p>
            </div>

            <form class="stack stack--lg" data-github-settings novalidate>
              <div class="form-grid form-grid--split">
                <label class="stack" for="github-owner">
                  <span class="u-card__subtitle" data-i18n-key="labels.githubOwner"></span>
                  <input class="u-input" type="text" id="github-owner" name="github-owner" autocomplete="off" data-github-owner />
                </label>
                <label class="stack" for="github-repo">
                  <span class="u-card__subtitle" data-i18n-key="labels.githubRepo"></span>
                  <input class="u-input" type="text" id="github-repo" name="github-repo" autocomplete="off" data-github-repo />
                </label>
              </div>

              <div class="form-grid form-grid--split">
                <label class="stack" for="github-branch">
                  <span class="u-card__subtitle" data-i18n-key="labels.githubBranch"></span>
                  <input class="u-input" type="text" id="github-branch" name="github-branch" autocomplete="off" placeholder="main" data-github-branch />
                </label>
                <label class="stack" for="github-limit">
                  <span class="u-card__subtitle" data-i18n-key="labels.githubStorageLimit"></span>
                  <input class="u-input" type="number" min="1" step="1" id="github-limit" name="github-limit" data-github-limit />
                </label>
              </div>

              <label class="stack" for="github-token">
                <span class="u-card__subtitle" data-i18n-key="labels.githubToken"></span>
                <input class="u-input" type="password" id="github-token" name="github-token" autocomplete="off" data-github-token />
              </label>

              <p class="upload-feedback" data-github-feedback hidden></p>

              <div class="upload-card__actions" style="justify-content: flex-start;">
                <button class="u-btn u-btn--primary" type="submit" data-i18n-key="common.save"></button>
                <button class="u-btn u-btn--ghost" type="button" data-github-test>Test connection</button>
              </div>
            </form>
          </article>
          <article class="u-card library-card" aria-labelledby="asset-library">
            <div class="u-card__header">
              <h2 class="u-card__title" id="asset-library">Asset library</h2>
              <p class="u-card__subtitle">
                Reference previously uploaded artifacts to accelerate triage.
              </p>
            </div>

            <div class="stack" role="region" aria-live="polite">
              <label class="stack" for="library-search">
                <span class="u-card__subtitle">Filter library</span>
                <input
                  class="u-input"
                  type="search"
                  id="library-search"
                  placeholder="Search by title, file name, or type"
                  autocomplete="off"
                  data-library-search
                />
              </label>

              <div class="library-card__table" role="region" aria-label="Document library table">
                <table class="library-table">
                  <thead>
                    <tr>
                      <th scope="col">Title</th>
                      <th scope="col">Type</th>
                      <th scope="col">Size</th>
                      <th scope="col">Last updated</th>
                      <th scope="col" class="library-table__actions-heading">Actions</th>
                    </tr>
                  </thead>
                  <tbody data-library-rows></tbody>
                </table>
                <p class="library-card__empty" data-library-empty hidden>No documents uploaded yet.</p>
              </div>
            </div>
          </article>
          <article class="u-card viewer-card" aria-labelledby="document-viewer">
              <div class="u-card__header">
                <h2 class="u-card__title" id="document-viewer">Document viewer</h2>
                <p class="u-card__subtitle">Preview uploaded documents inline or switch to immersive mode.</p>
              </div>

            <div class="viewer-card__toolbar" role="group" aria-label="Document viewer controls">
              <label class="viewer-card__selector">
                <span class="visually-hidden">Select a document to preview</span>
                <select class="u-input viewer-card__select" data-viewer-select aria-label="Select document">
                  <option value="" selected>Select a document…</option>
                </select>
              </label>
              <label class="viewer-card__resize" for="document-viewer-width">
                <span>Viewer width</span>
                <input
                  id="document-viewer-width"
                  type="range"
                  min="25"
                  max="100"
                  step="5"
                  value="40"
                  aria-valuemin="25"
                  aria-valuemax="100"
                  aria-valuenow="40"
                  aria-label="Document viewer width"
                  data-viewer-resize
                />
                <span class="viewer-card__resize-value" data-viewer-resize-value>40%</span>
              </label>
            </div>

            <div class="viewer-card__preview" data-viewer-preview>
              <div class="viewer-card__empty" data-viewer-empty>
                <h3>Nothing selected yet</h3>
                <p class="portal__lede" style="font-size: 0.95rem;">
                  Choose an item from the library to load a preview, transcript, or streaming session.
                </p>
              </div>
            </div>

            <div class="viewer-card__meta" data-viewer-meta hidden>
              <div class="stack">
                <span class="u-card__subtitle">Document details</span>
                <dl class="viewer-card__details">
                  <div>
                    <dt>Title</dt>
                    <dd data-viewer-name>—</dd>
                  </div>
                  <div>
                    <dt>File name</dt>
                    <dd data-viewer-filename>—</dd>
                  </div>
                  <div>
                    <dt>Type</dt>
                    <dd data-viewer-type>—</dd>
                  </div>
                  <div>
                    <dt>Size</dt>
                    <dd data-viewer-size>—</dd>
                  </div>
                  <div>
                    <dt>Last updated</dt>
                    <dd data-viewer-updated>—</dd>
                  </div>
                </dl>
                <p class="viewer-card__description" data-viewer-description hidden></p>
              </div>

              <div class="stack">
                <span class="u-card__subtitle">Shareable link</span>
                <div class="viewer-card__link">
                  <input
                    class="u-input viewer-card__link-input"
                    type="text"
                    readonly
                    id="viewer-direct-link"
                    data-viewer-link
                    value=""
                  />
                  <button class="u-btn u-btn--ghost" type="button" data-viewer-copy>Copy</button>
                  <a class="u-btn u-btn--primary" href="#" target="_blank" rel="noopener" data-viewer-open>
                    Open in new tab
                  </a>
                </div>
              </div>
            </div>
          </article>
        </section>
      </div>

      <section class="image-portal" aria-labelledby="image-management">
        <div class="image-portal__header">
          <h2 class="portal__heading" id="image-management">Image management</h2>
          <p class="portal__lede">        
          </p>
        </div>

        <div class="image-portal__grid">
          <div class="image-portal__column">
            <article class="u-card image-upload-card" aria-labelledby="image-upload-title">
              <div class="u-card__header">
                <h2 class="u-card__title" id="image-upload-title">Image upload</h2>
                <p class="u-card__subtitle">
                  
                </p>
              </div>

              <form class="stack stack--lg" data-image-form novalidate>
                <div class="stack">
                  <div class="upload-card__dropzone" role="region" aria-label="Image upload dropzone" data-image-dropzone>
                    <svg viewBox="0 0 48 48" role="presentation" aria-hidden="true">
                      <path
                        fill="currentColor"
                        d="M24 6a12 12 0 0 0-12 12v3H8a6 6 0 0 0 0 12h32a6 6 0 0 0 1-11.9V18A12 12 0 0 0 24 6Zm0 4a8 8 0 0 1 8 8v3h-4.5a1.5 1.5 0 0 0-1.07.44L24 23.86l-2.43-2.42A1.5 1.5 0 0 0 20.5 21H16v-3a8 8 0 0 1 8-8Zm-2 11.62 1.43 1.43a1.5 1.5 0 0 0 2.12 0L27 21.05l3.45 3.45a1.5 1.5 0 0 0 1.06.44H36a2 2 0 0 1 0 4H12a2 2 0 1 1 0-4h4.5l4.5-4.38Z"
                      />
                    </svg>
                    <p class="portal__lede">
                      Drag and drop visual assets or browse your workstation. Files are inspected before upload.
                    </p>
                    <div class="upload-card__actions">
                      <label class="u-btn u-btn--primary" for="image-upload-input">Browse images</label>
                      <span aria-hidden="true">or</span>
                      <span class="u-card__subtitle">Drop anywhere to upload</span>
                    </div>
                    <p class="upload-card__accepted">
                      JPEG, PNG, WebP, AVIF, GIF, and HEIC · Max dimension 8,192&nbsp;px on either side.
                    </p>
                  </div>
                  <input
                    class="u-input"
                    type="file"
                    id="image-upload-input"
                    name="images"
                    accept="image/*"
                    multiple
                    data-image-file-input
                  />
                </div>

                <div class="form-grid form-grid--split">
                  <label class="stack" for="image-title">
                    <span class="u-card__subtitle">Title <span aria-hidden="true">(optional)</span></span>
                    <input
                      class="u-input"
                      type="text"
                      id="image-title"
                      placeholder="e.g. PagerDuty status overview"
                      data-image-title
                    />
                  </label>
                  <label class="stack" for="image-alt">
                    <span class="u-card__subtitle">Alt text <span aria-hidden="true">(optional)</span></span>
                    <input
                      class="u-input"
                      type="text"
                      id="image-alt"
                      placeholder="Accessible description for screen readers"
                      data-image-alt
                    />
                  </label>
                </div>

                <div class="stack">
                  <span class="u-card__subtitle">Upload progress</span>
                  <div class="upload-progress" data-image-progress hidden>
                    <div
                      class="upload-progress__bar"
                      role="progressbar"
                      aria-valuemin="0"
                      aria-valuemax="100"
                      aria-valuenow="0"
                      data-image-progress-bar
                    >
                      <span class="upload-progress__fill" data-image-progress-fill></span>
                    </div>
                    <p class="upload-progress__label" data-image-progress-label>Waiting for images…</p>
                  </div>
                </div>

                <p class="upload-feedback" data-image-feedback role="alert" hidden></p>

                <div class="upload-card__actions" style="justify-content: flex-start;">
                  <button class="u-btn u-btn--primary" type="submit">Upload images</button>
                  <button class="u-btn u-btn--ghost" type="reset">Reset</button>
                </div>
              </form>
            </article>

            <article class="u-card image-gallery-card" aria-labelledby="image-gallery">
              <div class="u-card__header">
                <h2 class="u-card__title" id="image-gallery">Image gallery</h2>
                <p class="u-card__subtitle">Switch between grid and list layouts while thumbnails lazy-load in view.</p>
              </div>

              <div class="stack">
                <div class="image-gallery__toolbar">
                  <label class="stack image-gallery__search" for="image-gallery-search">
                    <span class="u-card__subtitle">Filter images</span>
                    <input
                      class="u-input"
                      type="search"
                      id="image-gallery-search"
                      placeholder="Search by title, file name, or EXIF metadata"
                      autocomplete="off"
                      data-image-search
                    />
                  </label>
                  <div class="image-gallery__views" role="group" aria-label="Select gallery view">
                    <button class="image-gallery__view is-active" type="button" data-image-view="grid">Grid</button>
                    <button class="image-gallery__view" type="button" data-image-view="list">List</button>
                  </div>
                </div>

                <ul class="image-gallery__items image-gallery__items--grid" data-image-gallery-items aria-live="polite"></ul>
                <p class="image-gallery__empty" data-image-gallery-empty hidden>No images uploaded yet.</p>
              </div>
            </article>
          </div>

          <div class="image-portal__column">
            <article class="u-card image-viewer-card" aria-labelledby="image-viewer">
              <div class="u-card__header">
                <h2 class="u-card__title" id="image-viewer">Image viewer</h2>
                <p class="u-card__subtitle"></p>
              </div>

              <div class="image-viewer__toolbar" role="group" aria-label="Image viewer controls">
                <label class="image-viewer__resize" for="image-viewer-width">
                  <span>Viewer width</span>
                  <input
                    id="image-viewer-width"
                    type="range"
                    min="25"
                    max="100"
                    step="5"
                    value="40"
                    aria-valuemin="25"
                    aria-valuemax="100"
                    aria-valuenow="40"
                    aria-label="Image viewer width"
                    data-image-resize
                  />
                  <span class="image-viewer__resize-value" data-image-resize-value>40%</span>
                </label>
              </div>

              <div class="stack" data-image-viewer>
                <div class="image-viewer__canvas" data-image-canvas data-fit="contain">
                  <div class="image-viewer__empty" data-image-empty>
                    <h3>Waiting for a selection</h3>
                    <p class="portal__lede" style="font-size: 0.95rem;">
                      Choose a thumbnail to open a rich preview with zoom controls and EXIF-aware metadata.
                    </p>
                  </div>
                  <img data-image-preview alt="" hidden />
                </div>

                <div class="image-viewer__controls" data-image-controls hidden>
                  <div class="image-viewer__control-group" role="group" aria-label="Fit controls">
                    <button class="image-viewer__control is-active" type="button" data-image-fit="contain">Fit</button>
                    <button class="image-viewer__control" type="button" data-image-fit="cover">Fill</button>
                    <button class="image-viewer__control" type="button" data-image-fit="actual">Actual</button>
                  </div>
                  <label class="stack" style="gap: var(--space-2xs); min-width: 10rem;">
                    <span class="u-card__subtitle">Zoom</span>
                    <input
                      class="image-viewer__slider"
                      type="range"
                      min="25"
                      max="200"
                      step="5"
                      value="100"
                      data-image-zoom
                    />
                  </label>
                </div>

                <div class="image-viewer__meta" data-image-meta hidden>
                  <dl class="image-viewer__details">
                    <div>
                      <dt>Title</dt>
                      <dd data-image-name>—</dd>
                    </div>
                    <div>
                      <dt>File name</dt>
                      <dd data-image-filename>—</dd>
                    </div>
                    <div>
                      <dt>Dimensions</dt>
                      <dd data-image-dimensions>—</dd>
                    </div>
                    <div>
                      <dt>Size</dt>
                      <dd data-image-size>—</dd>
                    </div>
                    <div>
                      <dt>Type</dt>
                      <dd data-image-type>—</dd>
                    </div>
                    <div>
                      <dt>Alt text</dt>
                      <dd data-image-alt>—</dd>
                    </div>
                    <div>
                      <dt>Captured</dt>
                      <dd data-image-taken>—</dd>
                    </div>
                  </dl>

                  <div class="image-viewer__exif" data-image-exif hidden>
                    <h3>EXIF metadata</h3>
                    <div class="image-viewer__exif-list" data-image-exif-list></div>
                  </div>

                  <div class="stack">
                    <span class="u-card__subtitle">Direct link</span>
                    <div class="viewer-card__link">
                      <input
                        class="u-input viewer-card__link-input"
                        type="text"
                        readonly
                        id="image-direct-link"
                        data-image-link
                        value=""
                      />
                      <button class="u-btn u-btn--ghost" type="button" data-copy-target="#image-direct-link">Copy</button>
                      <a class="u-btn u-btn--primary" href="#" target="_blank" rel="noopener" data-image-open aria-disabled="true">
                        Open in new tab
                      </a>
                    </div>
                  </div>
                </div>
              </div>
            </article>
          </div>
        </div>
      </section>
    </main>

    <div class="toast-stack" role="status" aria-live="polite" aria-atomic="false" data-toast-stack></div>

    <div class="u-modal" id="clipboard-confirm" role="dialog" aria-modal="true" aria-labelledby="clipboard-title">
      <div class="u-modal__dialog">
        <div class="stack">
          <h2 class="u-card__title" id="clipboard-title">Copied to clipboard</h2>
          <p class="u-card__subtitle" id="clipboard-description">
            The requested value is available for sharing. Paste it into any chat or ticket.
          </p>
          <button class="u-btn u-btn--primary" type="button" data-close-modal>Continue</button>
        </div>
      </div>
    </div>

    <div class="u-modal" id="storage-modal" role="dialog" aria-modal="true" aria-labelledby="storage-title" aria-describedby="storage-description">
      <div class="u-modal__dialog">
        <div class="stack">
          <h2 class="u-card__title" id="storage-title" data-i18n-key="labels.storageDialogTitle"></h2>
          <p class="u-card__subtitle" id="storage-description" data-i18n-key="labels.storageDialogDescription"></p>
          <div class="storage-modal__summary" data-storage-summary>
            <dl class="storage-summary">
              <div class="storage-summary__row">
                <dt class="storage-summary__label" data-i18n-key="labels.storageUsed"></dt>
                <dd class="storage-summary__value" data-storage-used>—</dd>
              </div>
              <div class="storage-summary__row">
                <dt class="storage-summary__label" data-i18n-key="labels.storageAvailable"></dt>
                <dd class="storage-summary__value" data-storage-available>—</dd>
              </div>
            </dl>
            <ul class="storage-breakdown">
              <li class="storage-breakdown__item">
                <span class="storage-breakdown__label" data-i18n-key="labels.storageDocuments"></span>
                <span class="storage-breakdown__value" data-storage-documents>—</span>
              </li>
              <li class="storage-breakdown__item">
                <span class="storage-breakdown__label" data-i18n-key="labels.storageImages"></span>
                <span class="storage-breakdown__value" data-storage-images>—</span>
              </li>
            </ul>
          </div>
          <div class="upload-card__actions" style="justify-content: flex-end;">
            <button class="u-btn u-btn--primary" type="button" data-storage-clear data-i18n-key="labels.storageClearCta"></button>
            <button class="u-btn u-btn--ghost" type="button" data-storage-cancel data-i18n-key="labels.storageCancelCta"></button>
          </div>
        </div>
      </div>
    </div>

    <footer>
      Invisible Support · Seamless context hand-offs for modern ops teams
    </footer>

    <script>
      const Localization = (() => {
        const defaultLocale = document.documentElement.lang || "en";
        const fallbackLocale = "en";
        const locales = {
          en: {
            common: {
              copySuccess: "Link copied to clipboard.",
              copyFailure: "Copy failed. Please copy manually.",
              dismiss: "Dismiss notification",
              remove: "Remove",
              manageStorage: "Manage storage",
              usageSummary: "{used} of {limit}",
              storageWarning: "Storage is almost full ({percent}% used).",
              unknownFile: "File",
              save: "Save",
            },
            notifications: {
              documentRemoved: "Document removed from library.",
              imageRemoved: "Image removed from gallery.",
              imageUploadSuccess: "Images uploaded successfully.",
              imageUploadSelectPrompt: "Select at least one image to upload.",
              documentUploadSuccess: "Documents uploaded successfully.",
              documentUploadSelectPrompt: "Select at least one document to upload.",
              storageQuotaExceeded: "Storage quota exceeded. Remove items or clear space to continue.",
              duplicateName: "An item with this name already exists. Renamed automatically.",
              largeFileWarning: "File is large and may exceed available space.",
              storageCleared: "Stored items cleared successfully.",
              githubConfigSaved: "Repository settings saved.",
              githubTestSuccess: "Connection to GitHub succeeded.",
              githubTestFailure: "GitHub connection failed. Check credentials and permissions.",
            },
              errors: {
              quotaExceeded: "Unable to save changes because storage is full.",
              persistFailure: "Unable to persist items. Try clearing storage and retrying.",
              invalidDocument: "Invalid document file.",
              invalidImage: "Invalid image file.",
              unsupportedImageType: "Unsupported image type.",
              imageDimensions: "Unable to read image dimensions.",
              imageTooLarge: "Image exceeds maximum supported dimensions.",
              githubConfigMissing: "Configure the GitHub repository settings before uploading.",
              githubRequestFailed: "GitHub request failed. Review the setup instructions and try again.",
              githubValidation: "Enter the repository owner and name before saving.",
            },
            labels: {
              storageUsed: "Storage used",
              storageLimit: "Storage limit",
              storageAvailable: "Available space",
              storageDocuments: "Documents",
              storageImages: "Images",
              storageDocumentSingular: "Document",
              storageImageSingular: "Image",
              storageLimitUnset: "Limit not configured",
              storageDialogTitle: "Storage management",
              storageDialogDescription:
                "Local storage is near capacity. Clear older items or export data to continue uploading.",
              storageClearCta: "Clear all stored items",
              storageCancelCta: "Keep items",
              storageManageCta: "Manage stored data",
              storageWarningCta: "Review storage",
              githubOwner: "Repository owner",
              githubRepo: "Repository name",
              githubBranch: "Branch",
              githubToken: "Personal access token",
              githubStorageLimit: "Storage budget (MB)",
            },
            upload: {
              waitingImages: "Waiting for images…",
              waitingDocuments: "Waiting for files…",
              validating: "{name} • validating",
              progress: "{name} • {percent}%",
              summaryImagesSingle: "{name} uploaded",
              summaryImagesMultiple: "{count} images uploaded",
              summaryDocumentsSingle: "{name} uploaded",
              summaryDocumentsMultiple: "{count} documents uploaded",
              completeImages: "Upload complete. Images are ready in the gallery.",
              completeDocuments: "Upload complete. Documents are ready in the library.",
              queueTitle: "Selected files",
              queueEmpty: "No files selected yet.",
              queueClear: "Clear selection",
              queueSummarySingle: "\"{name}\" ready to upload ({size})",
              queueSummaryMultiple: "{count} files ready to upload ({size})",
              errorSelectImages: "Select at least one image to upload.",
              errorSelectDocuments: "Select at least one document to upload.",
              errorUnsupportedImage: "{name} is not a supported image type.",
              errorImageTooLarge: "{name} exceeds the {limit}px dimension limit.",
              errorImageDimensions: "Unable to read dimensions for {name}.",
              errorUploadFailed: "Upload failed for {name}.",
              errorMissingConfiguration: "Configure repository settings before uploading.",
            },
            gallery: {
              selectImage: "Select {name}",
            },
          },
        };

        let activeLocale = locales[defaultLocale] ? defaultLocale : fallbackLocale;

        function getString(key) {
          const segments = key.split(".");
          let current = locales[activeLocale] || locales[fallbackLocale];
          for (const segment of segments) {
            if (current && typeof current === "object" && segment in current) {
              current = current[segment];
            } else {
              return key;
            }
          }
          return typeof current === "string" ? current : key;
        }

        function format(template, replacements = {}) {
          return template.replace(/\{(.*?)\}/g, (_, token) => {
            const value = replacements[token.trim()];
            return value ?? "";
          });
        }

        function t(key, replacements) {
          const template = getString(key);
          return typeof template === "string" ? format(template, replacements) : key;
        }

        function apply(root = document) {
          root
            .querySelectorAll?.("[data-i18n-key]")
            .forEach((node) => {
              const key = node.getAttribute("data-i18n-key");
              if (!key) return;
              const text = t(key);
              if (node instanceof HTMLInputElement || node instanceof HTMLTextAreaElement) {
                node.placeholder = text;
              } else {
                node.textContent = text;
              }
            });
        }

        function setLocale(locale) {
          if (!locales[locale]) return;
          activeLocale = locale;
          apply();
        }

        function getLocale() {
          return activeLocale;
        }

        return { t, apply, setLocale, getLocale };
      })();

      Localization.apply();

      const GitHubIntegration = (() => {
        const CONFIG_KEY = "invisibleSupport.githubConfig";

        function inferRepositoryDefaults() {
          try {
            const { hostname, pathname } = window.location || {};
            if (!hostname || !hostname.endsWith("github.io")) {
              return { owner: "", repo: "" };
            }
            const parts = hostname.split(".");
            if (parts.length < 3) {
              return { owner: "", repo: "" };
            }
            const owner = parts[0];
            const cleanPath = (pathname || "").replace(/^\/+|\/+$|\s+/g, "");
            if (!cleanPath) {
              return { owner, repo: `${owner}.github.io` };
            }
            const [repo] = cleanPath.split("/");
            return { owner, repo: repo || "" };
          } catch (error) {
            console.warn("Failed to infer GitHub repository from location", error);
            return { owner: "", repo: "" };
          }
        }

        const inferred = inferRepositoryDefaults();
        const DEFAULT_CONFIG = {
          owner: inferred.owner,
          repo: inferred.repo,
          branch: "main",
          token: "",
          storageLimitMb: 200,
        };
        const configListeners = new Set();
        const textEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder() : null;
        const textDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder() : null;

        function sanitizeConfig(raw) {
          if (!raw || typeof raw !== "object") {
            return { ...DEFAULT_CONFIG };
          }
          const limit = Number(raw.storageLimitMb);
          const owner = typeof raw.owner === "string" ? raw.owner.trim() : "";
          const repo = typeof raw.repo === "string" ? raw.repo.trim() : "";
          const branch =
            typeof raw.branch === "string" && raw.branch.trim() ? raw.branch.trim() : DEFAULT_CONFIG.branch;
          return {
            owner: owner || DEFAULT_CONFIG.owner,
            repo: repo || DEFAULT_CONFIG.repo,
            branch,
            token: typeof raw.token === "string" ? raw.token.trim() : "",
            storageLimitMb: Number.isFinite(limit) && limit > 0 ? limit : DEFAULT_CONFIG.storageLimitMb,
          };
        }

        function loadConfig() {
          try {
            const stored = localStorage.getItem(CONFIG_KEY);
            if (!stored) return { ...DEFAULT_CONFIG };
            const parsed = JSON.parse(stored);
            return sanitizeConfig(parsed);
          } catch (error) {
            console.warn("Failed to read GitHub configuration", error);
            return { ...DEFAULT_CONFIG };
          }
        }

        let config = loadConfig();

        function notifyConfig() {
          const snapshot = getConfig();
          configListeners.forEach((listener) => {
            try {
              listener(snapshot);
            } catch (error) {
              console.warn("GitHub config listener error", error);
            }
          });
        }

        function persistConfig(next) {
          config = sanitizeConfig({ ...config, ...next });
          try {
            localStorage.setItem(CONFIG_KEY, JSON.stringify(config));
          } catch (error) {
            console.warn("Unable to persist GitHub configuration", error);
          }
          notifyConfig();
        }

        function getConfig() {
          return { ...config };
        }

        function subscribe(listener) {
          if (typeof listener !== "function") return () => {};
          configListeners.add(listener);
          listener(getConfig());
          return () => configListeners.delete(listener);
        }

        function updateConfig(partial = {}) {
          persistConfig(partial);
        }

        function isConfigured() {
          return Boolean(config.owner && config.repo && config.token);
        }

        function ensureConfigured() {
          if (isConfigured()) return;
          const error = new Error(Localization.t("errors.githubConfigMissing"));
          error.code = "config";
          throw error;
        }

        function getBranch() {
          return config.branch && config.branch.trim() ? config.branch.trim() : DEFAULT_CONFIG.branch;
        }

        function buildApiBase() {
          return `https://api.github.com/repos/${config.owner}/${config.repo}`;
        }

        function buildApiUrl(path = "") {
          const base = buildApiBase();
          return path ? `${base}/${path}` : base;
        }

        function buildHeaders(extra) {
          const headers = { Accept: "application/vnd.github+json" };
          if (config.token) {
            headers.Authorization = `Bearer ${config.token}`;
          }
          if (extra) {
            Object.assign(headers, extra);
          }
          return headers;
        }

        function encodePath(path) {
          return path
            .split("/")
            .filter(Boolean)
            .map((segment) => encodeURIComponent(segment))
            .join("/");
        }

        function encodeBase64(value) {
          if (!value) return "";
          if (textEncoder) {
            const bytes = textEncoder.encode(value);
            let binary = "";
            bytes.forEach((byte) => {
              binary += String.fromCharCode(byte);
            });
            return btoa(binary);
          }
          return btoa(unescape(encodeURIComponent(value)));
        }

        function decodeBase64(value) {
          if (!value) return "";
          try {
            const binary = atob(value);
            if (textDecoder) {
              const bytes = Uint8Array.from(binary, (char) => char.charCodeAt(0));
              return textDecoder.decode(bytes);
            }
            return decodeURIComponent(escape(binary));
          } catch (error) {
            console.warn("Failed to decode base64 payload", error);
            return "";
          }
        }

        async function getContents(path) {
          ensureConfigured();
          const encodedPath = encodePath(path);
          const branch = encodeURIComponent(getBranch());
          const url = `${buildApiUrl(`contents/${encodedPath}`)}?ref=${branch}`;
          const response = await fetch(url, { headers: buildHeaders() });
          if (response.status === 404) {
            return null;
          }
          if (!response.ok) {
            let payload = null;
            try {
              payload = await response.json();
            } catch (error) {
              payload = null;
            }
            const error = new Error(payload?.message || Localization.t("errors.githubRequestFailed"));
            error.code = "request";
            error.status = response.status;
            error.payload = payload;
            throw error;
          }
          return response.json();
        }

        async function putContents(path, { message, content, sha } = {}) {
          ensureConfigured();
          const body = {
            message: message || `Update ${path}`,
            content,
            branch: getBranch(),
          };
          if (sha) {
            body.sha = sha;
          }
          const response = await fetch(buildApiUrl(`contents/${encodePath(path)}`), {
            method: "PUT",
            headers: buildHeaders({ "Content-Type": "application/json" }),
            body: JSON.stringify(body),
          });
          if (!response.ok) {
            let payload = null;
            try {
              payload = await response.json();
            } catch (error) {
              payload = null;
            }
            const error = new Error(payload?.message || Localization.t("errors.githubRequestFailed"));
            error.code = "request";
            error.status = response.status;
            error.payload = payload;
            throw error;
          }
          return response.json();
        }

        async function deleteContents(path, { message, sha } = {}) {
          ensureConfigured();
          const body = {
            message: message || `Remove ${path}`,
            sha,
            branch: getBranch(),
          };
          const response = await fetch(buildApiUrl(`contents/${encodePath(path)}`), {
            method: "DELETE",
            headers: buildHeaders({ "Content-Type": "application/json" }),
            body: JSON.stringify(body),
          });
          if (response.status === 404) {
            return null;
          }
          if (!response.ok) {
            let payload = null;
            try {
              payload = await response.json();
            } catch (error) {
              payload = null;
            }
            const error = new Error(payload?.message || Localization.t("errors.githubRequestFailed"));
            error.code = "request";
            error.status = response.status;
            error.payload = payload;
            throw error;
          }
          return response.json();
        }

        async function downloadFile(path) {
          ensureConfigured();
          const branch = encodeURIComponent(getBranch());
          const url = `${buildApiUrl(`contents/${encodePath(path)}`)}?ref=${branch}`;
          const response = await fetch(url, {
            headers: buildHeaders({ Accept: "application/vnd.github.v3.raw" }),
          });
          if (!response.ok) {
            let payload = null;
            try {
              payload = await response.json();
            } catch (error) {
              payload = null;
            }
            const error = new Error(payload?.message || Localization.t("errors.githubRequestFailed"));
            error.code = "request";
            error.status = response.status;
            error.payload = payload;
            throw error;
          }
          const contentType = response.headers.get("Content-Type") || "";
          const arrayBuffer = await response.arrayBuffer();
          return { arrayBuffer, contentType };
        }

        async function readManifest(path) {
          const file = await getContents(path);
          if (!file) {
            return { items: [], sha: null };
          }
          const text = decodeBase64(file.content || "");
          let data = [];
          if (text) {
            try {
              const parsed = JSON.parse(text);
              data = Array.isArray(parsed) ? parsed : [];
            } catch (error) {
              console.warn("Failed to parse manifest", error);
              data = [];
            }
          }
          return { items: data, sha: file.sha };
        }

        async function writeManifest(path, items, sha) {
          const payload = JSON.stringify(items ?? [], null, 2);
          const response = await putContents(path, {
            content: encodeBase64(payload),
            message: `Update ${path}`,
            sha,
          });
          return {
            sha: response?.content?.sha ?? response?.sha ?? null,
            path: response?.content?.path ?? path,
          };
        }

        async function deleteManifest(path, sha) {
          await deleteContents(path, { sha, message: `Remove ${path}` });
        }

        async function uploadFile(path, base64Content, message) {
          const response = await putContents(path, { content: base64Content, message });
          const content = response?.content ?? {};
          return {
            path: content.path ?? path,
            sha: content.sha ?? response?.sha ?? null,
            downloadUrl: content.download_url ?? buildRawUrl(content.path ?? path),
          };
        }

        async function deleteFile(path, sha, message) {
          await deleteContents(path, { sha, message });
        }

        async function testConnection() {
          ensureConfigured();
          const response = await fetch(buildApiUrl(), { headers: buildHeaders() });
          if (!response.ok) {
            let payload = null;
            try {
              payload = await response.json();
            } catch (error) {
              payload = null;
            }
            const error = new Error(payload?.message || Localization.t("errors.githubRequestFailed"));
            error.code = "request";
            error.status = response.status;
            throw error;
          }
          return true;
        }

        function getStorageLimitBytes() {
          const limitMb = Number(config.storageLimitMb);
          if (Number.isFinite(limitMb) && limitMb > 0) {
            return limitMb * 1024 * 1024;
          }
          return DEFAULT_CONFIG.storageLimitMb * 1024 * 1024;
        }

        function buildRawUrl(path) {
          if (!config.owner || !config.repo) return "";
          return `https://raw.githubusercontent.com/${config.owner}/${config.repo}/${getBranch()}/${path}`;
        }

        return {
          getConfig,
          updateConfig,
          subscribe,
          isConfigured,
          readManifest,
          writeManifest,
          deleteManifest,
          uploadFile,
          deleteFile,
          testConnection,
          getStorageLimitBytes,
          buildRawUrl,
          downloadFile,
        };
      })();

      const GitHubSettings = (() => {
        const form = document.querySelector("[data-github-settings]");
        if (!form) return null;
        const ownerInput = form.querySelector("[data-github-owner]");
        const repoInput = form.querySelector("[data-github-repo]");
        const branchInput = form.querySelector("[data-github-branch]");
        const tokenInput = form.querySelector("[data-github-token]");
        const limitInput = form.querySelector("[data-github-limit]");
        const feedback = form.querySelector("[data-github-feedback]");
        const testButton = form.querySelector("[data-github-test]");

        function clearFeedback() {
          if (feedback) {
            Notifications.inline(feedback, "");
          }
        }

        function showFeedback(message, tone = "info") {
          if (feedback && message) {
            Notifications.inline(feedback, message, tone);
          }
        }

        function populate(config) {
          if (!config) return;
          if (ownerInput && document.activeElement !== ownerInput) {
            ownerInput.value = config.owner || "";
          }
          if (repoInput && document.activeElement !== repoInput) {
            repoInput.value = config.repo || "";
          }
          if (branchInput && document.activeElement !== branchInput) {
            branchInput.value = config.branch || "";
          }
          if (limitInput && document.activeElement !== limitInput) {
            const limit = Number(config.storageLimitMb);
            limitInput.value = Number.isFinite(limit) && limit > 0 ? String(limit) : "";
          }
          if (tokenInput && document.activeElement !== tokenInput) {
            tokenInput.value = "";
          }
        }

        form.addEventListener("submit", (event) => {
          event.preventDefault();
          clearFeedback();
          const owner = ownerInput?.value.trim() ?? "";
          const repo = repoInput?.value.trim() ?? "";
          if (!owner || !repo) {
            showFeedback(Localization.t("errors.githubValidation"), "error");
            return;
          }
          const branch = branchInput?.value.trim() || "main";
          const limitValue = Number(limitInput?.value);
          const payload = {
            owner,
            repo,
            branch,
          };
          if (Number.isFinite(limitValue) && limitValue > 0) {
            payload.storageLimitMb = limitValue;
          }
          const token = tokenInput?.value.trim();
          if (token) {
            payload.token = token;
          }
          try {
            GitHubIntegration.updateConfig(payload);
            if (tokenInput) {
              tokenInput.value = "";
            }
            showFeedback(Localization.t("notifications.githubConfigSaved"), "success");
            Notifications.toast(Localization.t("notifications.githubConfigSaved"), "success");
          } catch (error) {
            console.error("Failed to save GitHub configuration", error);
            showFeedback(Localization.t("errors.githubRequestFailed"), "error");
          }
        });

        testButton?.addEventListener("click", async (event) => {
          event.preventDefault();
          clearFeedback();
          testButton.disabled = true;
          const originalText = testButton.textContent;
          try {
            await GitHubIntegration.testConnection();
            showFeedback(Localization.t("notifications.githubTestSuccess"), "success");
            Notifications.toast(Localization.t("notifications.githubTestSuccess"), "success");
          } catch (error) {
            console.error("GitHub connection test failed", error);
            const message = error?.code === "config"
              ? Localization.t("errors.githubConfigMissing")
              : Localization.t("notifications.githubTestFailure");
            showFeedback(message, "error");
            Notifications.toast(message, "error");
          } finally {
            testButton.disabled = false;
            if (typeof originalText === "string") {
              testButton.textContent = originalText;
            }
          }
        });

        GitHubIntegration.subscribe((config) => {
          populate(config);
        });

        populate(GitHubIntegration.getConfig());

        return null;
      })();

      const StorageManager = (() => {
        const WARNING_THRESHOLD = 0.8;
        const trackedSizes = new Map();
        const manifestMeta = new Map();
        const listeners = new Set();
        const KEY_PATH_MAP = new Map([
          ["invisibleSupport.documents", "storage/documents.json"],
          ["invisibleSupport.images", "storage/images.json"],
        ]);

        function calculateSize(value) {
          if (!Array.isArray(value)) return 0;
          return value.reduce((total, item) => total + (Number(item?.size) || 0), 0);
        }

        function resolvePath(key) {
          return KEY_PATH_MAP.get(key) ?? null;
        }

        function buildSnapshot(overrideKey, overrideSize) {
          let used = 0;
          trackedSizes.forEach((size, key) => {
            if (overrideKey && key === overrideKey && typeof overrideSize === "number") {
              used += overrideSize;
            } else {
              used += size;
            }
          });
          if (overrideKey && !trackedSizes.has(overrideKey) && typeof overrideSize === "number") {
            used += overrideSize;
          }
          const limit = GitHubIntegration.getStorageLimitBytes();
          const ratio = limit > 0 ? used / limit : 0;
          return {
            used,
            limit,
            ratio,
            isWarning: ratio >= WARNING_THRESHOLD && ratio < 1,
            isExceeded: ratio >= 1,
          };
        }

        function notify(snapshot = buildSnapshot()) {
          listeners.forEach((listener) => {
            try {
              listener({ ...snapshot });
            } catch (error) {
              console.warn("Storage listener error", error);
            }
          });
        }

        async function persist(key, value) {
          const path = resolvePath(key);
          if (!path) {
            console.warn(`No manifest path registered for key: ${key}`);
            return value;
          }
          const size = calculateSize(value);
          const snapshot = buildSnapshot(key, size);
          if (snapshot.isExceeded) {
            const error = new Error(Localization.t("errors.quotaExceeded"));
            error.code = "quota";
            error.snapshot = snapshot;
            throw error;
          }
          try {
            const meta = manifestMeta.get(key);
            const result = await GitHubIntegration.writeManifest(path, value, meta?.sha);
            manifestMeta.set(key, { sha: result.sha });
            trackedSizes.set(key, size);
            notify();
            return value;
          } catch (error) {
            if (error?.code === "config") {
              throw error;
            }
            const persistError = new Error(Localization.t("errors.persistFailure"));
            persistError.code = "persist";
            persistError.cause = error;
            throw persistError;
          }
        }

        async function read(key) {
          const path = resolvePath(key);
          if (!path) return null;
          try {
            const result = await GitHubIntegration.readManifest(path);
            manifestMeta.set(key, { sha: result.sha });
            const size = calculateSize(result.items);
            trackedSizes.set(key, size);
            notify();
            return result.items;
          } catch (error) {
            if (error?.code === "config") {
              trackedSizes.set(key, 0);
              notify();
              throw error;
            }
            console.error("Failed to read manifest", error);
            trackedSizes.set(key, 0);
            notify();
            return null;
          }
        }

        async function clear(key) {
          const path = resolvePath(key);
          if (!path) return;
          const meta = manifestMeta.get(key);
          try {
            await GitHubIntegration.deleteManifest(path, meta?.sha ?? null);
          } catch (error) {
            console.warn("Failed to remove manifest", error);
          }
          manifestMeta.delete(key);
          trackedSizes.set(key, 0);
          notify();
        }

        async function clearAll() {
          const tasks = Array.from(KEY_PATH_MAP.keys()).map((key) => clear(key));
          await Promise.all(tasks);
        }

        function subscribe(listener) {
          if (typeof listener !== "function") return () => {};
          listeners.add(listener);
          listener(buildSnapshot());
          return () => listeners.delete(listener);
        }

        function getSnapshot() {
          return buildSnapshot();
        }

        function estimateImpact(bytes) {
          if (!Number.isFinite(bytes) || bytes <= 0) return 0;
          return bytes;
        }

        function getRemainingCapacity() {
          const snapshot = buildSnapshot();
          return Math.max(snapshot.limit - snapshot.used, 0);
        }

        function canStore(additionalBytes) {
          if (!Number.isFinite(additionalBytes) || additionalBytes <= 0) return true;
          const snapshot = buildSnapshot();
          return snapshot.used + additionalBytes <= snapshot.limit;
        }

        GitHubIntegration.subscribe(() => {
          notify();
        });

        return {
          persist,
          read,
          clear,
          clearAll,
          subscribe,
          getSnapshot,
          estimateImpact,
          getRemainingCapacity,
          canStore,
        };
      })();

      const Utils = (() => {
        const relativeTimeFormatter = new Intl.RelativeTimeFormat(undefined, { numeric: "auto" });
        const bytesFormatter = new Intl.NumberFormat(undefined, { maximumFractionDigits: 1 });
        const dateTimeFormatter = new Intl.DateTimeFormat(undefined, {
          dateStyle: "medium",
          timeStyle: "short",
        });
        const blobRegistry = new Set();

        function formatBytes(bytes) {
          if (!Number.isFinite(bytes) || bytes < 0) return "—";
          if (bytes === 0) return "0 B";
          const units = ["B", "KB", "MB", "GB", "TB"];
          const exponent = Math.min(Math.floor(Math.log(bytes) / Math.log(1024)), units.length - 1);
          const value = bytes / 1024 ** exponent;
          return `${bytesFormatter.format(value)} ${units[exponent]}`;
        }

        function formatRelativeTime(isoString) {
          if (!isoString) return "—";
          const date = new Date(isoString);
          if (Number.isNaN(date.getTime())) return "—";
          const diffMs = date.getTime() - Date.now();
          const units = [
            { unit: "year", ms: 1000 * 60 * 60 * 24 * 365 },
            { unit: "month", ms: 1000 * 60 * 60 * 24 * 30 },
            { unit: "day", ms: 1000 * 60 * 60 * 24 },
            { unit: "hour", ms: 1000 * 60 * 60 },
            { unit: "minute", ms: 1000 * 60 },
            { unit: "second", ms: 1000 },
          ];
          for (const { unit, ms } of units) {
            if (Math.abs(diffMs) >= ms || unit === "second") {
              const value = Math.round(diffMs / ms);
              return relativeTimeFormatter.format(value, unit);
            }
          }
          return relativeTimeFormatter.format(0, "second");
        }

        function formatDateTime(isoString) {
          if (!isoString) return "—";
          const date = new Date(isoString);
          if (Number.isNaN(date.getTime())) return "—";
          return dateTimeFormatter.format(date);
        }

        function createObjectUrl(value) {
          if (!value) return "";
          try {
            const url = URL.createObjectURL(value);
            blobRegistry.add(url);
            return url;
          } catch (error) {
            console.warn("Failed to create object URL", error);
            return "";
          }
        }

        function revokeObjectUrl(url) {
          if (!url) return;
          blobRegistry.delete(url);
          try {
            URL.revokeObjectURL(url);
          } catch (error) {
            console.warn("Failed to revoke object URL", error);
          }
        }

        function revokeAllObjectUrls() {
          blobRegistry.forEach((url) => {
            try {
              URL.revokeObjectURL(url);
            } catch (error) {
              console.warn("Failed to revoke object URL", error);
            }
          });
          blobRegistry.clear();
        }

        function dataUrlToBlob(dataUrl, fallbackType = "application/octet-stream") {
          if (!dataUrl) {
            return { blob: new Blob([], { type: fallbackType }), type: fallbackType };
          }
          const [header, payload] = dataUrl.split(",");
          try {
            const match = header?.match(/data:(.*?);base64/);
            const mime = match?.[1] || fallbackType;
            const binary = atob(payload ?? "");
            const length = binary.length;
            const bytes = new Uint8Array(length);
            for (let index = 0; index < length; index += 1) {
              bytes[index] = binary.charCodeAt(index);
            }
            return { blob: new Blob([bytes], { type: mime }), type: mime };
          } catch (error) {
            console.error("Failed to parse stored file", error);
            return { blob: new Blob([], { type: fallbackType }), type: fallbackType };
          }
        }

        function dataUrlToBase64(dataUrl) {
          if (!dataUrl) return "";
          const parts = dataUrl.split(",");
          if (parts.length === 1) {
            return parts[0] ?? "";
          }
          return parts[1] ?? "";
        }

        function readFileAsDataUrl(file, progressCallback) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onerror = () => reject(reader.error);
            reader.onprogress = (event) => {
              if (event.lengthComputable) {
                const progress = event.total > 0 ? event.loaded / event.total : 0;
                progressCallback?.(progress);
              }
            };
            reader.onload = () => {
              resolve(typeof reader.result === "string" ? reader.result : "");
            };
            reader.readAsDataURL(file);
          });
        }

        async function copyToClipboard(text) {
          if (!text) return false;
          try {
            await navigator.clipboard.writeText(text);
            return true;
          } catch (error) {
            console.warn("Async clipboard failed, attempting fallback", error);
          }
          const textarea = document.createElement("textarea");
          textarea.value = text;
          textarea.setAttribute("readonly", "true");
          textarea.style.position = "fixed";
          textarea.style.top = "-9999px";
          document.body.appendChild(textarea);
          const selection = document.getSelection();
          const range = selection && selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
          textarea.select();
          let success = false;
          try {
            success = document.execCommand("copy");
          } catch (error) {
            console.error("Fallback copy failed", error);
            success = false;
          }
          textarea.blur();
          document.body.removeChild(textarea);
          if (range && selection) {
            selection.removeAllRanges();
            selection.addRange(range);
          }
          return success;
        }

        return {
          formatBytes,
          formatRelativeTime,
          formatDateTime,
          dataUrlToBlob,
          dataUrlToBase64,
          readFileAsDataUrl,
          createObjectUrl,
          revokeObjectUrl,
          revokeAllObjectUrls,
          copyToClipboard,
        };
      })();

      const Notifications = (() => {
        const stack = document.querySelector("[data-toast-stack]");
        const hideDelay = 5000;
        const tones = new Map([
          ["success", { icon: "✓", className: "toast--success" }],
          ["error", { icon: "⚠", className: "toast--error" }],
          ["info", { icon: "ℹ", className: "toast--info" }],
        ]);

        function buildToast(message, tone = "info") {
          const meta = tones.get(tone) || tones.get("info");
          const toast = document.createElement("div");
          toast.className = `toast ${meta?.className ?? ""}`.trim();
          toast.setAttribute("role", tone === "error" ? "alert" : "status");
          toast.setAttribute("aria-live", tone === "error" ? "assertive" : "polite");
          toast.tabIndex = 0;

          const icon = document.createElement("span");
          icon.className = "toast__icon";
          icon.setAttribute("aria-hidden", "true");
          icon.textContent = meta?.icon ?? "ℹ";

          const textNode = document.createElement("span");
          textNode.className = "toast__message";
          textNode.textContent = message;

          const dismissButton = document.createElement("button");
          dismissButton.className = "toast__dismiss";
          dismissButton.type = "button";
          dismissButton.textContent = Localization.t("common.dismiss");
          dismissButton.setAttribute("aria-label", Localization.t("common.dismiss"));

          toast.append(icon, textNode, dismissButton);
          toast.dataset.dismissButton = "";
          return toast;
        }

        function toast(message, tone = "info", { duration = hideDelay } = {}) {
          if (!stack || !message) return;
          const toastEl = buildToast(message, tone);
          stack.appendChild(toastEl);
          requestAnimationFrame(() => {
            toastEl.classList.add("is-visible");
          });
          const dismiss = () => {
            toastEl.classList.remove("is-visible");
            toastEl.addEventListener(
              "transitionend",
              () => {
                toastEl.remove();
              },
              { once: true }
            );
          };
          const timer = window.setTimeout(dismiss, duration);
          toastEl.addEventListener("click", (event) => {
            if (event.target instanceof HTMLButtonElement) return;
            window.clearTimeout(timer);
            dismiss();
          });
          toastEl.querySelector(".toast__dismiss")?.addEventListener("click", (event) => {
            event.stopPropagation();
            window.clearTimeout(timer);
            dismiss();
          });
          toastEl.addEventListener("keydown", (event) => {
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              window.clearTimeout(timer);
              dismiss();
            }
          });
        }

        function inline(target, message, tone) {
          if (!target) return;
          const normalized = message?.trim() ?? "";
          target.classList.remove("is-error", "is-success");
          if (!normalized) {
            target.hidden = true;
            target.textContent = "";
            target.removeAttribute("role");
            return;
          }
          target.hidden = false;
          target.textContent = normalized;
          if (tone === "error") {
            target.classList.add("is-error");
          } else if (tone === "success") {
            target.classList.add("is-success");
          }
          target.setAttribute("role", "alert");
        }

        return { toast, inline };
      })();

      let lastCopyTrigger = null;
      let openStorageModal = () => {};
      let closeStorageModal = () => {};
      const modal = document.getElementById("clipboard-confirm");
      const modalClose = modal?.querySelector("[data-close-modal]");

      function openModal(trigger) {
        if (!modal) return;
        lastCopyTrigger = trigger ?? null;
        modal.classList.add("is-open");
        modalClose?.focus({ preventScroll: true });
      }

      function closeModal() {
        if (!modal) return;
        modal.classList.remove("is-open");
        if (lastCopyTrigger) {
          lastCopyTrigger.focus({ preventScroll: true });
          lastCopyTrigger = null;
        }
      }

      modalClose?.addEventListener("click", closeModal);
      modal?.addEventListener("click", (event) => {
        if (event.target === modal) {
          closeModal();
        }
      });

      function resolveCopyValue(trigger) {
        const explicit = trigger.getAttribute("data-copy");
        if (explicit) return explicit;
        const selector = trigger.getAttribute("data-copy-target");
        if (!selector) return "";
        const target = document.querySelector(selector);
        if (!target) return "";
        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {
          return target.value?.trim() ?? "";
        }
        return target.textContent?.trim() ?? "";
      }

      async function copyFromTrigger(trigger) {
        const value = resolveCopyValue(trigger);
        if (!value) return;
        const success = await Utils.copyToClipboard(value);
        if (success) {
          Notifications.toast(Localization.t("common.copySuccess"), "success");
          if (modal) {
            openModal(trigger);
          }
        } else {
          Notifications.toast(Localization.t("common.copyFailure"), "error");
          const selector = trigger.getAttribute("data-copy-target");
          if (selector) {
            const target = document.querySelector(selector);
            if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {
              target.focus();
              target.select();
            }
          }
        }
      }

      document.addEventListener("click", (event) => {
        const trigger = event.target.closest("[data-copy], [data-copy-target]");
        if (!trigger) return;
        event.preventDefault();
        copyFromTrigger(trigger);
      });

      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          closeModal();
          closeStorageModal();
        }
      });

      window.addEventListener("beforeunload", () => {
        Utils.revokeAllObjectUrls();
      });

      function guessMimeType(name, fallback = "application/octet-stream") {
        if (!name) return fallback;
        const extension = name.split(".").pop()?.toLowerCase();
        const lookup = {
          pdf: "application/pdf",
          doc: "application/msword",
          docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
          ppt: "application/vnd.ms-powerpoint",
          pptx: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
          xls: "application/vnd.ms-excel",
          xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
          csv: "text/csv",
          txt: "text/plain",
          rtf: "application/rtf",
          json: "application/json",
          log: "text/plain",
          png: "image/png",
          jpg: "image/jpeg",
          jpeg: "image/jpeg",
          gif: "image/gif",
          webp: "image/webp",
          heic: "image/heic",
          mp4: "video/mp4",
          mov: "video/quicktime",
          zip: "application/zip",
        };
        return lookup[extension] || fallback;
      }

      function formatExifDate(value) {
        if (!value || typeof value !== "string") return null;
        const cleaned = value.replace(/\0/g, "").trim();
        const match = cleaned.match(/^(\d{4}):(\d{2}):(\d{2}) (\d{2}):(\d{2}):(\d{2})$/);
        if (!match) return cleaned || null;
        const iso = `${match[1]}-${match[2]}-${match[3]}T${match[4]}:${match[5]}:${match[6]}`;
        const date = new Date(iso);
        if (Number.isNaN(date.getTime())) return cleaned || null;
        return date.toISOString();
      }

      const SUPPORTED_IMAGE_TYPES = new Set([
        "image/jpeg",
        "image/png",
        "image/webp",
        "image/avif",
        "image/gif",
        "image/heic",
        "image/heif",
        "image/svg+xml",
        "image/tiff",
      ]);

      const MAX_IMAGE_DIMENSION = 8192;

      function isSupportedImageType(type) {
        if (!type) return false;
        const normalized = type.toLowerCase();
        if (SUPPORTED_IMAGE_TYPES.has(normalized)) return true;
        return normalized.startsWith("image/");
      }

      function getImageDimensions(file) {
        return new Promise((resolve, reject) => {
          const url = URL.createObjectURL(file);
          const image = new Image();
          image.onload = () => {
            const width = image.naturalWidth || image.width;
            const height = image.naturalHeight || image.height;
            URL.revokeObjectURL(url);
            resolve({ width, height });
          };
          image.onerror = (error) => {
            URL.revokeObjectURL(url);
            reject(error);
          };
          image.src = url;
        });
      }
      function parseExifFromArrayBuffer(buffer) {
        if (!buffer || !(buffer instanceof ArrayBuffer)) return {};
        try {
          const view = new DataView(buffer);
          if (view.byteLength < 4) return {};
          // Only JPEG containers expose the SOI marker (0xffd8); bail fast for other formats.
          if (view.getUint16(0) !== 0xffd8) {
            return {};
          }
          let offset = 2;
          while (offset + 4 < view.byteLength) {
            if (view.getUint8(offset) !== 0xff) break;
            const marker = view.getUint8(offset + 1);
            const length = view.getUint16(offset + 2);
            if (marker === 0xe1 && length > 8) {
              const start = offset + 4;
              const header = String.fromCharCode(
                view.getUint8(start),
                view.getUint8(start + 1),
                view.getUint8(start + 2),
                view.getUint8(start + 3)
              );
              if (header === "Exif") {
                // EXIF payloads start after the 6-byte TIFF header ("Exif\0\0"); parse the nested TIFF records.
                return parseExifSegment(view, start + 6, length - 6);
              }
            }
            // Advance past the current JPEG segment (length includes the size field itself).
            offset += 2 + length;
          }
        } catch (error) {
          console.warn("Failed to parse EXIF metadata", error);
        }
        return {};
      }

      function parseExifSegment(view, offset, length) {
        if (!view || typeof offset !== "number" || typeof length !== "number") return {};
        if (offset + length > view.byteLength) return {};
        const tiffOffset = offset;
        const byteOrder = view.getUint16(tiffOffset);
        const littleEndian = byteOrder === 0x4949;
        if (byteOrder !== 0x4949 && byteOrder !== 0x4d4d) return {};
        const magic = view.getUint16(tiffOffset + 2, littleEndian);
        if (magic !== 0x002a) return {};
        const firstIfdOffset = view.getUint32(tiffOffset + 4, littleEndian);
        const visited = new Set();
        const queue = [firstIfdOffset];
        const exif = {};

        const TYPE_SIZES = {
          1: 1,
          2: 1,
          3: 2,
          4: 4,
          5: 8,
          7: 1,
          10: 8,
        };

        function readValue(type, count, valueOffset, entryOffset) {
          const typeSize = TYPE_SIZES[type];
          if (!typeSize) return null;
          const valueSize = typeSize * count;
          let dataOffset;
          if (valueSize <= 4) {
            dataOffset = entryOffset + 8;
          } else {
            dataOffset = tiffOffset + valueOffset;
          }
          if (dataOffset + valueSize > tiffOffset + length) return null;
          switch (type) {
            case 2: {
              // ASCII strings are null-terminated; iterate until the sentinel to avoid trailing garbage.
              let text = "";
              for (let index = 0; index < valueSize; index += 1) {
                const code = view.getUint8(dataOffset + index);
                if (code === 0) break;
                text += String.fromCharCode(code);
              }
              return text.trim();
            }
            case 3: {
              if (count === 1) {
                return view.getUint16(dataOffset, littleEndian);
              }
              return Array.from({ length: count }, (_, i) =>
                view.getUint16(dataOffset + i * 2, littleEndian)
              );
            }
            case 4: {
              if (count === 1) {
                return view.getUint32(dataOffset, littleEndian);
              }
              return Array.from({ length: count }, (_, i) =>
                view.getUint32(dataOffset + i * 4, littleEndian)
              );
            }
            case 5: {
              const values = Array.from({ length: count }, (_, i) => {
                const numerator = view.getUint32(dataOffset + i * 8, littleEndian);
                const denominator = view.getUint32(dataOffset + i * 8 + 4, littleEndian);
                // Rational values encode numerator/denominator pairs; guard against divide-by-zero.
                return denominator ? numerator / denominator : 0;
              });
              return count === 1 ? values[0] : values;
            }
            case 10: {
              const values = Array.from({ length: count }, (_, i) => {
                const numerator = view.getInt32(dataOffset + i * 8, littleEndian);
                const denominator = view.getInt32(dataOffset + i * 8 + 4, littleEndian);
                // Signed rationals behave similarly but can include negative exposure bias values.
                return denominator ? numerator / denominator : 0;
              });
              return count === 1 ? values[0] : values;
            }
            case 7:
            case 1: {
              if (count === 1) {
                return view.getUint8(dataOffset);
              }
              return Array.from({ length: count }, (_, i) => view.getUint8(dataOffset + i));
            }
            default:
              return null;
          }
        }

        function queueIfd(offsetValue) {
          if (typeof offsetValue !== "number") return;
          if (offsetValue === 0) return;
          if (visited.has(offsetValue)) return;
          // Queue additional IFD (Image File Directory) blocks so we traverse thumbnails and sub-IFDs breadth-first.
          queue.push(offsetValue);
        }

        while (queue.length) {
          const ifdOffset = queue.shift();
          if (typeof ifdOffset !== "number") continue;
          if (visited.has(ifdOffset)) continue;
          visited.add(ifdOffset);
          const absolute = tiffOffset + ifdOffset;
          if (absolute + 2 > tiffOffset + length) continue;
          const entryCount = view.getUint16(absolute, littleEndian);
          for (let index = 0; index < entryCount; index += 1) {
            const entryOffset = absolute + 2 + index * 12;
            if (entryOffset + 12 > tiffOffset + length) break;
            const tag = view.getUint16(entryOffset, littleEndian);
            const type = view.getUint16(entryOffset + 2, littleEndian);
            const count = view.getUint32(entryOffset + 4, littleEndian);
            const valueOffset = view.getUint32(entryOffset + 8, littleEndian);
            if (tag === 0x8769 || tag === 0xa005) {
              queueIfd(valueOffset);
              continue;
            }
            const value = readValue(type, count, valueOffset, entryOffset);
            switch (tag) {
              case 0x010f:
                if (value) exif.make = value;
                break;
              case 0x0110:
                if (value) exif.model = value;
                break;
              case 0x0112:
                if (typeof value === "number") exif.orientation = value;
                break;
              case 0x0131:
                if (value) exif.software = value;
                break;
              case 0x0132:
                if (value && !exif.dateTimeOriginal) exif.dateTimeOriginal = value;
                break;
              case 0x829a:
                if (value) exif.exposureTime = value;
                break;
              case 0x829d:
                if (value) exif.fNumber = value;
                break;
              case 0x8827:
                if (value) {
                  exif.iso = Array.isArray(value) ? value[0] : value;
                }
                break;
              case 0x9003:
                if (value) exif.dateTimeOriginal = value;
                break;
              case 0x9201:
                if (value) exif.shutterSpeed = value;
                break;
              case 0x9204:
                if (value) exif.exposureBias = value;
                break;
              case 0x920a:
                if (value) exif.focalLength = value;
                break;
              case 0xa405:
                if (value) exif.focalLength35mm = value;
                break;
              case 0xa434:
                if (value) exif.lensModel = value;
                break;
              default:
                break;
            }
          }
          const nextIfdOffset = view.getUint32(absolute + 2 + entryCount * 12, littleEndian);
          if (nextIfdOffset) {
            queueIfd(nextIfdOffset);
          }
        }

        return exif;
      }

      function describeOrientation(value) {
        switch (value) {
          case 2:
            return "Mirrored horizontally";
          case 3:
            return "Rotated 180°";
          case 4:
            return "Mirrored vertically";
          case 5:
            return "Mirrored horizontally & rotated 90°";
          case 6:
            return "Rotated 90° clockwise";
          case 7:
            return "Mirrored horizontally & rotated 270°";
          case 8:
            return "Rotated 90° counter-clockwise";
          default:
            return value ? `Orientation ${value}` : null;
        }
      }

      const DocumentStore = (() => {
        const STORAGE_KEY = "invisibleSupport.documents";
        const listeners = new Set();
        let documents = [];

        function toSerializable(items) {
          return items.map(({ blobUrl, ...rest }) => rest);
        }

        function notify() {
          listeners.forEach((listener) => listener([...documents]));
        }

        async function persist(nextDocuments) {
          const serializable = toSerializable(nextDocuments);
          await StorageManager.persist(STORAGE_KEY, serializable);
        }

        function hydrate(rawDocs) {
          return rawDocs.map((doc) => {
            const downloadUrl = doc.downloadUrl || (doc.repoPath ? GitHubIntegration.buildRawUrl(doc.repoPath) : "");
            return { ...doc, downloadUrl, blobUrl: downloadUrl };
          });
        }

        async function load() {
          try {
            const stored = await StorageManager.read(STORAGE_KEY);
            if (Array.isArray(stored)) {
              documents = hydrate(stored).sort(
                (a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
              );
            } else {
              documents = [];
            }
          } catch (error) {
            if (error?.code !== "config") {
              console.error("Failed to load stored documents", error);
            }
            documents = [];
          }
          notify();
        }

        function generateId() {
          return typeof crypto !== "undefined" && crypto.randomUUID
            ? crypto.randomUUID()
            : `doc-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;
        }

        function ensureUniqueName(name) {
          if (!name) return name;
          const trimmed = name.trim();
          if (!trimmed) return trimmed;
          const [base, extension] = (() => {
            const lastDot = trimmed.lastIndexOf(".");
            if (lastDot > 0 && lastDot < trimmed.length - 1) {
              return [trimmed.slice(0, lastDot), trimmed.slice(lastDot)];
            }
            return [trimmed, ""];
          })();
          let candidate = trimmed;
          let counter = 2;
          while (documents.some((doc) => doc.name === candidate)) {
            // Mirror desktop OS renaming conventions: append " (n)" before the extension until unique.
            candidate = `${base} (${counter})${extension}`;
            counter += 1;
          }
          if (candidate !== trimmed) {
            Notifications.toast(Localization.t("notifications.duplicateName"), "info");
          }
          return candidate;
        }

        function normalizeDocument(file, extras) {
          const now = new Date().toISOString();
          const title = extras.title?.trim();
          const description = extras.description?.trim() ?? "";
          const type = file.type || guessMimeType(file.name);
          const normalizedName = ensureUniqueName(file.name);
          return {
            id: generateId(),
            name: normalizedName,
            title: title || normalizedName,
            description,
            type,
            size: file.size,
            updatedAt: now,
            repoPath: "",
            sha: "",
            downloadUrl: "",
            blobUrl: "",
          };
        }

        async function addDocument(doc) {
          const nextDocuments = [doc, ...documents].sort(
            (a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
          );
          await persist(nextDocuments);
          documents = nextDocuments;
          notify();
        }

        async function createDocument(file, extras = {}, progressCallback) {
          if (!(file instanceof File)) {
            const error = new Error(Localization.t("errors.invalidDocument"));
            error.code = "invalid";
            throw error;
          }
          if (!GitHubIntegration.isConfigured()) {
            const error = new Error(Localization.t("errors.githubConfigMissing"));
            error.code = "config";
            throw error;
          }
          const dataUrl = await Utils.readFileAsDataUrl(file, progressCallback);
          const base64 = Utils.dataUrlToBase64(dataUrl);
          const documentRecord = normalizeDocument(file, extras);
          const repoPath = `uploads/documents/${documentRecord.id}/${encodeURIComponent(documentRecord.name)}`;
          try {
            const upload = await GitHubIntegration.uploadFile(
              repoPath,
              base64,
              `Add document ${documentRecord.name}`
            );
            documentRecord.repoPath = upload.path;
            documentRecord.sha = upload.sha ?? "";
            documentRecord.downloadUrl = upload.downloadUrl ?? "";
            documentRecord.blobUrl = documentRecord.downloadUrl;
            documentRecord.updatedAt = new Date().toISOString();
            await addDocument(documentRecord);
            return documentRecord;
          } catch (error) {
            const failure =
              error?.code === "config" || error?.code === "quota" || error?.code === "persist"
                ? error
                : new Error(Localization.t("errors.persistFailure"));
            if (failure !== error) {
              failure.code = "persist";
              failure.cause = error;
            }
            throw failure;
          }
        }

        async function removeDocument(id) {
          const doc = documents.find((item) => item.id === id);
          if (!doc) return;
          try {
            if (doc.repoPath) {
              await GitHubIntegration.deleteFile(doc.repoPath, doc.sha, `Remove document ${doc.name}`);
            }
          } catch (error) {
            console.warn("Failed to delete remote document", error);
          }
          if (doc.blobUrl?.startsWith("blob:")) {
            Utils.revokeObjectUrl(doc.blobUrl);
          }
          const nextDocuments = documents.filter((item) => item.id !== id);
          await persist(nextDocuments);
          documents = nextDocuments;
          notify();
        }

        async function clearAll() {
          await Promise.all(
            documents.map((doc) => {
              if (!doc.repoPath) return Promise.resolve();
              return GitHubIntegration.deleteFile(doc.repoPath, doc.sha, `Remove document ${doc.name}`).catch((error) => {
                console.warn("Failed to delete remote document", error);
              });
            })
          );
          documents.forEach((doc) => {
            if (doc?.blobUrl?.startsWith("blob:")) {
              Utils.revokeObjectUrl(doc.blobUrl);
            }
          });
          documents = [];
          await StorageManager.clear(STORAGE_KEY);
          notify();
        }

        function subscribe(listener) {
          listeners.add(listener);
          listener([...documents]);
          return () => listeners.delete(listener);
        }

        function getDocument(id) {
          return documents.find((doc) => doc.id === id) ?? null;
        }

        function getDocuments() {
          return [...documents];
        }

        load();
        GitHubIntegration.subscribe(() => {
          load();
        });

        return { subscribe, createDocument, removeDocument, getDocument, getDocuments, clearAll };
      })();

      const ImageStore = (() => {
        const STORAGE_KEY = "invisibleSupport.images";
        const listeners = new Set();
        let images = [];

        function toSerializable(items) {
          return items.map(({ blobUrl, ...rest }) => rest);
        }

        function notify() {
          listeners.forEach((listener) => listener([...images]));
        }

        async function persist(nextImages) {
          const serializable = toSerializable(nextImages);
          await StorageManager.persist(STORAGE_KEY, serializable);
        }

        function hydrate(rawImages) {
          return rawImages.map((image) => {
            const downloadUrl = image.downloadUrl || (image.repoPath ? GitHubIntegration.buildRawUrl(image.repoPath) : "");
            const type = image.type || "image/png";
            return { ...image, type, downloadUrl, blobUrl: downloadUrl };
          });
        }

        async function load() {
          try {
            const stored = await StorageManager.read(STORAGE_KEY);
            if (Array.isArray(stored)) {
              images = hydrate(stored).sort(
                (a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
              );
            } else {
              images = [];
            }
          } catch (error) {
            if (error?.code !== "config") {
              console.error("Failed to load stored images", error);
            }
            images = [];
          }
          notify();
        }

        function generateId() {
          return typeof crypto !== "undefined" && crypto.randomUUID
            ? crypto.randomUUID()
            : `img-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;
        }

        function ensureUniqueName(name) {
          if (!name) return name;
          const trimmed = name.trim();
          if (!trimmed) return trimmed;
          const [base, extension] = (() => {
            const lastDot = trimmed.lastIndexOf(".");
            if (lastDot > 0 && lastDot < trimmed.length - 1) {
              return [trimmed.slice(0, lastDot), trimmed.slice(lastDot)];
            }
            return [trimmed, ""];
          })();
          let candidate = trimmed;
          let counter = 2;
          while (images.some((image) => image.name === candidate)) {
            candidate = `${base} (${counter})${extension}`;
            counter += 1;
          }
          if (candidate !== trimmed) {
            Notifications.toast(Localization.t("notifications.duplicateName"), "info");
          }
          return candidate;
        }

        function normalizeImage(file, extras, dimensions, exif) {
          const now = new Date().toISOString();
          const title = extras.title?.trim();
          const alt = extras.alt?.trim();
          const type = file.type || guessMimeType(file.name, "image/png");
          const capturedAtIso = formatExifDate(exif.dateTimeOriginal);
          const normalizedName = ensureUniqueName(file.name);
          return {
            id: generateId(),
            name: normalizedName,
            title: title || normalizedName,
            alt: alt || "",
            type,
            size: file.size,
            width: dimensions.width,
            height: dimensions.height,
            updatedAt: now,
            capturedAt: capturedAtIso,
            exif,
            repoPath: "",
            sha: "",
            downloadUrl: "",
            blobUrl: "",
          };
        }

        async function addImage(image) {
          const nextImages = [image, ...images].sort(
            (a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
          );
          await persist(nextImages);
          images = nextImages;
          notify();
        }

        async function createImage(file, extras = {}, progressCallback) {
          if (!(file instanceof File)) {
            const error = new Error(Localization.t("errors.invalidImage"));
            error.code = "invalid";
            throw error;
          }
          const mimeType = file.type || guessMimeType(file.name, "image/png");
          if (!isSupportedImageType(mimeType)) {
            const error = new Error(Localization.t("errors.unsupportedImageType"));
            error.code = "type";
            throw error;
          }

          let dimensions;
          try {
            dimensions = await getImageDimensions(file);
          } catch (error) {
            const dimensionError = new Error(Localization.t("errors.imageDimensions"));
            dimensionError.code = "dimensions";
            throw dimensionError;
          }

          if (
            !dimensions ||
            dimensions.width > MAX_IMAGE_DIMENSION ||
            dimensions.height > MAX_IMAGE_DIMENSION
          ) {
            const sizeError = new Error(Localization.t("errors.imageTooLarge"));
            sizeError.code = "max-dimensions";
            sizeError.details = dimensions;
            throw sizeError;
          }

          const arrayBufferPromise = file.arrayBuffer().catch(() => null);
          const dataUrl = await Utils.readFileAsDataUrl(file, progressCallback);
          let exif = {};
          try {
            const buffer = await arrayBufferPromise;
            if (buffer) {
              exif = parseExifFromArrayBuffer(buffer);
            }
          } catch (error) {
            console.warn("Unable to parse EXIF data", error);
          }

          if (!GitHubIntegration.isConfigured()) {
            const error = new Error(Localization.t("errors.githubConfigMissing"));
            error.code = "config";
            throw error;
          }

          const base64 = Utils.dataUrlToBase64(dataUrl);
          const imageRecord = normalizeImage(file, extras, dimensions, exif);
          const repoPath = `uploads/images/${imageRecord.id}/${encodeURIComponent(imageRecord.name)}`;
          try {
            const upload = await GitHubIntegration.uploadFile(
              repoPath,
              base64,
              `Add image ${imageRecord.name}`
            );
            imageRecord.repoPath = upload.path;
            imageRecord.sha = upload.sha ?? "";
            imageRecord.downloadUrl = upload.downloadUrl ?? "";
            imageRecord.blobUrl = imageRecord.downloadUrl;
            imageRecord.updatedAt = new Date().toISOString();
            await addImage(imageRecord);
            return imageRecord;
          } catch (error) {
            if (error?.code === "config" || error?.code === "quota" || error?.code === "persist") {
              throw error;
            }
            const failure = new Error(Localization.t("errors.persistFailure"));
            failure.code = "persist";
            failure.cause = error;
            throw failure;
          }
        }

        async function removeImage(id) {
          const image = images.find((item) => item.id === id);
          if (!image) return;
          try {
            if (image.repoPath) {
              await GitHubIntegration.deleteFile(image.repoPath, image.sha, `Remove image ${image.name}`);
            }
          } catch (error) {
            console.warn("Failed to delete remote image", error);
          }
          if (image?.blobUrl?.startsWith("blob:")) {
            Utils.revokeObjectUrl(image.blobUrl);
          }
          const nextImages = images.filter((item) => item.id !== id);
          await persist(nextImages);
          images = nextImages;
          notify();
        }

        function subscribe(listener) {
          listeners.add(listener);
          listener([...images]);
          return () => listeners.delete(listener);
        }

        function getImage(id) {
          return images.find((image) => image.id === id) ?? null;
        }

        function getImages() {
          return [...images];
        }

        async function clearAll() {
          await Promise.all(
            images.map((image) => {
              if (!image.repoPath) return Promise.resolve();
              return GitHubIntegration.deleteFile(image.repoPath, image.sha, `Remove image ${image.name}`).catch((error) => {
                console.warn("Failed to delete remote image", error);
              });
            })
          );
          images.forEach((image) => {
            if (image?.blobUrl?.startsWith("blob:")) {
              Utils.revokeObjectUrl(image.blobUrl);
            }
          });
          images = [];
          await StorageManager.clear(STORAGE_KEY);
          notify();
        }

        load();
        GitHubIntegration.subscribe(() => {
          load();
        });

      return { subscribe, createImage, removeImage, getImage, getImages, clearAll };
    })();

      const StorageUI = (() => {
        const meter = document.querySelector("[data-storage-meter]");
        const summaryEl = meter?.querySelector("[data-storage-summary]");
        const limitEl = meter?.querySelector("[data-storage-limit]");
        const progress = meter?.querySelector("[data-storage-progress]");
        const progressBar = meter?.querySelector("[data-storage-progress-bar]");
        const warningEl = meter?.querySelector("[data-storage-warning]");
        const manageButton = meter?.querySelector("[data-storage-manage]");
        const storageModal = document.getElementById("storage-modal");
        const modalUsed = storageModal?.querySelector("[data-storage-used]");
        const modalAvailable = storageModal?.querySelector("[data-storage-available]");
        const modalDocuments = storageModal?.querySelector("[data-storage-documents]");
        const modalImages = storageModal?.querySelector("[data-storage-images]");
        const modalClear = storageModal?.querySelector("[data-storage-clear]");
        const modalCancel = storageModal?.querySelector("[data-storage-cancel]");
        let lastTrigger = null;
        let snapshot = StorageManager.getSnapshot();
        let documents = DocumentStore.getDocuments();
        let images = ImageStore.getImages();

        function formatLimit(limitBytes) {
          if (!Number.isFinite(limitBytes) || limitBytes <= 0) {
            return Localization.t("labels.storageLimitUnset");
          }
          return Utils.formatBytes(limitBytes);
        }

        function describeCollection(count, singularKey, pluralKey, bytes) {
          const label = count === 1 ? Localization.t(singularKey) : Localization.t(pluralKey);
          const sizeText = Utils.formatBytes(bytes);
          return `${count} ${label.toLowerCase()} • ${sizeText}`;
        }

        function renderMeter() {
          if (!meter) return;
          const usedText = Utils.formatBytes(snapshot.used);
          const limitText = formatLimit(snapshot.limit);
          const percent = snapshot.limit > 0 ? Math.min(100, Math.round((snapshot.used / snapshot.limit) * 100)) : 0;
          if (summaryEl) {
            summaryEl.textContent = Localization.t("common.usageSummary", { used: usedText, limit: limitText });
          }
          if (limitEl) {
            limitEl.textContent = limitText;
          }
          if (progress) {
            progress.setAttribute("aria-valuemin", "0");
            progress.setAttribute("aria-valuemax", "100");
            progress.setAttribute("aria-valuenow", String(percent));
          }
          if (progressBar) {
            progressBar.style.width = `${percent}%`;
          }
          meter.classList.toggle("is-warning", snapshot.isWarning || snapshot.isExceeded);
          meter.classList.toggle("is-exceeded", snapshot.isExceeded);
          if (warningEl) {
            if (snapshot.isExceeded) {
              warningEl.hidden = false;
              warningEl.textContent = Localization.t("notifications.storageQuotaExceeded");
            } else if (snapshot.isWarning) {
              warningEl.hidden = false;
              warningEl.textContent = Localization.t("notifications.storageWarning", { percent });
            } else {
              warningEl.hidden = true;
              warningEl.textContent = "";
            }
          }
        }

        function renderModal() {
          if (!storageModal) return;
          const docBytes = documents.reduce((total, doc) => total + (Number(doc?.size) || 0), 0);
          const imageBytes = images.reduce((total, image) => total + (Number(image?.size) || 0), 0);
          const availableBytes = snapshot.limit > 0 ? Math.max(snapshot.limit - snapshot.used, 0) : 0;
          if (modalUsed) {
            modalUsed.textContent = Utils.formatBytes(snapshot.used);
          }
          if (modalAvailable) {
            modalAvailable.textContent = snapshot.limit > 0
              ? Utils.formatBytes(availableBytes)
              : Localization.t("labels.storageLimitUnset");
          }
          if (modalDocuments) {
            modalDocuments.textContent = describeCollection(
              documents.length,
              "labels.storageDocumentSingular",
              "labels.storageDocuments",
              docBytes
            );
          }
          if (modalImages) {
            modalImages.textContent = describeCollection(
              images.length,
              "labels.storageImageSingular",
              "labels.storageImages",
              imageBytes
            );
          }
        }

        function openModalInternal(trigger) {
          if (!storageModal) return;
          lastTrigger = trigger ?? null;
          renderModal();
          storageModal.classList.add("is-open");
          modalClear?.focus({ preventScroll: true });
        }

        function closeModalInternal() {
          if (!storageModal) return;
          storageModal.classList.remove("is-open");
          if (lastTrigger) {
            lastTrigger.focus({ preventScroll: true });
            lastTrigger = null;
          }
        }

        if (manageButton) {
          manageButton.addEventListener("click", (event) => {
            event.preventDefault();
            openModalInternal(manageButton);
          });
        }

        modalCancel?.addEventListener("click", closeModalInternal);
        storageModal?.addEventListener("click", (event) => {
          if (event.target === storageModal) {
            closeModalInternal();
          }
        });

        if (modalClear) {
          modalClear.addEventListener("click", async () => {
            if (modalClear.disabled) return;
            modalClear.disabled = true;
            try {
              await Promise.all([DocumentStore.clearAll(), ImageStore.clearAll()]);
              Notifications.toast(Localization.t("notifications.storageCleared"), "success");
              closeModalInternal();
            } catch (error) {
              console.error("Failed to clear storage", error);
              Notifications.toast(Localization.t("errors.persistFailure"), "error");
            } finally {
              modalClear.disabled = false;
            }
          });
        }

        StorageManager.subscribe((nextSnapshot) => {
          snapshot = nextSnapshot;
          renderMeter();
          renderModal();
        });

        DocumentStore.subscribe((nextDocuments) => {
          documents = nextDocuments;
          renderMeter();
          renderModal();
        });

        ImageStore.subscribe((nextImages) => {
          images = nextImages;
          renderModal();
          renderMeter();
        });

        renderMeter();
        renderModal();

        openStorageModal = openModalInternal;
        closeStorageModal = closeModalInternal;

        return null;
      })();

      function createViewerWidthController({
        sliderSelector,
        valueSelector,
        targetSelector,
        variableName,
        defaultValue = 40,
        mediaQuery = "(max-width: 960px)",
      }) {
        const slider = document.querySelector(sliderSelector);
        const valueEl = document.querySelector(valueSelector);
        const target = document.querySelector(targetSelector);
        if (!slider || !target) return null;

        const min = Number.parseFloat(slider.min) || 25;
        const max = Number.parseFloat(slider.max) || 100;
        const clamp = (value) => {
          const numeric = Number.parseFloat(value);
          if (Number.isNaN(numeric)) return defaultValue;
          return Math.min(max, Math.max(min, Math.round(numeric)));
        };

        const resolved = getComputedStyle(target)
          .getPropertyValue(variableName)
          .replace("%", "")
          .trim();
        let currentPercent = clamp(resolved || slider.value || defaultValue);

        function update(percent) {
          currentPercent = clamp(percent);
          slider.value = String(currentPercent);
          slider.setAttribute("aria-valuenow", String(currentPercent));
          if (valueEl) valueEl.textContent = `${currentPercent}%`;
          target.style.setProperty(variableName, `${currentPercent}%`);
        }

        function handleInput(event) {
          update(event.target.value);
        }

        const mq = typeof window !== "undefined" && window.matchMedia ? window.matchMedia(mediaQuery) : null;

        function syncWithMedia(event) {
          const matches = event?.matches ?? mq?.matches;
          if (!matches) {
            slider.disabled = false;
            slider.removeAttribute("aria-disabled");
            const previous = slider.dataset.previousValue;
            slider.removeAttribute("data-previous-value");
            update(previous ?? currentPercent);
            return;
          }
          slider.dataset.previousValue = slider.value;
          slider.disabled = true;
          slider.setAttribute("aria-disabled", "true");
          slider.value = "100";
          slider.setAttribute("aria-valuenow", "100");
          if (valueEl) valueEl.textContent = "100%";
          target.style.removeProperty(variableName);
        }

        slider.addEventListener("input", handleInput);
        update(currentPercent);
        if (mq) {
          if (mq.addEventListener) {
            mq.addEventListener("change", syncWithMedia);
          } else if (mq.addListener) {
            mq.addListener(syncWithMedia);
          }
          syncWithMedia();
        }

        return {
          set(percent) {
            update(percent);
            if (mq?.matches) {
              slider.dataset.previousValue = String(clamp(percent));
            }
          },
          get() {
            return currentPercent;
          },
        };
      }

      createViewerWidthController({
        sliderSelector: "[data-viewer-resize]",
        valueSelector: "[data-viewer-resize-value]",
        targetSelector: ".portal__grid",
        variableName: "--document-viewer-width",
      });

      createViewerWidthController({
        sliderSelector: "[data-image-resize]",
        valueSelector: "[data-image-resize-value]",
        targetSelector: ".image-portal__grid",
        variableName: "--image-viewer-width",
      });

      const ADOBE_EMBED_CLIENT_ID = "d6b613e7ac104dc49aae04788ff781df";
      const pdfLocale = document.documentElement.lang || "en-US";
      let adobeSdkPromise = null;
      const MAMMOTH_SCRIPT_URL = "https://cdn.jsdelivr.net/npm/mammoth@1.6.0/mammoth.browser.min.js";
      let mammothPromise = null;
      const scriptPromises = new Map();

      function waitForAdobeSdk() {
        if (typeof window === "undefined") {
          return Promise.reject(new Error("Adobe PDF Embed SDK is unavailable in this environment."));
        }
        if (window.AdobeDC?.View) {
          return Promise.resolve(window.AdobeDC);
        }
        if (!adobeSdkPromise) {
          adobeSdkPromise = new Promise((resolve, reject) => {
            const timeoutId = window.setTimeout(() => {
              adobeSdkPromise = null;
              reject(new Error("Timed out while waiting for the Adobe PDF Embed SDK."));
            }, 10000);

            const onReady = () => {
              window.clearTimeout(timeoutId);
              resolve(window.AdobeDC);
            };

            const previousHandler = document.adobe_dc_view_sdk_ready;
            document.adobe_dc_view_sdk_ready = () => {
              if (typeof previousHandler === "function") {
                try {
                  previousHandler();
                } catch (error) {
                  console.warn("Existing Adobe PDF ready handler failed", error);
                }
              }
              onReady();
            };
          });
        }
        return adobeSdkPromise;
      }

      function loadScriptOnce(src) {
        if (scriptPromises.has(src)) {
          return scriptPromises.get(src);
        }
        if (typeof document === "undefined") {
          return Promise.reject(new Error("Cannot load scripts in this environment."));
        }
        const promise = new Promise((resolve, reject) => {
          const script = document.createElement("script");
          script.src = src;
          script.async = true;
          script.crossOrigin = "anonymous";
          script.referrerPolicy = "no-referrer";
          script.onload = () => {
            window.setTimeout(() => script.remove(), 0);
            resolve();
          };
          script.onerror = () => {
            script.remove();
            scriptPromises.delete(src);
            reject(new Error(`Failed to load script: ${src}`));
          };
          document.head.appendChild(script);
        });
        scriptPromises.set(src, promise);
        return promise;
      }

      function waitForMammoth() {
        if (typeof window === "undefined" || typeof document === "undefined") {
          return Promise.reject(new Error("DOCX preview is unavailable in this environment."));
        }
        if (window.mammoth?.convertToHtml) {
          return Promise.resolve(window.mammoth);
        }
        if (!mammothPromise) {
          mammothPromise = loadScriptOnce(MAMMOTH_SCRIPT_URL)
            .then(() => {
              if (window.mammoth?.convertToHtml) {
                return window.mammoth;
              }
              throw new Error("Mammoth failed to initialize.");
            })
            .catch((error) => {
              mammothPromise = null;
              throw error;
            });
        }
        return mammothPromise;
      }

      function sanitizeForId(value) {
        if (!value) return "document";
        const cleaned = String(value).replace(/[^a-zA-Z0-9_-]/g, "");
        return cleaned || "document";
      }

      function createPdfContainerId(doc) {
        return `pdf-viewer-${sanitizeForId(doc?.id)}-${Math.random().toString(36).slice(2, 8)}`;
      }

      function getExtension(name) {
        if (!name) return "";
        const parts = String(name).toLowerCase().split(".");
        return parts.length > 1 ? parts.pop() ?? "" : "";
      }

      function getDocumentUrl(doc) {
        if (!doc) return "";
        return doc.blobUrl || doc.downloadUrl || "";
      }

      function isPdfDocument(doc) {
        if (!doc) return false;
        const type = (doc.type || "").toLowerCase();
        const extension = getExtension(doc.name);
        return type === "application/pdf" || extension === "pdf";
      }

      function createViewerFallback(doc, message) {
        const fallback = document.createElement("div");
        fallback.className = "viewer-card__fallback";
        const heading = document.createElement("h3");
        heading.textContent = "Preview unavailable";
        const copy = document.createElement("p");
        copy.className = "portal__lede";
        copy.style.fontSize = "0.95rem";
        copy.textContent =
          message
          || `This file type (${doc?.type || "unknown"}) cannot be previewed inline. Use the controls below to open or download the document.`;
        fallback.append(heading, copy);
        return fallback;
      }

      const DocumentViewer = (() => {
        const preview = document.querySelector("[data-viewer-preview]");
        const meta = document.querySelector("[data-viewer-meta]");
        const linkInput = document.querySelector("[data-viewer-link]");
        const openLink = document.querySelector("[data-viewer-open]");
        const copyButton = document.querySelector("[data-viewer-copy]");
        const nameEl = document.querySelector("[data-viewer-name]");
        const filenameEl = document.querySelector("[data-viewer-filename]");
        const typeEl = document.querySelector("[data-viewer-type]");
        const sizeEl = document.querySelector("[data-viewer-size]");
        const updatedEl = document.querySelector("[data-viewer-updated]");
        const descriptionEl = document.querySelector("[data-viewer-description]");
        const selectInput = document.querySelector("[data-viewer-select]");
        const emptyTemplate = preview?.querySelector("[data-viewer-empty]")?.cloneNode(true) ?? null;
        const previewCache = new Map();
        let currentId = null;
        let renderToken = 0;

        const OFFICE_MIME_TYPES = new Set([
          "application/msword",
          "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
          "application/vnd.ms-powerpoint",
          "application/vnd.openxmlformats-officedocument.presentationml.presentation",
          "application/vnd.ms-excel",
          "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        ].map((item) => item.toLowerCase()));
        const OFFICE_EXTENSIONS = new Set([
          "doc",
          "docx",
          "dotx",
          "ppt",
          "pptx",
          "pps",
          "ppsx",
          "xls",
          "xlsx",
        ]);
        const TEXT_MIME_TYPES = new Set([
          "application/json",
          "application/xml",
          "application/yaml",
          "application/x-yaml",
          "application/csv",
        ].map((item) => item.toLowerCase()));
        const TEXT_EXTENSIONS = new Set([
          "txt",
          "log",
          "md",
          "json",
          "csv",
          "yml",
          "yaml",
          "xml",
          "ini",
          "conf",
        ]);
        const TEXT_CHAR_LIMIT = 100000;

        function focusPreview() {
          if (preview) {
            preview.setAttribute("tabindex", "-1");
            preview.focus({ preventScroll: true });
          }
        }

        function emitSelectionChange() {
          document.dispatchEvent(new CustomEvent("documentviewerchange", { detail: { id: currentId } }));
        }

        function updateSelectValue(id) {
          if (!selectInput) return;
          if (!id) {
            selectInput.value = "";
            return;
          }
          const option = Array.from(selectInput.options).find((item) => item.value === id);
          if (option) {
            selectInput.value = id;
          }
        }

        function updateSelectOptions(docs) {
          if (!selectInput) return;
          const fragment = document.createDocumentFragment();
          const placeholder = document.createElement("option");
          placeholder.value = "";
          placeholder.textContent = docs.length ? "Select a document…" : "No documents uploaded yet";
          fragment.appendChild(placeholder);
          docs.forEach((doc) => {
            const option = document.createElement("option");
            option.value = doc.id;
            option.textContent = doc.title || doc.name;
            fragment.appendChild(option);
          });
          selectInput.replaceChildren(fragment);
          if (docs.length === 0) {
            selectInput.value = "";
            selectInput.disabled = true;
            selectInput.setAttribute("aria-disabled", "true");
          } else {
            selectInput.disabled = false;
            selectInput.removeAttribute("aria-disabled");
            if (currentId && docs.some((doc) => doc.id === currentId)) {
              selectInput.value = currentId;
            } else {
              selectInput.value = "";
            }
          }
        }

        function cleanupCache(validIds) {
          previewCache.forEach((entry, id) => {
            if (!validIds.has(id)) {
              entry?.dispose?.();
              previewCache.delete(id);
            }
          });
        }

        function renderLoading() {
          if (!preview) return;
          preview.innerHTML = "";
          preview.dataset.state = "loading";
          const loading = document.createElement("div");
          loading.className = "viewer-card__loading";
          loading.textContent = "Loading preview…";
          preview.appendChild(loading);
        }

        function resetMeta() {
          if (meta) meta.hidden = true;
          if (nameEl) nameEl.textContent = "—";
          if (filenameEl) filenameEl.textContent = "—";
          if (typeEl) typeEl.textContent = "—";
          if (sizeEl) sizeEl.textContent = "—";
          if (updatedEl) updatedEl.textContent = "—";
          if (descriptionEl) {
            descriptionEl.hidden = true;
            descriptionEl.textContent = "";
          }
          if (linkInput) linkInput.value = "";
          if (copyButton) copyButton.setAttribute("data-copy", "");
          if (openLink) {
            openLink.href = "#";
            openLink.setAttribute("aria-disabled", "true");
          }
        }

        function updateMeta(doc) {
          const docUrl = getDocumentUrl(doc);
          if (meta) meta.hidden = false;
          if (nameEl) nameEl.textContent = doc.title || doc.name;
          if (filenameEl) filenameEl.textContent = doc.name;
          if (typeEl) typeEl.textContent = doc.type || "Unknown";
          if (sizeEl) sizeEl.textContent = Utils.formatBytes(doc.size);
          if (updatedEl) updatedEl.textContent = Utils.formatRelativeTime(doc.updatedAt);
          if (descriptionEl) {
            if (doc.description) {
              descriptionEl.hidden = false;
              descriptionEl.textContent = doc.description;
            } else {
              descriptionEl.hidden = true;
              descriptionEl.textContent = "";
            }
          }
          if (linkInput) linkInput.value = docUrl;
          if (copyButton) copyButton.setAttribute("data-copy", docUrl);
          if (openLink) {
            if (docUrl) {
              openLink.href = docUrl;
              openLink.removeAttribute("aria-disabled");
            } else {
              openLink.href = "#";
              openLink.setAttribute("aria-disabled", "true");
            }
          }
        }

        function isPdf(type, extension) {
          return type === "application/pdf" || extension === "pdf";
        }

        function isOfficeDocument(type, extension) {
          return OFFICE_MIME_TYPES.has(type) || OFFICE_EXTENSIONS.has(extension);
        }

        function isTextDocument(type, extension) {
          return type.startsWith("text/") || TEXT_MIME_TYPES.has(type) || TEXT_EXTENSIONS.has(extension);
        }

        function isImage(type) {
          return type.startsWith("image/");
        }

        function isVideo(type) {
          return type.startsWith("video/");
        }

        function isAudio(type) {
          return type.startsWith("audio/");
        }

        async function fetchDocumentResource(doc) {
          if (!doc) return null;
          const url = getDocumentUrl(doc);
          const revision = String(doc.sha || doc.updatedAt || "");
          const cached = previewCache.get(doc.id);
          if (cached && cached.revision === revision) {
            return cached;
          }
          if (cached) {
            cached.dispose?.();
            previewCache.delete(doc.id);
          }
          const useExistingUrl = url && url.startsWith("blob:");
          const fallbackType = doc.type || "application/octet-stream";

          async function cacheResourceFromBlob(blob) {
            if (!blob) return null;
            const objectUrl = useExistingUrl && url ? url : URL.createObjectURL(blob);
            const resource = {
              url: objectUrl,
              type: blob.type || fallbackType,
              blob,
              revision,
              dispose:
                useExistingUrl && url
                  ? null
                  : () => {
                      URL.revokeObjectURL(objectUrl);
                    },
            };
            previewCache.set(doc.id, resource);
            return resource;
          }

          if (url) {
            try {
              const response = await fetch(url);
              if (response.ok) {
                const blob = await response.blob();
                return cacheResourceFromBlob(blob);
              }
              if (response.status !== 404) {
                console.warn("Failed to fetch document preview", new Error(`Unable to fetch preview (${response.status})`));
              }
            } catch (error) {
              console.warn("Failed to fetch document preview", error);
            }
          }

          if (doc.repoPath && typeof GitHubIntegration?.downloadFile === "function") {
            try {
              const { arrayBuffer, contentType } = await GitHubIntegration.downloadFile(doc.repoPath);
              const blob = new Blob([arrayBuffer], { type: contentType || fallbackType });
              return cacheResourceFromBlob(blob);
            } catch (error) {
              console.warn("Failed to fetch document preview via GitHub API", error);
            }
          }

          return null;
        }

        async function buildPreviewContent(doc) {
          const type = (doc.type || "").toLowerCase();
          const extension = getExtension(doc.name);
          const displayName = doc.title || doc.name;
          const directUrl = getDocumentUrl(doc);

          if (isPdf(type, extension)) {
            const resource = await fetchDocumentResource(doc);
            if (resource?.blob) {
              const container = document.createElement("div");
              container.className = "viewer-card__pdf";
              container.dataset.state = "loading";
              container.id = createPdfContainerId(doc);
              container.setAttribute("aria-busy", "true");

              const status = document.createElement("p");
              status.className = "viewer-card__pdf-message";
              status.textContent = "Loading secure PDF preview…";
              container.appendChild(status);

              const bufferPromise = resource.blob.arrayBuffer();

              waitForAdobeSdk()
                .then(() => bufferPromise)
                .then((buffer) => {
                  if (!container.isConnected || currentId !== doc.id) {
                    return;
                  }

                  if (typeof window.AdobeDC?.View !== "function") {
                    throw new Error("Adobe PDF Embed SDK failed to initialize.");
                  }

                  container.textContent = "";
                  container.dataset.state = "ready";
                  container.removeAttribute("aria-busy");

                  const view = new window.AdobeDC.View({
                    clientId: ADOBE_EMBED_CLIENT_ID,
                    divId: container.id,
                    locale: pdfLocale,
                  });

                  view.previewFile(
                    {
                      content: { promise: Promise.resolve(buffer) },
                      metaData: {
                        fileName: doc.name,
                        id: doc.id,
                      },
                    },
                    {
                      embedMode: "FULL_WINDOW",
                      showAnnotationTools: false,
                      showDownloadPDF: true,
                      showPrintPDF: true,
                    }
                  );
                })
                .catch((error) => {
                  console.warn("Failed to initialize Adobe PDF preview", error);
                  if (!container.isConnected || currentId !== doc.id) {
                    return;
                  }
                  const fallback = createViewerFallback(
                    doc,
                    "Unable to load the interactive PDF preview. Use the controls below to open or download the document."
                  );
                  container.replaceWith(fallback);
                });

              return container;
            }
          }

          if (isOfficeDocument(type, extension)) {
            const isDocx =
              extension === "docx" ||
              type === "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
            if (isDocx) {
              const resource = await fetchDocumentResource(doc);
              if (resource?.blob) {
                const container = document.createElement("div");
                container.className = "viewer-card__docx";
                container.dataset.state = "loading";
                container.setAttribute("aria-busy", "true");

                const status = document.createElement("p");
                status.className = "viewer-card__docx-message";
                status.textContent = "Rendering document preview.";
                container.appendChild(status);

                const bufferPromise = resource.blob.arrayBuffer();

                Promise.all([waitForMammoth(), bufferPromise])
                  .then(([mammothLib, buffer]) => {
                    if (!container.isConnected || currentId !== doc.id) {
                      return null;
                    }
                    if (typeof mammothLib?.convertToHtml !== "function") {
                      throw new Error("Mammoth library did not expose convertToHtml.");
                    }
                    const options =
                      typeof mammothLib.images?.inline === "function"
                        ? {
                            convertImage: mammothLib.images.inline((element) =>
                              element.read("base64").then((imageBuffer) => ({
                                src: `data:${element.contentType};base64,${imageBuffer}`,
                              }))
                            ),
                          }
                        : {};
                    return mammothLib.convertToHtml({ arrayBuffer: buffer }, options);
                  })
                  .then((result) => {
                    if (!container.isConnected || currentId !== doc.id) {
                      return;
                    }
                    if (!result) {
                      throw new Error("Mammoth returned no result.");
                    }
                    const html = (result.value || "").trim();
                    const messages = Array.isArray(result.messages) ? result.messages : [];
                    container.dataset.state = "ready";
                    container.removeAttribute("aria-busy");
                    status.remove();
                    if (!html) {
                      throw new Error("Mammoth returned empty content.");
                    }
                    container.innerHTML = html;
                    messages.forEach((message) => {
                      console.warn("Mammoth message:", message);
                    });
                    container.scrollTop = 0;
                  })
                  .catch((error) => {
                    console.warn("Failed to render DOCX preview", error);
                    if (!container.isConnected || currentId !== doc.id) {
                      return;
                    }
                    status.remove();
                    const fallback = createViewerFallback(
                      doc,
                      "Unable to load the DOCX preview. Use the controls below to open or download the document."
                    );
                    container.replaceWith(fallback);
                  });

                return container;
              }
              return createViewerFallback(
                doc,
                "Unable to load the DOCX preview. Use the controls below to open or download the document."
              );
            }

            if (directUrl) {
              const frame = document.createElement("iframe");
              frame.src = `https://view.officeapps.live.com/op/embed.aspx?src=${encodeURIComponent(directUrl)}`;
              frame.title = `${displayName} preview`;
              frame.loading = "lazy";
              return frame;
            }
          }

          if (isImage(type)) {
            const resource = await fetchDocumentResource(doc);
            if (resource?.url) {
              const img = document.createElement("img");
              img.src = resource.url;
              img.alt = displayName;
              img.loading = "lazy";
              return img;
            }
          }

          if (isVideo(type)) {
            const resource = await fetchDocumentResource(doc);
            if (resource?.url) {
              const video = document.createElement("video");
              video.controls = true;
              video.src = resource.url;
              video.preload = "metadata";
              return video;
            }
          }

          if (isAudio(type)) {
            const resource = await fetchDocumentResource(doc);
            if (resource?.url) {
              const audio = document.createElement("audio");
              audio.controls = true;
              audio.src = resource.url;
              return audio;
            }
          }

          if (isTextDocument(type, extension)) {
            const resource = await fetchDocumentResource(doc);
            if (resource?.blob) {
              try {
                const text = await resource.blob.text();
                const pre = document.createElement("pre");
                if (text.length > TEXT_CHAR_LIMIT) {
                  pre.textContent = `${text.slice(0, TEXT_CHAR_LIMIT)}\n… (preview truncated)`;
                } else {
                  pre.textContent = text;
                }
                return pre;
              } catch (error) {
                console.warn("Failed to decode text preview", error);
              }
            }
          }

          const resource = await fetchDocumentResource(doc);
          if (resource?.url) {
            const objectEl = document.createElement("object");
            objectEl.data = resource.url;
            objectEl.type = resource.type || doc.type || "application/octet-stream";
            objectEl.className = "viewer-card__object";
            if (directUrl) {
              const paragraph = document.createElement("p");
              paragraph.textContent = "Preview unavailable. ";
              const link = document.createElement("a");
              link.href = directUrl;
              link.target = "_blank";
              link.rel = "noopener";
              link.textContent = "Open in new tab";
              paragraph.appendChild(link);
              objectEl.appendChild(paragraph);
            }
            return objectEl;
          }

          return null;
        }

        function renderEmpty() {
          renderToken += 1;
          if (!preview) return;
          preview.innerHTML = "";
          preview.dataset.state = "empty";
          if (emptyTemplate) {
            preview.appendChild(emptyTemplate.cloneNode(true));
          }
          resetMeta();
          updateSelectValue(null);
          currentId = null;
          emitSelectionChange();
          focusPreview();
        }

        async function renderDocument(doc) {
          if (!preview) return;
          if (!doc) {
            renderEmpty();
            return;
          }

          const token = ++renderToken;
          currentId = doc.id;
          updateSelectValue(doc.id);
          renderLoading();

          let content = null;
          try {
            content = await buildPreviewContent(doc);
          } catch (error) {
            console.error("Failed to render document preview", error);
          }

          if (token !== renderToken || currentId !== doc.id) {
            return;
          }

          preview.innerHTML = "";
          preview.dataset.state = "ready";
          if (content) {
            preview.appendChild(content);
          } else {
            preview.appendChild(createViewerFallback(doc));
          }

          updateMeta(doc);
          emitSelectionChange();
          focusPreview();
        }

        selectInput?.addEventListener("change", (event) => {
          const id = event.target.value;
          if (!id) {
            renderEmpty();
            return;
          }
          if (id === currentId) return;
          const doc = DocumentStore.getDocument(id);
          if (doc) {
            renderDocument(doc);
          } else {
            renderEmpty();
          }
        });

        DocumentStore.subscribe((docs) => {
          updateSelectOptions(docs);
          cleanupCache(new Set(docs.map((doc) => doc.id)));
          if (!currentId) {
            if (docs.length === 0) {
              renderEmpty();
            }
            return;
          }
          const match = docs.find((doc) => doc.id === currentId);
          if (!match) {
            renderEmpty();
          } else {
            renderDocument(match);
          }
        });

        renderEmpty();

      return {
        selectDocument(id) {
          if (!id) {
            renderEmpty();
            return;
          }
          const doc = DocumentStore.getDocument(id);
          if (doc) {
            renderDocument(doc);
          } else {
            renderEmpty();
          }
        },
        getSelectedId() {
          return currentId;
        },
      };
      })();

      const LibraryView = (() => {
        const rows = document.querySelector("[data-library-rows]");
        const emptyState = document.querySelector("[data-library-empty]");
        const searchInput = document.querySelector("[data-library-search]");
        let docs = [];
        let query = "";
        let pendingFocusTarget = null;

        function matches(doc) {
          if (!query) return true;
          const value = query.toLowerCase();
          return [doc.title, doc.name, doc.type, doc.description]
            .filter(Boolean)
            .some((field) => field.toLowerCase().includes(value));
        }

        function getRowSelector(id) {
          if (!id) return null;
          if (typeof CSS !== "undefined" && CSS.escape) {
            return `tr[data-id="${CSS.escape(id)}"]`;
          }
          const safe = String(id).replace(/"/g, '\"');
          return `tr[data-id="${safe}"]`;
        }

        function focusRow(id) {
          const selector = getRowSelector(id);
          if (!rows || !selector) return;
          const target = rows.querySelector(selector);
          target?.focus({ preventScroll: false });
        }

        function markSelection(row, isSelected) {
          row.classList.toggle("is-selected", isSelected);
          if (isSelected) {
            row.setAttribute("aria-selected", "true");
          } else {
            row.removeAttribute("aria-selected");
          }
        }

        function syncSelection() {
          const selectedIds = new Set();
          if (typeof DocumentViewer?.getSelectedId === "function") {
            const id = DocumentViewer.getSelectedId();
            if (id) selectedIds.add(id);
          }
          rows?.querySelectorAll("tr[data-id]").forEach((row) => {
            markSelection(row, selectedIds.has(row.dataset.id));
          });
        }

        function applyPendingFocus() {
          if (!pendingFocusTarget) return;
          if (pendingFocusTarget === "search") {
            searchInput?.focus({ preventScroll: false });
          } else {
            focusRow(pendingFocusTarget);
          }
          pendingFocusTarget = null;
        }

        function render() {
          if (!rows) return;
          rows.textContent = "";
          const filtered = docs.filter(matches);
          if (emptyState) {
            emptyState.hidden = filtered.length > 0;
          }
          if (filtered.length === 0) {
            applyPendingFocus();
            return;
          }

          const selectedIds = new Set();
          if (typeof DocumentViewer?.getSelectedId === "function") {
            const id = DocumentViewer.getSelectedId();
            if (id) selectedIds.add(id);
          }

          filtered.forEach((doc) => {
            const docUrl = doc.downloadUrl || doc.blobUrl || "";
            const row = document.createElement("tr");
            row.dataset.id = doc.id;
            row.tabIndex = -1;
            markSelection(row, selectedIds.has(doc.id));

            const titleCell = document.createElement("td");
            const titleWrapper = document.createElement("div");
            titleWrapper.className = "library-table__title";
            const title = document.createElement("strong");
            title.textContent = doc.title || doc.name;
            const subtitle = document.createElement("span");
            subtitle.textContent = doc.description || doc.name;
            titleWrapper.append(title, subtitle);
            titleCell.appendChild(titleWrapper);
            row.appendChild(titleCell);

            const typeCell = document.createElement("td");
            typeCell.textContent = doc.type || "Unknown";
            row.appendChild(typeCell);

            const sizeCell = document.createElement("td");
            sizeCell.textContent = Utils.formatBytes(doc.size);
            row.appendChild(sizeCell);

            const updatedCell = document.createElement("td");
            updatedCell.textContent = Utils.formatRelativeTime(doc.updatedAt);
            row.appendChild(updatedCell);

            const actionsCell = document.createElement("td");
            actionsCell.className = "library-table__actions";

            const viewButton = document.createElement("button");
            viewButton.type = "button";
            viewButton.className = "library-action";
            viewButton.dataset.action = "view";
            viewButton.textContent = "View";
            actionsCell.appendChild(viewButton);

            const copyBtn = document.createElement("button");
            copyBtn.type = "button";
            copyBtn.className = "library-action";
            copyBtn.dataset.copy = docUrl;
            copyBtn.textContent = "Copy link";
            actionsCell.appendChild(copyBtn);

            const downloadLink = document.createElement("a");
            downloadLink.className = "library-action";
            downloadLink.href = docUrl || "#";
            downloadLink.target = "_blank";
            downloadLink.rel = "noopener";
            downloadLink.download = doc.name;
            downloadLink.textContent = "Download";
            if (!docUrl) {
              downloadLink.classList.add("is-disabled");
              downloadLink.setAttribute("aria-disabled", "true");
            }
            actionsCell.appendChild(downloadLink);

            const deleteButton = document.createElement("button");
            deleteButton.type = "button";
            deleteButton.className = "library-action";
            deleteButton.dataset.action = "delete";
            deleteButton.textContent = "Delete";
            actionsCell.appendChild(deleteButton);

            row.appendChild(actionsCell);
            rows.appendChild(row);
          });

          applyPendingFocus();
          syncSelection();
        }

        DocumentStore.subscribe((nextDocs) => {
          docs = nextDocs;
          render();
        });

        searchInput?.addEventListener("input", (event) => {
          query = event.target.value.trim().toLowerCase();
          render();
        });

        rows?.addEventListener("click", (event) => {
          const actionTarget = event.target.closest("[data-action]");
          if (!actionTarget) return;
          const row = actionTarget.closest("tr[data-id]");
          const id = row?.dataset.id;
          if (!id) return;
          if (actionTarget.dataset.action === "view") {
            if (typeof DocumentViewer?.selectDocument === "function") {
              DocumentViewer.selectDocument(id);
            }
            pendingFocusTarget = id;
            syncSelection();
          } else if (actionTarget.dataset.action === "delete") {
            const fallback = row.previousElementSibling?.dataset.id || row.nextElementSibling?.dataset.id || "search";
            pendingFocusTarget = fallback;
            DocumentStore.removeDocument(id)
              .then(() => {
                Notifications.toast(Localization.t("notifications.documentRemoved"), "info");
              })
              .catch((error) => {
                console.error("Failed to remove document", error);
                Notifications.toast(Localization.t("errors.persistFailure"), "error");
              });
          }
        });

        rows?.addEventListener("keydown", (event) => {
          const row = event.target.closest("tr[data-id]");
          if (!row || event.target !== row) return;
          const id = row.dataset.id;
          if (!id) return;
          if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            if (typeof DocumentViewer?.selectDocument === "function") {
              DocumentViewer.selectDocument(id);
            }
            pendingFocusTarget = id;
            syncSelection();
          } else if (event.key === "Delete") {
            event.preventDefault();
            const fallback = row.previousElementSibling?.dataset.id || row.nextElementSibling?.dataset.id || "search";
            pendingFocusTarget = fallback;
            DocumentStore.removeDocument(id)
              .then(() => {
                Notifications.toast(Localization.t("notifications.documentRemoved"), "info");
              })
              .catch((error) => {
                console.error("Failed to remove document", error);
                Notifications.toast(Localization.t("errors.persistFailure"), "error");
              });
          }
        });

        document.addEventListener("documentviewerchange", () => {
          syncSelection();
        });

        return {
          focusRow,
          focusFirst() {
            const firstRow = rows?.querySelector("tr[data-id]");
            firstRow?.focus({ preventScroll: false });
          },
        };
      })();

      const ImageViewer = (() => {
        const canvas = document.querySelector("[data-image-canvas]");
        const preview = canvas?.querySelector("[data-image-preview]");
        const emptyState = canvas?.querySelector("[data-image-empty]");
        const controls = document.querySelector("[data-image-controls]");
        const fitButtons = controls ? Array.from(controls.querySelectorAll("[data-image-fit]")) : [];
        const zoomSlider = controls?.querySelector("[data-image-zoom]");
        const meta = document.querySelector("[data-image-meta]");
        const nameEl = document.querySelector("[data-image-name]");
        const filenameEl = document.querySelector("[data-image-filename]");
        const dimensionsEl = document.querySelector("[data-image-dimensions]");
        const sizeEl = document.querySelector("[data-image-size]");
        const typeEl = document.querySelector("[data-image-type]");
        const altEl = document.querySelector("[data-image-alt]");
        const takenEl = document.querySelector("[data-image-taken]");
        const linkInput = document.querySelector("[data-image-link]");
        const openLink = document.querySelector("[data-image-open]");
        const exifContainer = document.querySelector("[data-image-exif]");
        const exifList = document.querySelector("[data-image-exif-list]");
        let currentId = null;
        let currentFit = "contain";
        let zoom = 100;
        let currentOrientation = 1;

        function focusCanvas() {
          if (canvas) {
            canvas.setAttribute("tabindex", "-1");
            canvas.focus({ preventScroll: true });
          }
        }

        function emitSelectionChange() {
          document.dispatchEvent(
            new CustomEvent("imageviewerchange", { detail: { id: currentId } })
          );
        }

        function resolveOrientationTransform(value) {
          switch (value) {
            case 2:
              return "scaleX(-1)";
            case 3:
              return "rotate(180deg)";
            case 4:
              return "scaleY(-1)";
            case 5:
              return "rotate(90deg) scaleX(-1)";
            case 6:
              return "rotate(90deg)";
            case 7:
              return "rotate(-90deg) scaleX(-1)";
            case 8:
              return "rotate(-90deg)";
            default:
              return "";
          }
        }

        function applyTransform() {
          if (!preview) return;
          const scale = zoom / 100;
          const orientationTransform = resolveOrientationTransform(currentOrientation);
          if (orientationTransform) {
            preview.style.transform = `${orientationTransform} scale(${scale})`;
          } else {
            preview.style.transform = `scale(${scale})`;
          }
        }

        function setZoom(value) {
          const clamped = Math.max(25, Math.min(200, Number(value) || 100));
          zoom = clamped;
          if (zoomSlider && zoomSlider.value !== String(clamped)) {
            zoomSlider.value = String(clamped);
          }
          applyTransform();
        }

        function setFit(nextFit) {
          currentFit = nextFit;
          if (canvas) {
            canvas.dataset.fit = nextFit;
          }
          fitButtons.forEach((button) => {
            button.classList.toggle("is-active", button.dataset.imageFit === nextFit);
          });
          applyTransform();
        }

        function clearMeta() {
          if (nameEl) nameEl.textContent = "—";
          if (filenameEl) filenameEl.textContent = "—";
          if (dimensionsEl) dimensionsEl.textContent = "—";
          if (sizeEl) sizeEl.textContent = "—";
          if (typeEl) typeEl.textContent = "—";
          if (altEl) altEl.textContent = "—";
          if (takenEl) takenEl.textContent = "—";
          if (linkInput) linkInput.value = "";
          if (openLink) {
            openLink.href = "#";
            openLink.setAttribute("aria-disabled", "true");
          }
          if (exifList) {
            exifList.textContent = "";
          }
          if (exifContainer) {
            exifContainer.hidden = true;
          }
        }

        function renderEmpty() {
          currentId = null;
          currentOrientation = 1;
          zoom = 100;
          if (zoomSlider) {
            zoomSlider.value = "100";
          }
          if (canvas) {
            canvas.dataset.fit = currentFit;
          }
          if (preview) {
            preview.hidden = true;
            preview.removeAttribute("src");
            preview.style.transform = "scale(1)";
          }
          if (emptyState) {
            emptyState.hidden = false;
          }
          if (controls) controls.hidden = true;
          if (meta) meta.hidden = true;
          clearMeta();
          setFit(currentFit);
          emitSelectionChange();
          focusCanvas();
        }

        function formatExifEntries(exif) {
          if (!exif || typeof exif !== "object") return [];
          const entries = [];
          const camera = [exif.make, exif.model].filter(Boolean).join(" ").trim();
          if (camera) {
            entries.push({ label: "Camera", value: camera });
          }
          if (exif.lensModel) {
            entries.push({ label: "Lens", value: exif.lensModel });
          }
          if (typeof exif.exposureTime === "number" && exif.exposureTime > 0) {
            const exposure = exif.exposureTime < 1
              ? `1/${Math.round(1 / exif.exposureTime)} s`
              : `${exif.exposureTime.toFixed(2)} s`;
            entries.push({ label: "Exposure", value: exposure });
          }
          if (typeof exif.shutterSpeed === "number" && !Number.isNaN(exif.shutterSpeed)) {
            entries.push({ label: "Shutter speed", value: `${exif.shutterSpeed.toFixed(2)} EV` });
          }
          if (typeof exif.fNumber === "number" && exif.fNumber > 0) {
            entries.push({ label: "Aperture", value: `ƒ/${exif.fNumber.toFixed(1)}` });
          }
          if (typeof exif.iso === "number" && exif.iso > 0) {
            entries.push({ label: "ISO", value: `ISO ${exif.iso}` });
          }
          if (typeof exif.exposureBias === "number" && !Number.isNaN(exif.exposureBias)) {
            const bias = exif.exposureBias.toFixed(2);
            entries.push({ label: "Exposure bias", value: `${bias} EV` });
          }
          if (typeof exif.focalLength === "number" && exif.focalLength > 0) {
            entries.push({ label: "Focal length", value: `${exif.focalLength.toFixed(1)} mm` });
          }
          if (typeof exif.focalLength35mm === "number" && exif.focalLength35mm > 0) {
            entries.push({ label: "35mm equivalent", value: `${exif.focalLength35mm} mm` });
          }
          if (exif.software) {
            entries.push({ label: "Software", value: exif.software });
          }
          const orientationDescription = describeOrientation(exif.orientation);
          if (orientationDescription) {
            entries.push({ label: "Orientation", value: orientationDescription });
          }
          return entries;
        }

        function renderExif(exif) {
          if (!exifContainer || !exifList) return;
          const entries = formatExifEntries(exif);
          exifList.textContent = "";
          if (!entries.length) {
            exifContainer.hidden = true;
            return;
          }
          entries.forEach(({ label, value }) => {
            const item = document.createElement("div");
            const strong = document.createElement("strong");
            strong.textContent = `${label}:`;
            item.append(strong, document.createTextNode(` ${value}`));
            exifList.appendChild(item);
          });
          exifContainer.hidden = false;
        }

        function renderImage(image) {
          if (!image) {
            renderEmpty();
            return;
          }
          currentId = image.id;
          currentOrientation = typeof image.exif?.orientation === "number" ? image.exif.orientation : 1;
          if (zoomSlider) {
            zoomSlider.value = "100";
          }
          zoom = 100;
          if (preview) {
            const src = image.blobUrl || image.downloadUrl || "";
            if (src) {
              preview.src = src;
            }
            preview.alt = image.alt || image.title || image.name;
            preview.hidden = false;
          }
          if (emptyState) {
            emptyState.hidden = true;
          }
          if (controls) controls.hidden = false;
          if (meta) meta.hidden = false;
          setFit(currentFit || "contain");

          if (nameEl) nameEl.textContent = image.title || image.name;
          if (filenameEl) filenameEl.textContent = image.name;
          if (dimensionsEl) {
            dimensionsEl.textContent = image.width && image.height ? `${image.width} × ${image.height}px` : "—";
          }
          if (sizeEl) sizeEl.textContent = Utils.formatBytes(image.size);
          if (typeEl) typeEl.textContent = image.type || "Unknown";
          if (altEl) altEl.textContent = image.alt || "—";
          if (takenEl) {
            let capturedLabel = "—";
            if (image.capturedAt) {
              const formatted = Utils.formatDateTime(image.capturedAt);
              capturedLabel = formatted !== "—" ? formatted : image.capturedAt;
            } else if (image.exif?.dateTimeOriginal) {
              capturedLabel = image.exif.dateTimeOriginal.replace(/\0/g, "").trim();
            }
            takenEl.textContent = capturedLabel || "—";
          }

          if (linkInput) {
            linkInput.value = image.blobUrl || image.downloadUrl || "";
          }
          if (openLink) {
            if (image.blobUrl || image.downloadUrl) {
              openLink.href = image.blobUrl || image.downloadUrl || "#";
              openLink.removeAttribute("aria-disabled");
            } else {
              openLink.href = "#";
              openLink.setAttribute("aria-disabled", "true");
            }
          }

          renderExif(image.exif);
          applyTransform();
          emitSelectionChange();
          focusCanvas();
        }

        fitButtons.forEach((button) => {
          button.addEventListener("click", () => {
            const fit = button.dataset.imageFit;
            if (!fit) return;
            setFit(fit);
          });
        });

        if (zoomSlider) {
          zoomSlider.addEventListener("input", (event) => {
            setZoom(event.target.value);
          });
          zoomSlider.addEventListener("change", (event) => {
            setZoom(event.target.value);
          });
        }

        ImageStore.subscribe((items) => {
          if (!currentId) {
            if (items.length === 0) {
              renderEmpty();
            }
            return;
          }
          const match = items.find((image) => image.id === currentId);
          if (!match) {
            renderEmpty();
          } else {
            renderImage(match);
          }
        });

        renderEmpty();

        return {
          selectImage(id) {
            const image = ImageStore.getImage(id);
            if (image) {
              renderImage(image);
            } else {
              renderEmpty();
            }
          },
          getSelectedId() {
            return currentId;
          },
        };
      })();

      const ImageGallery = (() => {
        const items = document.querySelector("[data-image-gallery-items]");
        const emptyState = document.querySelector("[data-image-gallery-empty]");
        const searchInput = document.querySelector("[data-image-search]");
        const viewButtons = Array.from(document.querySelectorAll("[data-image-view]"));
        if (!items) return null;
        let images = [];
        let query = "";
        let viewMode = "grid";
        let pendingFocusId = null;

        const observer = typeof IntersectionObserver !== "undefined"
          ? new IntersectionObserver((entries, obs) => {
              entries.forEach((entry) => {
                if (!entry.isIntersecting) return;
                const target = entry.target;
                const src = target.dataset.src;
                if (src) {
                  target.src = src;
                  target.removeAttribute("data-src");
                }
                obs.unobserve(target);
              });
            }, { rootMargin: "120px", threshold: 0.1 })
          : null;

        function getButtonSelector(id) {
          if (!id) return null;
          if (typeof CSS !== "undefined" && CSS.escape) {
            return `.image-gallery__thumb[data-id="${CSS.escape(id)}"]`;
          }
          const safe = String(id).replace(/"/g, '\"');
          return `.image-gallery__thumb[data-id="${safe}"]`;
        }

        function focusItem(id) {
          const selector = getButtonSelector(id);
          if (!selector) return;
          const button = items.querySelector(selector);
          button?.focus({ preventScroll: false });
        }

        function clearObserver() {
          observer?.disconnect();
        }

        function matches(image) {
          if (!query) return true;
          const value = query.toLowerCase();
          const fields = [
            image.title,
            image.name,
            image.type,
            image.alt,
            image.exif?.make,
            image.exif?.model,
            image.exif?.lensModel,
            image.exif?.software,
          ];
          return fields
            .filter(Boolean)
            .some((field) => String(field).toLowerCase().includes(value));
        }

        function syncSelection() {
          const selectedId = ImageViewer.getSelectedId();
          items.querySelectorAll(".image-gallery__thumb").forEach((thumb) => {
            thumb.classList.toggle("is-selected", thumb.dataset.id === selectedId);
            if (thumb.dataset.id === selectedId) {
              thumb.setAttribute("aria-current", "true");
            } else {
              thumb.removeAttribute("aria-current");
            }
          });
        }

        function applyPendingFocus() {
          if (!pendingFocusId) return;
          if (pendingFocusId === "search") {
            searchInput?.focus({ preventScroll: false });
          } else {
            focusItem(pendingFocusId);
          }
          pendingFocusId = null;
        }

        function render() {
          clearObserver();
          items.textContent = "";
          const filtered = images.filter(matches);
          if (emptyState) {
            emptyState.hidden = filtered.length > 0;
          }
          items.classList.toggle("image-gallery__items--grid", viewMode === "grid");
          items.classList.toggle("image-gallery__items--list", viewMode === "list");
          if (filtered.length === 0) {
            syncSelection();
            applyPendingFocus();
            return;
          }

          filtered.forEach((image) => {
            const listItem = document.createElement("li");
            listItem.className = "image-gallery__item";

            const button = document.createElement("button");
            button.type = "button";
            button.className = "image-gallery__thumb";
            button.dataset.id = image.id;
            const labelName = image.title || image.name || Localization.t("common.unknownFile");
            button.setAttribute("aria-label", Localization.t("gallery.selectImage", { name: labelName }));

            const media = document.createElement("span");
            media.className = "image-gallery__thumb-media";
            const img = document.createElement("img");
            img.alt = image.alt || image.title || image.name;
            img.decoding = "async";
            img.loading = "lazy";
            const previewSrc = image.blobUrl || image.downloadUrl;
            if (previewSrc) {
              if (observer) {
                img.dataset.src = previewSrc;
                observer.observe(img);
              } else {
                img.src = previewSrc;
              }
            }
            media.appendChild(img);

            const meta = document.createElement("div");
            meta.className = "image-gallery__thumb-meta";
            const title = document.createElement("span");
            title.className = "image-gallery__meta-title";
            title.textContent = image.title || image.name;
            const subtitle = document.createElement("span");
            subtitle.className = "image-gallery__meta-subtitle";
            subtitle.textContent = image.name;
            const extra = document.createElement("div");
            extra.className = "image-gallery__thumb-extra";
            if (image.width && image.height) {
              const dimensions = document.createElement("span");
              dimensions.textContent = `${image.width}×${image.height}px`;
              extra.appendChild(dimensions);
            }
            if (image.size) {
              const size = document.createElement("span");
              size.textContent = Utils.formatBytes(image.size);
              extra.appendChild(size);
            }
            meta.append(title, subtitle, extra);

            const actions = document.createElement("div");
            actions.className = "image-gallery__thumb-actions";
            const removeButton = document.createElement("button");
            removeButton.type = "button";
            removeButton.className = "image-gallery__delete";
            removeButton.textContent = Localization.t("common.remove");
            removeButton.addEventListener("click", (event) => {
              event.stopPropagation();
              const fallback = listItem.nextElementSibling?.querySelector(".image-gallery__thumb")?.dataset.id
                || listItem.previousElementSibling?.querySelector(".image-gallery__thumb")?.dataset.id
                || "search";
              pendingFocusId = fallback;
              ImageStore.removeImage(image.id)
                .then(() => {
                  Notifications.toast(Localization.t("notifications.imageRemoved"), "info");
                })
                .catch((error) => {
                  console.error("Failed to remove image", error);
                  Notifications.toast(Localization.t("errors.persistFailure"), "error");
                });
            });
            actions.appendChild(removeButton);

            button.append(media, meta, actions);
            button.addEventListener("click", () => {
              ImageViewer.selectImage(image.id);
              syncSelection();
            });

            listItem.appendChild(button);
            items.appendChild(listItem);
          });

          syncSelection();
          applyPendingFocus();
        }

        ImageStore.subscribe((nextImages) => {
          images = nextImages;
          render();
        });

        viewButtons.forEach((button) => {
          button.addEventListener("click", () => {
            const nextView = button.dataset.imageView;
            if (!nextView) return;
            viewMode = nextView;
            viewButtons.forEach((toggle) => {
              toggle.classList.toggle("is-active", toggle.dataset.imageView === nextView);
            });
            render();
          });
        });

        searchInput?.addEventListener("input", (event) => {
          query = event.target.value.trim().toLowerCase();
          render();
        });

        items.addEventListener("keydown", (event) => {
          const targetButton = event.target.closest(".image-gallery__thumb");
          if (!targetButton || event.target !== targetButton) return;
          const id = targetButton.dataset.id;
          if (!id) return;
          if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            ImageViewer.selectImage(id);
            syncSelection();
          } else if (event.key === "Delete") {
            event.preventDefault();
            const listItem = targetButton.closest("li");
            const fallback = listItem?.nextElementSibling?.querySelector(".image-gallery__thumb")?.dataset.id
              || listItem?.previousElementSibling?.querySelector(".image-gallery__thumb")?.dataset.id
              || "search";
            pendingFocusId = fallback;
            ImageStore.removeImage(id)
              .then(() => {
                Notifications.toast(Localization.t("notifications.imageRemoved"), "info");
              })
              .catch((error) => {
                console.error("Failed to remove image", error);
                Notifications.toast(Localization.t("errors.persistFailure"), "error");
              });
          }
        });

        document.addEventListener("imageviewerchange", () => {
          syncSelection();
        });

        return {
          focusItem,
        };
      })();

      const ImageUpload = (() => {
        const form = document.querySelector("[data-image-form]");
        if (!form) return null;
        const fileInput = form.querySelector("[data-image-file-input]");
        const titleInput = form.querySelector("[data-image-title]");
        const altInput = form.querySelector("[data-image-alt]");
        const progressContainer = form.querySelector("[data-image-progress]");
        const progressBar = progressContainer?.querySelector("[data-image-progress-bar]");
        const progressFill = form.querySelector("[data-image-progress-fill]");
        const progressLabel = form.querySelector("[data-image-progress-label]");
        const feedback = form.querySelector("[data-image-feedback]");
        const dropzone = form.querySelector("[data-image-dropzone]");

        function resetFeedback() {
          Notifications.inline(feedback, "");
        }

        function showFeedback(message, tone) {
          Notifications.inline(feedback, message, tone);
        }

        function hideProgress() {
          if (!progressContainer || !progressFill || !progressLabel || !progressBar) return;
          progressContainer.hidden = true;
          progressFill.style.width = "0%";
          progressBar.setAttribute("aria-valuenow", "0");
          progressLabel.textContent = Localization.t("upload.waitingImages");
        }

        function updateProgress(percent, label) {
          if (!progressContainer || !progressFill || !progressLabel || !progressBar) return;
          const clamped = Math.max(0, Math.min(100, percent));
          progressContainer.hidden = false;
          progressFill.style.width = `${clamped}%`;
          progressBar.setAttribute("aria-valuenow", String(Math.round(clamped)));
          if (label) {
            progressLabel.textContent = label;
          }
        }

        function describeError(file, error) {
          const fileName = file?.name ?? Localization.t("common.unknownFile");
          switch (error?.code) {
            case "config":
              return Localization.t("upload.errorMissingConfiguration");
            case "type":
              return Localization.t("upload.errorUnsupportedImage", { name: fileName });
            case "max-dimensions":
              return Localization.t("upload.errorImageTooLarge", {
                name: fileName,
                limit: MAX_IMAGE_DIMENSION,
              });
            case "dimensions":
              return Localization.t("upload.errorImageDimensions", { name: fileName });
            case "quota":
              return Localization.t("notifications.storageQuotaExceeded");
            case "persist":
              return Localization.t("errors.persistFailure");
            default:
              return Localization.t("upload.errorUploadFailed", { name: fileName });
          }
        }

        async function processFiles(fileList) {
          const files = Array.from(fileList ?? []).filter((item) => item instanceof File);
          if (!files.length) {
            const message = Localization.t("upload.errorSelectImages");
            showFeedback(message, "error");
            Notifications.toast(message, "error");
            return;
          }

          resetFeedback();
          let lastImage = null;
          const baseTitle = titleInput?.value.trim() ?? "";
          const baseAlt = altInput?.value.trim() ?? "";
          let warnedLarge = false;

          for (const [index, file] of files.entries()) {
            const estimatedImpact = StorageManager.estimateImpact(file.size);
            const snapshot = StorageManager.getSnapshot();
            if (!StorageManager.canStore(estimatedImpact)) {
              const message = Localization.t("notifications.storageQuotaExceeded");
              showFeedback(message, "error");
              Notifications.toast(message, "error");
              hideProgress();
              return;
            }
            const predictedRatio = snapshot.limit
              ? Math.round(((snapshot.used + estimatedImpact) / snapshot.limit) * 100)
              : 100;
            if (!warnedLarge && predictedRatio >= 85) {
              Notifications.toast(Localization.t("notifications.largeFileWarning"), "info");
              warnedLarge = true;
            }
            updateProgress(
              (index / files.length) * 100,
              Localization.t("upload.validating", { name: file.name })
            );
            try {
              const imageRecord = await ImageStore.createImage(
                file,
                {
                  title: baseTitle
                    ? files.length > 1
                      ? `${baseTitle} (${index + 1})`
                      : baseTitle
                    : undefined,
                  alt: baseAlt
                    ? files.length > 1
                      ? `${baseAlt} (${index + 1})`
                      : baseAlt
                    : undefined,
                },
                (progress) => {
                  const overall = ((index + progress) / files.length) * 100;
                  updateProgress(
                    overall,
                    Localization.t("upload.progress", {
                      name: file.name,
                      percent: Math.round(progress * 100),
                    })
                  );
                }
              );
              lastImage = imageRecord;
            } catch (error) {
              console.error("Image upload failed", error);
              const message = describeError(file, error);
              showFeedback(message, "error");
              Notifications.toast(message, "error");
              hideProgress();
              return;
            }
          }

          const firstImageName = files[0]?.name ?? Localization.t("common.unknownFile");
          const summary =
            files.length > 1
              ? Localization.t("upload.summaryImagesMultiple", { count: files.length })
              : Localization.t("upload.summaryImagesSingle", { name: firstImageName });
          updateProgress(100, summary);
          showFeedback(Localization.t("upload.completeImages"), "success");
          Notifications.toast(Localization.t("notifications.imageUploadSuccess"), "success");
          form.reset();
          if (fileInput) {
            fileInput.value = "";
          }
          setTimeout(() => {
            hideProgress();
          }, 600);
          if (lastImage) {
            ImageViewer.selectImage(lastImage.id);
            if (ImageGallery?.focusItem) {
              window.setTimeout(() => ImageGallery.focusItem(lastImage.id), 0);
            }
          }
        }

        form.addEventListener("submit", (event) => {
          event.preventDefault();
          processFiles(fileInput?.files ?? []);
        });

        form.addEventListener("reset", () => {
          hideProgress();
          resetFeedback();
        });

        fileInput?.addEventListener("change", () => {
          resetFeedback();
        });

        if (dropzone) {
          ["dragenter", "dragover"].forEach((eventName) => {
            dropzone.addEventListener(eventName, (event) => {
              event.preventDefault();
              dropzone.classList.add("is-dragover");
            });
          });

          ["dragleave", "dragend"].forEach((eventName) => {
            dropzone.addEventListener(eventName, () => {
              dropzone.classList.remove("is-dragover");
            });
          });

          dropzone.addEventListener("drop", (event) => {
            event.preventDefault();
            dropzone.classList.remove("is-dragover");
            if (event.dataTransfer?.files?.length) {
              processFiles(event.dataTransfer.files);
            }
          });
        }

        return null;
      })();

      const UploadController = (() => {
        const form = document.getElementById("document-upload-form");
        if (!form) return null;
        const fileInput = form.querySelector("[data-file-input]");
        const titleInput = form.querySelector("[data-title-input]");
        const descriptionInput = form.querySelector("[data-description-input]");
        const progressContainer = form.querySelector("[data-upload-progress]");
        const progressBar = progressContainer?.querySelector(".upload-progress__bar");
        const progressFill = form.querySelector("[data-progress-fill]");
        const progressLabel = form.querySelector("[data-progress-label]");
        const feedback = form.querySelector("[data-upload-feedback]");
        const dropzone = form.querySelector("[data-dropzone]");
        const queueContainer = form.querySelector("[data-upload-queue]");
        const queueList = form.querySelector("[data-queue-list]");
        const queueSummary = form.querySelector("[data-queue-summary]");
        const queueEmpty = form.querySelector("[data-queue-empty]");
        const queueClear = form.querySelector("[data-queue-clear]");

        const pendingFiles = [];
        const pendingKeys = new Set();
        let isUploading = false;

        function buildFileKey(file) {
          return `${file.name}::${file.size}::${file.lastModified}`;
        }

        function getTotalSize() {
          return pendingFiles.reduce((total, file) => total + (Number(file?.size) || 0), 0);
        }

        function resetFeedback() {
          Notifications.inline(feedback, "");
        }

        function showFeedback(message, tone) {
          Notifications.inline(feedback, message, tone);
        }

        function hideProgress() {
          if (!progressContainer || !progressFill || !progressLabel || !progressBar) return;
          progressContainer.hidden = true;
          progressFill.style.width = "0%";
          progressBar.setAttribute("aria-valuenow", "0");
          progressLabel.textContent = Localization.t("upload.waitingDocuments");
        }

        function updateProgress(percent, label) {
          if (!progressContainer || !progressFill || !progressLabel || !progressBar) return;
          const clamped = Math.max(0, Math.min(100, percent));
          progressContainer.hidden = false;
          progressFill.style.width = `${clamped}%`;
          progressBar.setAttribute("aria-valuenow", String(Math.round(clamped)));
          if (label) {
            progressLabel.textContent = label;
          }
        }

        function renderQueue() {
          if (!queueContainer || !queueList) return;
          queueList.textContent = "";
          const hasFiles = pendingFiles.length > 0;
          queueContainer.hidden = !hasFiles;
          if (queueClear) {
            queueClear.disabled = !hasFiles || isUploading;
          }
          if (queueEmpty) {
            queueEmpty.hidden = hasFiles;
          }
          if (!hasFiles) {
            if (queueSummary) {
              queueSummary.hidden = true;
              queueSummary.textContent = "";
            }
            if (progressLabel && (progressContainer?.hidden ?? true)) {
              progressLabel.textContent = Localization.t("upload.waitingDocuments");
            }
            return;
          }

          const totalSize = getTotalSize();
          const sizeText = Utils.formatBytes(totalSize);
          if (queueSummary) {
            const summary =
              pendingFiles.length === 1
                ? Localization.t("upload.queueSummarySingle", {
                    name: pendingFiles[0].name,
                    size: sizeText,
                  })
                : Localization.t("upload.queueSummaryMultiple", {
                    count: pendingFiles.length,
                    size: sizeText,
                  });
            queueSummary.hidden = false;
            queueSummary.textContent = summary;
            if (progressLabel && (progressContainer?.hidden ?? false) && !isUploading) {
              progressLabel.textContent = summary;
            }
          }

          pendingFiles.forEach((file) => {
            const key = buildFileKey(file);
            const item = document.createElement("li");
            item.className = "upload-card__queue-item";
            item.dataset.key = key;

            const details = document.createElement("div");
            const title = document.createElement("strong");
            title.textContent = file.name;
            const meta = document.createElement("p");
            meta.className = "upload-card__queue-meta";
            meta.textContent = Utils.formatBytes(file.size);
            details.append(title, meta);

            const removeButton = document.createElement("button");
            removeButton.type = "button";
            removeButton.className = "upload-card__queue-remove";
            removeButton.dataset.queueRemove = key;
            const removeLabel = Localization.t("common.remove");
            removeButton.textContent = removeLabel;
            removeButton.setAttribute("aria-label", `${removeLabel} ${file.name}`);
            removeButton.disabled = isUploading;

            item.append(details, removeButton);
            queueList.appendChild(item);
          });
        }

        function clearQueue() {
          pendingFiles.splice(0, pendingFiles.length);
          pendingKeys.clear();
          if (fileInput) {
            fileInput.value = "";
          }
          renderQueue();
        }

        function removeFromQueue(key) {
          if (!key) return;
          const index = pendingFiles.findIndex((file) => buildFileKey(file) === key);
          if (index === -1) return;
          const [removed] = pendingFiles.splice(index, 1);
          pendingKeys.delete(key);
          if (removed && progressContainer?.hidden) {
            progressLabel.textContent = pendingFiles.length
              ? progressLabel.textContent
              : Localization.t("upload.waitingDocuments");
          }
          renderQueue();
        }

        function addFiles(fileList) {
          const files = Array.from(fileList ?? []).filter((item) => item instanceof File);
          if (!files.length) {
            return 0;
          }
          let added = 0;
          files.forEach((file) => {
            const key = buildFileKey(file);
            if (pendingKeys.has(key)) {
              return;
            }
            pendingKeys.add(key);
            pendingFiles.push(file);
            added += 1;
          });
          if (added > 0) {
            renderQueue();
          }
          return added;
        }

        async function processFiles(fileList) {
          const files = Array.from(fileList ?? []).filter((item) => item instanceof File);
          if (!files.length) {
            const message = Localization.t("upload.errorSelectDocuments");
            showFeedback(message, "error");
            Notifications.toast(message, "error");
            return;
          }

          resetFeedback();
          isUploading = true;
          renderQueue();

          let lastDocument = null;
          const baseTitle = titleInput?.value.trim() ?? "";
          const description = descriptionInput?.value.trim() ?? "";
          let warnedLarge = false;

          try {
            for (const [index, file] of files.entries()) {
              const estimatedImpact = StorageManager.estimateImpact(file.size);
              const snapshot = StorageManager.getSnapshot();
              if (!StorageManager.canStore(estimatedImpact)) {
                const message = Localization.t("notifications.storageQuotaExceeded");
                showFeedback(message, "error");
                Notifications.toast(message, "error");
                hideProgress();
                return;
              }
              const predictedRatio = snapshot.limit
                ? Math.round(((snapshot.used + estimatedImpact) / snapshot.limit) * 100)
                : 100;
              if (!warnedLarge && predictedRatio >= 85) {
                Notifications.toast(Localization.t("notifications.largeFileWarning"), "info");
                warnedLarge = true;
              }
              updateProgress(
                (index / files.length) * 100,
                Localization.t("upload.progress", { name: file.name, percent: 0 })
              );
              try {
                const documentRecord = await DocumentStore.createDocument(
                  file,
                  {
                    title: baseTitle
                      ? files.length > 1
                        ? `${baseTitle} (${index + 1})`
                        : baseTitle
                      : undefined,
                    description,
                  },
                  (progress) => {
                    const overall = ((index + progress) / files.length) * 100;
                    updateProgress(
                      overall,
                      Localization.t("upload.progress", {
                        name: file.name,
                        percent: Math.round(progress * 100),
                      })
                    );
                  }
                );
                lastDocument = documentRecord;
              } catch (error) {
                console.error("Upload failed", error);
                const fileName = file?.name ?? Localization.t("common.unknownFile");
                const message =
                  error?.code === "config"
                    ? Localization.t("upload.errorMissingConfiguration")
                    : error?.code === "quota"
                    ? Localization.t("notifications.storageQuotaExceeded")
                    : error?.code === "persist"
                    ? Localization.t("errors.persistFailure")
                    : Localization.t("upload.errorUploadFailed", { name: fileName });
                showFeedback(message, "error");
                Notifications.toast(message, "error");
                hideProgress();
                return;
              }
            }

            const firstDocName = files[0]?.name ?? Localization.t("common.unknownFile");
            const summary =
              files.length > 1
                ? Localization.t("upload.summaryDocumentsMultiple", { count: files.length })
                : Localization.t("upload.summaryDocumentsSingle", { name: firstDocName });
            updateProgress(100, summary);
            showFeedback(Localization.t("upload.completeDocuments"), "success");
            Notifications.toast(Localization.t("notifications.documentUploadSuccess"), "success");
            form.reset();
            if (fileInput) {
              fileInput.value = "";
            }
            window.setTimeout(() => {
              hideProgress();
            }, 600);
            if (lastDocument) {
              DocumentViewer.selectDocument(lastDocument.id);
              if (LibraryView?.focusRow) {
                window.setTimeout(() => LibraryView.focusRow(lastDocument.id), 0);
              }
            }
          } finally {
            isUploading = false;
            renderQueue();
          }
        }

        form.addEventListener("submit", (event) => {
          event.preventDefault();
          processFiles([...pendingFiles]);
        });

        form.addEventListener("reset", () => {
          hideProgress();
          resetFeedback();
          clearQueue();
        });

        fileInput?.addEventListener("change", () => {
          resetFeedback();
          if (addFiles(fileInput.files)) {
            if (progressContainer?.hidden) {
              progressLabel.textContent = Localization.t("upload.waitingDocuments");
            }
          }
          if (fileInput) {
            fileInput.value = "";
          }
        });

        queueClear?.addEventListener("click", (event) => {
          event.preventDefault();
          if (!isUploading) {
            clearQueue();
          }
        });

        queueList?.addEventListener("click", (event) => {
          const button = event.target.closest("[data-queue-remove]");
          if (!button || isUploading) return;
          removeFromQueue(button.dataset.queueRemove);
        });

        if (dropzone) {
          ["dragenter", "dragover"].forEach((eventName) => {
            dropzone.addEventListener(eventName, (event) => {
              event.preventDefault();
              dropzone.classList.add("is-dragover");
            });
          });

          ["dragleave", "dragend"].forEach((eventName) => {
            dropzone.addEventListener(eventName, () => {
              dropzone.classList.remove("is-dragover");
            });
          });

          dropzone.addEventListener("drop", (event) => {
            event.preventDefault();
            dropzone.classList.remove("is-dragover");
            if (event.dataTransfer?.files?.length) {
              resetFeedback();
              addFiles(event.dataTransfer.files);
            }
          });
        }

        document.addEventListener("paste", (event) => {
          const files = event.clipboardData?.files;
          if (files?.length) {
            event.preventDefault();
            resetFeedback();
            addFiles(files);
          }
        });

        renderQueue();

        return null;
      })();
    </script>
  </body>
</html>
